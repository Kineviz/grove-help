{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Utilities\n\nA collection of snippets for working with arrays, math, randomness, animation and geometry.\n___`","pinCode":false,"dname":"d46a0c00-9df3-44f2-974a-811e849a2162","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"toc()","pinCode":false,"dname":"9fb98ad6-a463-4fd6-80c1-15346711110d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n## Arrays\n### array\nreturns an array with \\`n\\` elements where each is equal to its index`","pinCode":false,"dname":"2a7075a7-8a66-40bb-969c-f1b82eec3604","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"array = (n => new Array(n).fill(0).map((d, i) => i))","pinCode":false,"dname":"17304990-51ef-410d-bf19-8de380c305a2","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"array(5).map(i => i * 2)","pinCode":false,"dname":"4046b00c-afb6-49c6-becb-d8fca615ec52","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### range\nreturns an array containing values from \\`start\\` to \\`end\\`.  \nOptionnal \\`step\\` between values.`","pinCode":false,"dname":"799f976c-09b2-4692-b528-9775f6cd87e7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"range = ((start, end, step = 1) => array(Math.ceil((end - start + 1) / step)).map((d, i) => start + i * step))","pinCode":false,"dname":"ed710d5d-406c-4cf9-b330-9ce4039c4ded","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"range(6, 12)","pinCode":false,"dname":"8d1b705d-141b-4006-bd2c-7c93fe5c40b7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"range(8, 16, 4)","pinCode":false,"dname":"286977f9-0f55-4e50-a6ed-6e1d01f88e27","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"range(8, 16, 5)","pinCode":false,"dname":"005fe7d7-9e7a-428e-b13e-1ce9e5d4461d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### cut\ncut a range from \\`a\\` to \\`b\\` in \\`n\\` parts and returns the position of the cuts.`","pinCode":false,"dname":"f1ca5e44-574e-443a-b4ec-f715b98ddf4f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"cut = ((a, b, n) => array(n + 1).map(i => a + i * (b - a) / n))","pinCode":false,"dname":"ace41cdc-3e78-4304-8418-e61f31a090eb","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"cut(0, 10, 4)","pinCode":false,"dname":"cca9fd0e-fabc-4bda-8691-be00c3c311ac","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"cut(5, 25, 5)","pinCode":false,"dname":"3fd5a8a5-a8fe-411f-8fcf-94e1a12693dd","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### shiftLeft / shiftRight\nShift elements in array to the left/right. \nElements going out of the array are added at the opposite end/beginning of the array.\n`","pinCode":false,"dname":"f3157aaa-012e-4f27-acb4-a5b37e19a442","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shiftLeft = ((arr, n = 1) => {\n  const copy = [...arr]\n  array(n).forEach(i => copy.push(copy.shift()))\n  return copy\n})","pinCode":false,"dname":"b3671d53-d0cb-4475-8bf0-ef97af2f28c5","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shiftLeft(array(10), 2)","pinCode":false,"dname":"48510324-2178-485b-bc53-4718172083f3","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shiftRight = ((arr, n = 1) => {\n  const copy = [...arr]\n  array(n).forEach(i => copy.unshift(copy.pop()))\n  return copy\n})","pinCode":false,"dname":"d2df53cf-2aa0-482f-93e2-d05fe72ee322","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shiftRight(array(10), 2)","pinCode":false,"dname":"a23aa1a5-1f09-4f82-8c97-56cf4bba553d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### shuffle\nnon destructive shuffle method based on Fisherâ€“Yates shuffle: \nhttps://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle`","pinCode":false,"dname":"27572900-020a-4f5f-8708-d308f8f07236","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shuffle = (arr => {\n  let copy = [...arr] // create a copy of original array\n  for (let i = copy.length - 1; i; i --) {\n    let randomIndex = randInt(i + 1);\n    [copy[i], copy[randomIndex]] = [copy[randomIndex], copy[i]] // swap\n  }\n  return copy\n})","pinCode":false,"dname":"b27a5ff1-02c4-4e8d-b695-ced3017911b1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shuffle(array(10))","pinCode":false,"dname":"0a63f961-ad9f-4336-9562-43c03f69b261","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n## Math\n### Math constants`","pinCode":false,"dname":"50d08bce-2aa9-44d5-b648-ebd793bb947f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"PI = (Math.PI)","pinCode":false,"dname":"0647bd2c-fe30-4ae1-bd28-9fcef6b2094e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"TAU = (Math.PI * 2)","pinCode":false,"dname":"f9dfada6-9746-4e25-bbc4-da41d42bc42e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"goldenRatio = ((1 + Math.sqrt(5)) / 2)","pinCode":false,"dname":"a99a68f9-c6e4-4a03-8f16-018179c8a02e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### Distance`","pinCode":false,"dname":"97f9b0f2-687c-4d3a-a1ff-d6f4b2dc02cd","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"squareDist = (function() {\n  const len = arguments.length / 2\n  return array(len).reduce((acc, d, i) => acc + (arguments[i] - arguments[i + len]) ** 2, 0)\n})","pinCode":false,"dname":"b544146a-92d7-46b0-963e-5c9a62a10ce1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"squareDist(0, 0, 0, 10, 10, 10)","pinCode":false,"dname":"01b72787-9908-44aa-ae27-35fe6680391b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"dist = (function dist() {\n  return Math.sqrt(squareDist(...[...arguments]))\n})","pinCode":false,"dname":"c9d679eb-36d8-4191-a529-2779ae1dc7e8","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"dist(0, 0, 0, 10, 10, 10)","pinCode":false,"dname":"7680aef6-bf1a-41c9-a744-e6bcd26372df","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"manhattanDist = (function() {\n  const len = arguments.length / 2\n  return array(len).reduce((acc, d, i) => acc + Math.abs(arguments[i] - arguments[i + len]), 0)\n})","pinCode":false,"dname":"e368b1be-fec8-4860-b32b-0eb0a47ef675","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"manhattanDist(0, 0, 0, 10, 10, 10)","pinCode":false,"dname":"0ec463e6-b134-4188-b5d5-9673bf80d851","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### lerp\nlinear interpolation between \\`a\\` and \\`b\\` using a normalized value \\`amount\\``","pinCode":false,"dname":"77702d03-a5e7-4f2e-aba4-d8a0f8bc50da","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"lerp = ((a, b, amount, clamped = false) => clamped ? clamp(a + (b - a) * amount, 0, 1) : a + (b - a) * amount)","pinCode":false,"dname":"901a0ef5-ede7-492c-b509-44cb0e5a9d3e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"lerp(27, 38, 0.5)","pinCode":false,"dname":"c8b4d771-92cf-4f7c-be0a-f72e502e992a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### inverseLerp\nget normalized equivalent of \\`value\\` between \\`a\\` and \\`b\\``","pinCode":false,"dname":"61e64ff1-7028-4b25-8636-aa5d16640699","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"inverseLerp = ((a, b, value, clamped = false) => clamped ? (clamp(value, a, b) - a) / (b - a) : (value - a) / (b - a))","pinCode":false,"dname":"c5714219-7bfd-494d-a6a8-48b147cea70e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"inverseLerp(10, 15, 17, true)","pinCode":false,"dname":"48b1b28d-b279-40d2-86ca-4845fda1ecd0","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### mix\nlike \\`lerp\\` but for arrays`","pinCode":false,"dname":"cea47793-e0d4-4cad-979d-2608b5c0f7be","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"mix = ((a, b, amount) => {\n  return a.length === b.length ? a.map((d, i) => lerp(a[i], b[i], amount)) : 'lengths not matching'\n})","pinCode":false,"dname":"ddeb83d4-5113-49e9-88fa-1fe3a6f4b2df","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"mix([2,4,6], [1, 9, 12], 0.5)","pinCode":false,"dname":"83621c2f-8c0e-460b-a953-c3db18d0d11e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### clamp\nclamp a value \\`a\\` between a \\`min\\` and a \\`max\\``","pinCode":false,"dname":"676d14a9-b53c-42f8-98f2-61480f978af4","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"clamp = ((a, min, max) => a < min ? min : a > max ? max : a)","pinCode":false,"dname":"a8587288-defd-4e76-adeb-39bc1a28e326","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"clamp(23, 10, 20)","pinCode":false,"dname":"17d5f86a-c8b0-46e7-ada8-39a1553beaef","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### map\nlinear interpolation from a range \\`[a, b]\\` to another range \\`[c, d]\\``","pinCode":false,"dname":"71e42261-e85e-4ccb-b7e9-5c56dfa6b323","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"map = ((n, a, b, c, d, clamped = false) => {\n  return clamped ? clamp(lerp(c, d, (n - a) / (b - a)), c, d) : lerp(c, d, (n - a) / (b - a))\n})","pinCode":false,"dname":"c1f5b3d5-d756-4f32-a9cb-e5718c200a0c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"map(37, 28, 89, -10, 10)","pinCode":false,"dname":"91df5fae-c91b-46a1-b333-b93ac9d3713a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"map(5, 7, 16, 0, 10)","pinCode":false,"dname":"cccea270-908b-4423-9ef2-6e20d47bb143","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"map(5, 7, 16, 0, 10, true)","pinCode":false,"dname":"0a5dc155-dd62-4f5f-a2b2-5d78827b3631","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### modularDist\nComputes modular distance between 2 values`","pinCode":false,"dname":"51ed9d02-854f-4b6f-9700-958bebca478f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"modularDist = ((value, mod) => Math.min(value % mod, Math.abs(mod - (value % mod))))","pinCode":false,"dname":"9dfa4422-487f-4b56-bf76-cdcd4c99d303","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"modularDist((now/100000) * TAU, PI)","pinCode":false,"dname":"8f2ce4da-7351-40c2-859d-f6cb062ca53a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n## Randomness\n### random`","pinCode":false,"dname":"cf177cd4-6660-49b5-9501-02db2fea38c6","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"random = ((a, b) => {\n  if(Array.isArray(a)) return a[Math.random() * a.length | 0]\n  if(!a && a !== 0) return Math.random()\n  if(!b && b !== 0) return Math.random() * a\n\n  if(a > b) [a, b] = [b, a] // swap values\n  return a + Math.random() * (b - a)\n})","pinCode":false,"dname":"fa653f0a-029c-4172-a872-c9d33c7f3aad","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"random(10, 50)","pinCode":false,"dname":"23613130-0160-4a8e-87c2-4adedfd33eaa","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"random([1, 3, 5])","pinCode":false,"dname":"6ee3a8e7-8705-463e-a2d6-acae0793b713","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### randInt`","pinCode":false,"dname":"612e3aa9-7541-445b-a47e-9e19cb584668","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"randInt = ((a, b) => ~~random(a, b))","pinCode":false,"dname":"810a3353-275f-4cd9-8d2e-88fe3fb85bd0","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"randInt(3, 50)","pinCode":false,"dname":"b0a2c166-0d07-4507-bbda-1aa31e044bdd","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### Seedable Pseudo Random Number Generator`","pinCode":false,"dname":"5556580d-1359-4d28-b5a1-f15c19590204","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Based on https://www.npmjs.com/package/prng`","pinCode":false,"dname":"e87d2a28-a862-460e-966c-21783f20f090","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"PRNG = (require('https://bundle.run/prng@0.0.1'))","pinCode":false,"dname":"100a118f-52fd-49b6-8f91-4e88dba3aa11","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const prng = new PRNG(135)\n  return array(10).map(i => prng.rand(1, 13))\n}","pinCode":false,"dname":"eaa2bf6b-8ec8-442b-b6c6-4b05dc2a3877","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"seededRandom = ((seed) => {\n  const prng = new PRNG(seed)\n  \n  return (a, b) => {\n    const n = 100000\n    if(b) return prng.rand(a * n, b * n) / n\n    if(a) return prng.rand(a * n) / n\n    return prng.rand(n) / n\n  }\n})","pinCode":false,"dname":"486e2c51-def8-435d-9937-7606a0048320","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const prng = seededRandom(135)\n  return array(10).map(i => prng(1, 13))\n}","pinCode":false,"dname":"7f085486-31fc-4872-921e-4598ed27c44c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### coin\nreturns either -1 or 1`","pinCode":false,"dname":"44fa9e34-b8fe-4bc9-8fd7-8191b4fec569","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"coin = (() => random() < .5 ? -1 : 1)","pinCode":false,"dname":"fefa26da-06bf-4346-bd77-7d745cc7458c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### expRand\ncustomizable exponential randomness`","pinCode":false,"dname":"3f9c42b2-5799-4978-bb4f-62870ddf97fa","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"expRand = ((a, b, p = 2) => {\n  if(!a && a !== 0) return Math.random() ** p\n  if(!b && b !== 0) return (Math.random() ** p) * a\n\n  if(a > b) [a, b] = [b, a] // swap values\n  return a + (Math.random() ** p) * (b - a)\n})","pinCode":false,"dname":"5dde5c16-0309-466e-ad9b-f86eb67451b3","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"await visibility(), (() => {\n  const height = 200\n  const nChoices = 200\n  const results = new Array(nChoices).fill(0)\n  const N = 10e5\n  \n  array(N).forEach(() => results[expRand(0, nChoices, power) | 0]++)\n  \n  return svg`<svg width=\"${width}\" height=\"${height}\" style=\"background:black\">\n  ${results.map((d, i) => {\n    const w = (width - 10) / nChoices\n    const h = d/100\n    \n    const x = 5 + w * i\n    return `<rect \n      x=\"${x}\" \n      y=\"${height-h}\" \n      width=\"${w}\" \n      height=\"${h}\" \n      fill=\"white\" \n      stroke=\"black\" \n      stroke-width=\"2\" \n    />\n    <polyline \n      stroke=\"red\" \n      points=\"0 ${height - N/nChoices / 100} ${width} ${height - N/nChoices / 100}\" \n    />`\n  })}\n  </svg>`\n})()","pinCode":false,"dname":"57954be8-7d0e-483e-b619-9d6671970fd1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"power = (4)","pinCode":false,"dname":"57c81c5f-1e09-4d90-9521-dd21c1151b84","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n## Animation helpers`","pinCode":false,"dname":"7079b73a-3932-41cb-a2e0-0b12ef0645f9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### beat\nBased on https://observablehq.com/@mattdesl/heartbeat-function`","pinCode":false,"dname":"acaaf49d-9dac-4573-a4c8-0d761d2e4043","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"beat = ((value, intensity = 2, freq = 1)  => (Math.atan(Math.sin(value * TAU * freq) * intensity) + PI / 2) / PI)","pinCode":false,"dname":"8ffd4640-d487-4c24-a4b4-34effcf86ca4","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### ease`","pinCode":false,"dname":"4987d7db-d61f-4cb5-87bd-656e7d325fa3","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"ease = ((p, g) => !g ? 3 * p * p - 2 * p * p * p :\n  p < 0.5 ? 0.5 * Math.pow(2 * p, g) :\n  1 - 0.5 * Math.pow(2 * (1 - p), g))","pinCode":false,"dname":"947edc52-7a1d-49f2-99df-d9f9996d940b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### softplus`","pinCode":false,"dname":"6761642d-4171-45f6-b65c-71023d9c8038","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"softplus = ((q, p) => {\n  const qq = q + p\n  if(qq <= 0) return 0\n  if(qq >= 2 * p) return qq - p\n  return 1 / (4 * p) * qq * qq\n})","pinCode":false,"dname":"c14ba388-bb1e-4a6a-a560-2c8b1d261137","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`More easing functions can be found on https://observablehq.com/@d3/easing-animations`","pinCode":false,"dname":"c96e47e0-2998-4f89-851b-3f93a66e9cab","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"easing = (require('d3-ease'))","pinCode":false,"dname":"1bb5291d-74a7-40e4-8d19-416c0afd42e3","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\nPorts from Motion Toolkit (https://thebookofshaders.com/examples/?chapter=motionToolKit) for timeline:\n### step`","pinCode":false,"dname":"6bccaf4a-dc32-46be-ab8b-19ca9c10366a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"step = ((x, edge) => x < edge ? 0 : 1)","pinCode":false,"dname":"47a84f2b-02d5-4414-8ba3-85a80ebff2c5","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### smoothstep`","pinCode":false,"dname":"87778e13-07f2-4fce-b87f-650f9244f803","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"smoothstep = ((x, edge0, edge1) => {\n  const t = clamp((x - edge0) / (edge1 - edge0), 0, 1)\n  return t * t * (3 - 2 * t)\n})","pinCode":false,"dname":"977acc75-6ee9-491e-81e1-1c6713f339d4","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### linearstep`","pinCode":false,"dname":"69c921d3-3f38-4368-97b6-e4c5affc8e9f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"linearstep = ((t, begin, end) => clamp((t - begin) / (end - begin), 0, 1))","pinCode":false,"dname":"acc87713-5c02-47ee-9260-7c9a319c5137","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### linearstepUpDown`","pinCode":false,"dname":"e022cd5a-700f-4e24-8d28-6a4ed3300f34","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"linearstepUpDown = ((t, upBegin, upEnd, downBegin, downEnd) => {\n    return linearstep(t, upBegin, upEnd) - linearstep(t, downBegin, downEnd)\n})","pinCode":false,"dname":"326f13c1-f1d4-4eda-9cd9-8c4ab138bd5a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### stepUpDown`","pinCode":false,"dname":"ef83caa1-8aca-4316-ab74-3e328d9828f4","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"stepUpDown = ((t, begin, end) => step(t, begin) - step(t, end))","pinCode":false,"dname":"ee251141-3f30-4b82-96cb-4bb39ea6c89b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n## Working with angles`","pinCode":false,"dname":"f10b23fd-4d88-4658-9603-d851e10c3741","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### radToDeg\nConverts radians to degrees`","pinCode":false,"dname":"e03fa64b-bd48-4d07-aad5-51377fe6f1b9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"radToDeg = (angle => angle / TAU * 360)","pinCode":false,"dname":"c80372b7-76a1-4530-b305-9bf569bda923","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### degToRad\nConverts degrees to radians`","pinCode":false,"dname":"689ade4d-7ec2-4d87-bff3-0bcc037d19ac","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"degToRad = (angle => angle / 360 * TAU)","pinCode":false,"dname":"adbac8e7-f717-4db7-a12d-815a0f9ab0e7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### modAngle\nReturns equivalent angle in range 0 - TAU`","pinCode":false,"dname":"ab3586e1-758f-4593-9088-70061ee1af5d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"modAngle = (angle => ((angle % TAU) + TAU) % TAU)","pinCode":false,"dname":"7396c105-cbd7-4ff3-bed4-3898840508ce","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### lerpAngle\nShortest linear interpolation between angles`","pinCode":false,"dname":"8869a00c-122a-4c0b-922f-7aeabb9c44ff","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"lerpAngle = ((a, b, v) => {\n  let diff = modAngle(b - a)\n  if(diff > PI) diff = -modAngle(a - b)\n  return a + diff * v\n})","pinCode":false,"dname":"bcb238ab-45f0-4999-9f97-d944d3ec59e9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"await visibility(), (() => {\n  const t = now / 2000\n  const prng = new PRNG(t | 0)\n  const a = prng.rand(-TAU * 10, TAU * 10)\n  const u = PVector.fromAngle(a).mag(150)\n  \n  const b = prng.rand(-TAU * 10, TAU * 10)\n  const v = PVector.fromAngle(b).mag(150)\n  \n  const tt = ease(t % 1, 3)\n  const c = lerpAngle(a, b, tt)\n  const w = PVector.fromAngle(c).mag(150)\n  \n  return svg`<svg width=\"400\" height=\"400\">\n    <g transform=\"translate(200, 200)\">\n      <circle r=\"150\" fill=\"none\" stroke=\"black\" />\n\n      <line x2=\"${u.x}\" y2=\"${u.y}\" stroke=\"hsl(0, 50%, 50%)\" />\n      <text \n        fill=\"hsl(0, 50%, 50%)\"\n        transform=\"translate(${u.clone().mag(165).x}, ${u.clone().mag(165).y})\" \n        dominant-baseline=\"middle\" \n        text-anchor=\"middle\"\n      >\n        ${radToDeg(modAngle(a)) | 0}\n      </text>\n\n      <line x2=\"${v.x}\" y2=\"${v.y}\" stroke=\"hsl(270, 50%, 50%)\" />\n      <text \n        fill=\"hsl(270, 50%, 50%)\"\n        transform=\"translate(${v.clone().mag(165).x}, ${v.clone().mag(165).y})\" \n        dominant-baseline=\"middle\" \n        text-anchor=\"middle\"\n      >\n        ${radToDeg(modAngle(b)) | 0}\n      </text>\n\n      <line x2=\"${w.x}\" y2=\"${w.y}\" stroke=\"hsl(${lerp(0, 270, tt) | 0}, 50%, 50%)\" />\n      <text \n        fill=\"hsl(${lerp(0, 270, t) | 0}, 50%, 50%)\"\n        transform=\"translate(${w.clone().mag(165).x}, ${w.clone().mag(165).y})\" \n        dominant-baseline=\"middle\" \n        text-anchor=\"middle\"\n      >\n        ${radToDeg(modAngle(c)) | 0}\n      </text>\n    </g>\n  </svg>`\n})()","pinCode":false,"dname":"e1694788-7d49-420b-a560-2ea3b294223b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n## Geometry\n### Recursive subdivisions`","pinCode":false,"dname":"2ece83bd-8cb0-47bc-8fb7-7a54206aa398","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"divideRect = (function divideRect(x, y, w, h, n, arr, threshold = 0.7, rnd = random) {\n  n--\n\n  if (n >= 0 && rnd() < threshold) {\n    if (w >= h) {\n      let randomW = w * rnd(0.1, 0.9)\n      divideRect(x, y, randomW, h, n, arr, threshold, rnd)\n      divideRect(x+randomW, y, w-randomW, h, n, arr, threshold, rnd)\n    }\n    else {\n      let randomH = h * rnd(0.1, 0.9)\n      divideRect(x, y, w, randomH, n, arr, threshold, rnd)\n      divideRect(x, y+randomH, w, h-randomH, n, arr, threshold, rnd)\n    }\n  }\n  else {\n    arr.push({ x, y, w, h, n })\n  }\n})","pinCode":false,"dname":"1769c185-7b3d-4ffb-9821-173880214c97","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"html`<img src=\"https://d2l930y2yx77uc.cloudfront.net/production/uploads/images/10598462/picture_pc_4504d9feef39b252a1f0d1dc67fabc40.png\" width=\"500\">`","pinCode":false,"dname":"db14b8bc-5b14-4525-8fd2-fb059110ad37","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"divideRect4 = (function divideRect4(x, y, w, h, n, arr, threshold = .7, rnd = Math.random) {\n  n--\n\n  if (n >= 0 && rnd() < threshold) {\n    let hw = w/2\n    let hh = h/2\n\n    divideRect4(x, y, hw, hh, n, arr, threshold, rnd)\n    divideRect4(x+hw, y, hw, hh, n, arr, threshold, rnd)\n    divideRect4(x+hw, y+hh, hw, hh, n, arr, threshold, rnd)\n    divideRect4(x, y+hh, hw, hh, n, arr, threshold, rnd)\n  }\n  else {\n    arr.push({ x, y, w, h, n })\n  }\n})","pinCode":false,"dname":"676dc99f-70e9-49f4-a18a-a50269f252ed","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"html`<img src=\"https://d2l930y2yx77uc.cloudfront.net/production/uploads/images/11173857/picture_pc_7458c35ca8ff1f3b215d5e2cc41ee086.png\" width=\"500\">`","pinCode":false,"dname":"be7866b3-b935-4ac9-aa80-b2c52bd24d56","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### Ray Class`","pinCode":false,"dname":"8c3edc85-de3d-49a5-9ba3-68dfb231d35d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Ray = (class Ray {\n  constructor(pos, dir) {\n    this.pos = pos.clone()\n    this.dir = dir.clone()\n  }\n})","pinCode":false,"dname":"1ff55dca-7829-4677-a254-da4a72a4dd96","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### Segment Class`","pinCode":false,"dname":"25db0930-9ee0-428e-afb2-bc70c77499e0","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Segment = (class Segment { \n  constructor(a, b) {\n    this.a = a.clone()\n    this.b = b.clone()\n    this.center = this.pointAt(0.5)\n    this.dx = this.a.distX(this.b)\n    this.dy = this.a.distY(this.b)\n  }\n  \n  copy() {\n    return new Segment(this.a, this.b)\n  }\n  \n  getLength() {\n    return PVector.sub(this.b, this.a).mag()\n  }\n  \n  getAngle() {\n    return PVector.sub(this.b, this.a).angle2D()\n  }\n  \n  pointAt(n) {\n    return PVector.lerp(this.a, this.b, n)\n  }\n  \n  reduce(n) {\n    const ab = PVector.sub(this.b, this.a).setMag(n)\n    this.a.add(ab)\n    this.b.sub(ab)\n    this.center = this.pointAt(0.5)\n    this.dx = this.a.distX(this.b)\n    this.dy = this.a.distY(this.b)\n  }\n})","pinCode":false,"dname":"483a4ce9-11e5-4937-9fb2-4518d4692558","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### Intersections`","pinCode":false,"dname":"8cccaace-07a7-4580-a22c-ed87bdcc4952","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"raySegIntersection = ((ray, seg) => {\n  // ray is defined by its emitting position (pos) and a direction (dir)\n  // seg is defined between 2 points \"a\" and \"b\"\n  const x1 = seg.a.x\n  const y1 = seg.a.y\n  const x2 = seg.b.x\n  const y2 = seg.b.y\n\n  const x3 = ray.pos.x\n  const y3 = ray.pos.y\n  const x4 = ray.pos.x + ray.dir.x\n  const y4 = ray.pos.y + ray.dir.y\n  \n  const bx = x1 - x2\n  const by = y1 - y2\n\n  const den = bx * (y3 - y4) - by * (x3 - x4)\n  if (den == 0) return undefined\n\n  const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den\n  const u = -(bx * (y1 - y3) - by * (x1 - x3)) / den\n  if (t >= 0 && t <= 1 && u > 0) return PVector(x1 + t * (x2 - x1), y1 + t * (y2 - y1))\n  \n  return null\n})","pinCode":false,"dname":"a62763f7-6533-47b2-962e-ee51d8ce590d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"await visibility(), (() => {\n  const w = 200 \n  const ray = new Ray(PVector.random(PVector(w, w)), PVector.random2D().setMag(1000))\n  const seg = new Segment(PVector.random(PVector(w, w)), PVector.random(PVector(w, w)))\n  const intersection = raySegIntersection(ray, seg)\n  \n  return svg`<svg width=\"${w}\" height=\"${w}\">\n    <rect x=\"0\" y=\"0\" width=\"${w}\" height=\"${w}\" stroke=\"red\" fill=\"none\"/>\n\n    <circle cx=\"${ray.pos.x}\" cy=\"${ray.pos.y}\" fill=\"green\" stroke=\"none\" r=\"3\" />\n    <polyline fill=\"none\" stroke=\"green\" stroke-dasharray=\"3 3\" points=\"${ray.pos.x} ${ray.pos.y} ${ray.pos.x + ray.dir.x} ${ray.pos.y + ray.dir.y}\" />\n\n    <circle cx=\"${seg.a.x}\" cy=\"${seg.a.y}\" fill=\"blue\" stroke=\"none\" r=\"3\" />\n    <circle cx=\"${seg.b.x}\" cy=\"${seg.b.y}\" fill=\"blue\" stroke=\"none\" r=\"3\" />\n    <polyline fill=\"none\" stroke=\"blue\" points=\"${seg.a.x} ${seg.a.y} ${seg.b.x} ${seg.b.y}\" />\n\n    ${intersection ? `<circle fill=\"red\" stroke=\"none\" cx=\"${intersection.x}\" cy=\"${intersection.y}\" r=\"3\" />`: ''}\n  </svg>`\n})()","pinCode":false,"dname":"c6bcfffb-1955-4665-afe6-d27cd0c57916","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"segSegIntersection = (function segSegIntersection(s1, s2) {\n  const x1 = s1.a.x\n  const y1 = s1.a.y\n  const x2 = s1.b.x\n  const y2 = s1.b.y\n\n  const x3 = s2.a.x\n  const y3 = s2.a.y\n  const x4 = s2.b.x\n  const y4 = s2.b.y\n\n  const bx = x2 - x1\n  const by = y2 - y1\n  const dx = x4 - x3\n  const dy = y4 - y3\n\n  const b_dot_d_perp = bx * dy - by * dx\n  if (b_dot_d_perp == 0) return null\n\n  const cx = x3 - x1\n  const cy = y3 - y1\n\n  const t = (cx * dy - cy * dx) / b_dot_d_perp\n  if (t < 0 || t > 1) return null\n\n  const u = (cx * by - cy * bx) / b_dot_d_perp\n  if (u < 0 || u > 1) return null\n\n  return PVector(x1 + t * bx, y1 + t * by)\n})","pinCode":false,"dname":"0ad4a099-b181-480c-8d59-500c79f15e13","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"await visibility(), (() => {\n  const w = 200 \n  const s1 = new Segment(PVector.random(PVector(w, w)), PVector.random(PVector(w, w)))\n  const s2 = new Segment(PVector.random(PVector(w, w)), PVector.random(PVector(w, w)))\n  const intersection = segSegIntersection(s1, s2)\n  return svg`<svg width=\"${w}\" height=\"${w}\">\n    <rect x=\"0\" y=\"0\" width=\"${w}\" height=\"${w}\" stroke=\"red\" fill=\"none\"/>\n\n    <circle cx=\"${s1.a.x}\" cy=\"${s1.a.y}\" fill=\"green\" stroke=\"none\" r=\"3\" />\n    <circle cx=\"${s1.b.x}\" cy=\"${s1.b.y}\" fill=\"green\" stroke=\"none\" r=\"3\" />\n    <polyline fill=\"none\" stroke=\"green\" points=\"${s1.a.x} ${s1.a.y} ${s1.b.x} ${s1.b.y}\" />\n\n    <circle cx=\"${s2.a.x}\" cy=\"${s2.a.y}\" fill=\"blue\" stroke=\"none\" r=\"3\" />\n    <circle cx=\"${s2.b.x}\" cy=\"${s2.b.y}\" fill=\"blue\" stroke=\"none\" r=\"3\" />\n    <polyline fill=\"none\" stroke=\"blue\" points=\"${s2.a.x} ${s2.a.y} ${s2.b.x} ${s2.b.y}\" />\n    ${intersection ? `<circle fill=\"red\" stroke=\"none\" cx=\"${intersection.x}\" cy=\"${intersection.y}\" r=\"3\" />`: ''}\n  </svg>`\n})()","pinCode":false,"dname":"15c5c064-25f8-46a4-ba8d-4ee99ee07c13","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"lineLineIntersection = ((p0, p1, p2, p3) => {\n  const A1 = p1.y - p0.y\n  const B1 = p0.x - p1.x\n  const C1 = A1 * p0.x + B1 * p0.y\n  const A2 = p3.y - p2.y\n  const B2 = p2.x - p3.x\n  const C2 = A2 * p2.x + B2 * p2.y\n  const denominator = A1 * B2 - A2 * B1\n\n  if(denominator == 0) return null\n\n  return PVector((B2 * C1 - B1 * C2) / denominator, (A1 * C2 - A2 * C1) / denominator)\n})","pinCode":false,"dname":"5284c97c-e2af-477f-b36a-19e6dee8bba6","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"await visibility(), (() => {\n  const w = 200 \n  const p0 = PVector.random(PVector(w, w))\n  const p1 = PVector.random(PVector(w, w))\n  const proj1 = p0.clone().sub(p1).mag(1000)\n  \n  const p2 = PVector.random(PVector(w, w))\n  const p3 = PVector.random(PVector(w, w))\n  const proj2 = p2.clone().sub(p3).mag(1000)\n  \n  const intersection = lineLineIntersection(p0, p1, p2, p3)\n  \n  return svg`<svg width=\"${w}\" height=\"${w}\">\n  <rect x=\"0\" y=\"0\" width=\"${w}\" height=\"${w}\" stroke=\"red\" fill=\"none\"/>\n\n  <circle cx=\"${p0.x}\" cy=\"${p0.y}\" fill=\"green\" stroke=\"none\" r=\"3\" />\n  <circle cx=\"${p1.x}\" cy=\"${p1.y}\" fill=\"green\" stroke=\"none\" r=\"3\" />\n  <polyline fill=\"none\" stroke-dasharray=\"3 5\" stroke=\"green\" points=\"${p0.x + proj1.x} ${p0.y + proj1.y} ${p1.x - proj1.x} ${p1.y - proj1.y}\" />\n\n  <circle cx=\"${p2.x}\" cy=\"${p2.y}\" fill=\"blue\" stroke=\"none\" r=\"3\" />\n  <circle cx=\"${p3.x}\" cy=\"${p3.y}\" fill=\"blue\" stroke=\"none\" r=\"3\" />\n  <polyline fill=\"none\" stroke-dasharray=\"3 5\" stroke=\"blue\" points=\"${p2.x + proj2.x} ${p2.y + proj2.y} ${p3.x - proj2.x} ${p3.y - proj2.y}\" />\n\n  ${intersection ? `<circle fill=\"red\" stroke=\"none\" cx=\"${intersection.x}\" cy=\"${intersection.y}\" r=\"3\" />`: ''}\n  </svg>`\n})()","pinCode":false,"dname":"b6667b50-0e4b-4990-ab73-215b6a2499dc","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### Polygon Class`","pinCode":false,"dname":"728d78a6-142f-4598-89ab-f8fec4c9864f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Polygon = (class Polygon {\n  // create a new Polygon from SVG path string\n  static fromPath(path, lengthBetweenPts = 5) {\n    const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n    pathElement.setAttribute('d', path)\n    const pathLength = pathElement.getTotalLength()\n    const poly = new Polygon(...array(pathLength / lengthBetweenPts | 0).map(i => {\n      return PVector(pathElement.getPointAtLength(i * lengthBetweenPts))\n    }))\n    poly.originalPath = path\n    return poly\n  }\n\n  // Boolean operations using ClipperLib\n  // https://sourceforge.net/p/jsclipper/wiki/Home%206/\n  static intersection(p1, p2) {\n    const INTERSECTION = ClipperLib.ClipType.ctIntersection\n    return Polygon.boolOp(INTERSECTION, p1, p2)\n  }\n  static union(p1, p2) {\n    const UNION = ClipperLib.ClipType.ctUnion\n    return Polygon.boolOp(UNION, p1, p2)\n  }\n  static diff(p1, p2) {\n    const DIFF = ClipperLib.ClipType.ctDifference\n    return Polygon.boolOp(DIFF, p1, p2)\n  }\n  static xor(p1, p2) {\n    const XOR = ClipperLib.ClipType.ctXor\n    return Polygon.boolOp(XOR, p1, p2)\n  }\n  static boolOp(type, p1, p2) {\n    const polygonToClipperPath = p => p.pts.map(pt => ({ X: pt.x * 100, Y: pt.y * 100 }))\n    const subj_paths = [polygonToClipperPath(p1)]\n    const clip_paths = [polygonToClipperPath(p2)]\n\n    const clipper = new ClipperLib.Clipper();\n    const SUBJECT = ClipperLib.PolyType.ptSubject // 0\n    const CLIP = ClipperLib.PolyType.ptClip // 1\n    clipper.AddPaths(subj_paths, SUBJECT, true)\n    clipper.AddPaths(clip_paths, CLIP, true)\n\n    const result = [];\n\n    const EVEN_ODD = ClipperLib.PolyFillType.pftEvenOdd // 0\n    const NON_ZERO = ClipperLib.PolyFillType.pftNonZero // 1\n    const POSITIVE = ClipperLib.PolyFillType.pftPositive // 2\n    const NEGATIVE = ClipperLib.PolyFillType.pftNegative // 3\n    clipper.Execute(type, result, NON_ZERO, NON_ZERO)\n\n    return result.map(pts => new Polygon(...pts.map(pt => PVector(pt.X / 100, pt.Y / 100))))\n  }\n\n  // offset done using ClipperLib\n  // https://sourceforge.net/p/jsclipper/wiki/Home%206/#b-offsetting-paths\n  static offset(p, delta, type = 'round') {\n    // scale up coords since Clipper is using integer\n    const scale = 1000\n    let paths = [p.pts.map(pt => ({ X: pt.x * scale, Y: pt.y * scale }))]\n\n    // Simplifying\n    paths = ClipperLib.Clipper.SimplifyPolygons(paths, ClipperLib.PolyFillType.pftNonZero)\n\n    // Cleaning\n    var cleandelta = 0.1 // 0.1 should be the appropriate delta in different cases\n    paths = ClipperLib.JS.Clean(paths, cleandelta * scale)\n\n    // Create an instance of ClipperOffset object\n    var co = new ClipperLib.ClipperOffset()\n    \n    const jointType = type === 'miter' ? ClipperLib.JoinType.jtMiter :\n      type === 'square' ? ClipperLib.JoinType.jtSquare :\n      ClipperLib.JoinType.jtRound\n    \n    // Add paths\n    co.AddPaths(paths, jointType, ClipperLib.EndType.etClosedPolygon)\n    \n    // Create an empty solution and execute the offset operation\n    let offsetted_paths = new ClipperLib.Paths()\n    co.Execute(offsetted_paths, delta * scale)\n\n    ClipperLib.JS.ScaleDownPaths(offsetted_paths, scale)\n    if(!(offsetted_paths[0] && offsetted_paths[0].length > 0)) return null\n    return new Polygon(...offsetted_paths[0].map(pt => PVector(pt.X, pt.Y)))\n  }\n\n  constructor(...pts) {  \n    this.pts = pts.map(pt => pt.clone())\n    this.segments = pts.map((pt, i) => new Segment(pt, pts[(i + 1 ) % pts.length]))\n    this.center = new PVector(pts.reduce((acc, d) => PVector.add(acc, d), PVector())).div(pts.length)\n  }\n\n  // adapted from https://www.codeproject.com/tips/84226/is-a-point-inside-a-polygon\n  contains(pt) {\n    const pts = this.pts\n    let c = false\n    for (let i = 0, j = pts.length-1; i < pts.length; j = i++) {\n      if (\n        ((pts[i].y > pt.y) != (pts[j].y > pt.y)) && \n        (pt.x < (pts[j].x-pts[i].x) * (pt.y-pts[i].y) / (pts[j].y-pts[i].y) + pts[i].x)\n      ) {\n        c = !c\n      }\n    }\n    return c\n  }\n\n  getBoundingBox() {\n    const xs = this.pts.map(pt => pt.x)\n    const ys = this.pts.map(pt => pt.y)\n    const minX = Math.min(...xs)\n    const maxX = Math.max(...xs)\n    const minY = Math.min(...ys)\n    const maxY = Math.max(...ys)\n    return {\n      origin: PVector(minX, minY),\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  }\n\n  getHatches(originalAngle = PI/2, spacing = 2, offset = 0, alternate = false) {\n    if(offset !== 0) return Polygon.offset(this, -offset).getHatches(originalAngle, spacing, 0, alternate)\n    \n    //bounding box\n    const originalBB = this.getBoundingBox()\n    const bb = {\n      origin: originalBB.origin.clone().sub(spacing * 2),\n      width: originalBB.width + 4 * spacing,\n      height: originalBB.height + 4 * spacing\n    }\n\n    // hashes\n    let angle = ((originalAngle % TAU) + TAU) % PI\n    if(angle > PI/2) angle -= PI\n    if(modularDist(angle, PI/2) < 0.00001) angle += 0.00001\n    const hatchDirOriginal = PVector.fromAngle(originalAngle).setMag(1000)\n    const hatchDir = PVector.fromAngle(angle).setMag(1000)\n\n    let startY, endY\n    let leftPoint, rightPoint\n\n    if(angle < 0) {\n      rightPoint = bb.origin.clone().add(PVector(bb.width, bb.height))\n      startY = bb.origin.y\n      endY = lineLineIntersection(\n        bb.origin, \n        bb.origin.clone().addY(bb.height),\n        rightPoint,\n        rightPoint.clone().sub(hatchDir)\n      ).y\n      leftPoint = PVector(bb.origin.x, endY)\n    }\n    else {\n      rightPoint = bb.origin.clone().addX(bb.width)\n      startY = lineLineIntersection(\n        bb.origin, \n        bb.origin.clone().addY(bb.height),\n        rightPoint,\n        rightPoint.clone().sub(hatchDir)\n      ).y\n      endY = bb.origin.y + bb.height\n      leftPoint = PVector(bb.origin.x, startY)\n    }\n\n    const segA = new Segment(PVector(bb.origin.x, startY), PVector(bb.origin.x, endY))\n    const segB = new Segment(leftPoint, rightPoint)\n\n    const step = hatchDir.clone().rotateBy(PI/2).setMag(spacing)\n    const stepProjection = hatchDir.clone().mult(angle < 0 ? -1 : 1).add(step)\n    const stepIntersection = lineLineIntersection(segA.a, segA.b, PVector.add(bb.origin, step), PVector.add(bb.origin, stepProjection))\n    const stepY = stepIntersection.y - bb.origin.y\n\n    const hatches = array(((endY - startY) / stepY | 0) + 1).map(i => {\n      const A = PVector(bb.origin.x, startY + i * stepY)\n      const B = A.clone().add(hatchDir)\n      const ray = new Ray(A, hatchDir)\n\n      const intersections = this.segments.map(seg => raySegIntersection(ray, seg))\n      .filter(d => d)\n      .sort((a, b) => a.y > b.y ? 1 : \n            a.y < b.y ? -1 : \n            a.x > b.x ? 1 :\n            a.x < b.x ? -1 : 0)\n\n      if(intersections.length < 2) return null\n\n      if(alternate && i % 2) intersections.reverse()\n\n      const segments = []\n      for(let i = 0; i < intersections.length && intersections[i + 1]; i += 2) {\n        segments.push(new Segment(intersections[i], intersections[i + 1]))\n      }\n      return segments\n    }).filter(d => d).flat().filter(seg => this.contains(seg.pointAt(0.3)))\n\n    return hatches\n  }\n})","pinCode":false,"dname":"69d48552-cc92-45b9-85c8-de66fa7a725e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"p = (new Polygon(...array(5).map(i => PVector(20 + Math.cos(Math.PI * 2 / 5 * i) * 20, 30 + Math.sin(Math.PI * 2 / 5 * i) * 20))))","pinCode":false,"dname":"6f9e09ae-e84a-4d63-a883-5e69c1de5cf8","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Hatching`","pinCode":false,"dname":"e33f843f-3a96-4856-a235-5b26ce2fe71c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"await visibility(), (() => {\n  const w = width\n  const h = 300\n  const originalAngle = random(-TAU, TAU)\n  const spacing = 15//randInt(2, 25)\n  const offset = 15\n  \n  // polygon\n  const n = randInt(3, 30)\n  // const p = new Polygon(...array(n).map(i => {\n  //   const angle = TAU / n * i\n  //   const rad = 100\n  //   const x = w/2 + Math.cos(angle) * rad\n  //   const y = h/2 + Math.sin(angle) * rad\n  //   return PVector(x, y)\n  // }))\n  const p = new Polygon(...array(n).map(i => {\n    const angle = TAU / n * i\n    const x = w/2 + Math.cos(angle) * random(20, w/2)\n    const y = h/2 + Math.sin(angle) * random(20, h/2)\n    return PVector(x, y)\n  }))\n  \n  //bounding box\n  const bb = p.getBoundingBox()\n  \n  // hashes\n  let angle = ((originalAngle % TAU) + TAU) % PI\n  if(angle > PI/2) angle -= PI\n  const hatchDirOriginal = PVector.fromAngle(originalAngle).setMag(1000)\n  const hatchDir = PVector.fromAngle(angle).setMag(1000)\n  \n  let startY, endY\n  let leftPoint, rightPoint\n  \n  if(angle < 0) {\n    rightPoint = bb.origin.clone().add(PVector(bb.width, bb.height))\n    startY = bb.origin.y - 5\n    endY = lineLineIntersection(\n      bb.origin, \n      bb.origin.clone().addY(bb.height),\n      rightPoint,\n      rightPoint.clone().sub(hatchDir)\n    ).y + 5\n    leftPoint = PVector(bb.origin.x, endY)\n  }\n  else {\n    rightPoint = bb.origin.clone().addX(bb.width)\n    startY = lineLineIntersection(\n      bb.origin, \n      bb.origin.clone().addY(bb.height),\n      rightPoint,\n      rightPoint.clone().sub(hatchDir)\n    ).y - 5\n    endY = bb.origin.y + bb.height + 5\n    leftPoint = PVector(bb.origin.x, startY)\n  }\n  \n  const segA = new Segment(PVector(bb.origin.x, startY), PVector(bb.origin.x, endY))\n  const segB = new Segment(leftPoint, rightPoint)\n  \n  const step = hatchDir.clone().rotateBy(PI/2).setMag(spacing)\n  const stepProjection = hatchDir.clone().mult(angle < 0 ? -1 : 1).add(step)\n  const stepIntersection = lineLineIntersection(segA.a, segA.b, PVector.add(bb.origin, step), PVector.add(bb.origin, stepProjection))\n  const stepY = stepIntersection.y - bb.origin.y\n  \n  const hatches = [\n    ...p.getHatches(originalAngle, spacing, offset, true),\n    // ...p.getHatches(originalAngle + random(TAU), spacing),\n    // ...p.getHatches(originalAngle + random(TAU), spacing)\n  ]\n  \n  return svg`<svg width=\"${w}\" height=\"${h}\">\n    ${pathFromPolygon(p, 'fill=\"none\" stroke=\"black\" stroke-width=\"3\"')}\n    \n    <g transform=\"translate(${bb.origin.x}, ${bb.origin.y})\">\n      <!-- bounding box origin -->\n      <circle r=\"5\" fill=\"red\" />\n      \n      <!-- bounding box -->\n      <rect \n        stroke=\"red\" \n        stroke-dasharray=\"3 5\" \n        fill=\"none\"\n        width=\"${bb.width}\" \n        height=\"${bb.height}\"\n      />\n      \n      <!-- hatches with orignal angle -->\n      <line x2=\"${hatchDirOriginal.x}\" y2=\"${hatchDirOriginal.y}\" stroke=\"cyan\" stroke-dasharray=\"3\" />\n      <!-- hatches with computed angle -->\n      <line x2=\"${hatchDir.x}\" y2=\"${hatchDir.y}\" stroke=\"red\" />\n      <!-- hatches step --> \n      <line x2=\"${step.x}\" y2=\"${step.y}\" stroke=\"black\" stroke-dasharray=\"3\" />\n      <line x1=\"${step.x}\" y1=\"${step.y}\" x2=\"${stepProjection.x}\" y2=\"${stepProjection.y}\" stroke=\"black\" stroke-dasharray=\"3\" />\n    </g>\n    <line\n      x1=\"${segA.a.x}\"\n      y1=\"${segA.a.y}\"\n      x2=\"${segA.b.x}\"\n      y2=\"${segA.b.y}\"\n      stroke=\"blue\"\n    />\n    \n    <line\n      x1=\"${segB.a.x}\"\n      y1=\"${segB.a.y}\"\n      x2=\"${segB.b.x}\"\n      y2=\"${segB.b.y}\"\n      stroke=\"blue\"\n      stroke-dasharray=\"3 10\"\n    />\n    <circle cx=\"${segA.a.x}\" cy=\"${segA.a.y}\" r=\"5\" fill=\"blue\" />\n    <circle cx=\"${segA.b.x}\" cy=\"${segA.b.y}\" r=\"5\" fill=\"blue\" />\n\n    <circle cx=\"${stepIntersection.x}\" cy=\"${stepIntersection.y}\" r=\"5\" fill=\"green\" />\n\n    ${linesFromHatches(hatches, 'opacity=\"0.3\" stroke=\"black\" stroke-width=\"3\"')}\n\n    ${pathFromHatches(hatches, 'opacity=\"0.5\" stroke=\"blue\" stroke-dasharray=\"5\" fill=\"none\"')}\n\n    <!-- Infos -->\n    <!--\n    <g transform=\"translate(15, 15)\">\n      <text>Bounding box</text>\n      <text y=\"15\">x: ${bb.origin.x | 0}</text>\n      <text y=\"30\">y: ${bb.origin.y | 0}</text>\n      <text y=\"45\">width: ${bb.width | 0}</text>\n      <text y=\"60\">height: ${bb.height | 0}</text>\n    </g>\n\n    <g transform=\"translate(150, 15)\">\n      <text>Hatches</text>\n      <text y=\"15\">originalAngle: ${((originalAngle*100)|0)/100}</text>\n      <text y=\"30\">angle: ${((angle*100)|0)/100}</text>\n    </g>\n    -->\n  </svg>`\n})()","pinCode":false,"dname":"2ae3b9b5-4f85-463c-9962-015ffde0cb4a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Boolean operations`","pinCode":false,"dname":"0ca77146-d616-4ef4-8af0-5434142a0cdb","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"await visibility(), (() => {\n  const w = width\n  const h = 300\n  const p1 = new Polygon(...array(360).map(i => {\n    return PVector(w/2 + Math.cos(TAU/360*i) * (h/2 - 30), h/2 + 20 + Math.sin(TAU/360*i) * (h/2 - 30))\n  }))\n  \n  const p2 = Polygon.fromPath(`M${Math.sin(now/700) * 150 + w/2-150 | 0},${h-30} L${Math.sin(now/700) * 150 + w/2 | 0},30 L${Math.sin(now/700) * 150 + w/2+150 | 0},${h-30} Z`, 1)\n  // const p2 = Polygon.fromPath(`M${150 + w/2-150 | 0},${h-30} L${150 + w/2 | 0},30 L${150 + w/2+150 | 0},${h-30} Z`, 1)\n  \n  const op = ['union', 'intersection', 'diff', 'xor']\n  const result = Polygon.boolOp(((now/1400) | 0) % op.length, p2, p1)\n  \n  return svg`<svg width=\"${w}\" height=\"${h}\">\n    <path stroke=\"none\" opacity=\"1\" fill=\"black\" d=\"${p1.pts.map((d, i) => `${i === 0 ? 'M' : 'L'}${d.x},${d.y}`)} Z\" />\n    <path stroke=\"none\" opacity=\"0.7\" fill=\"white\" d=\"${p2.pts.map((d, i) => `${i === 0 ? 'M' : 'L'}${d.x},${d.y}`)} Z\" />\n    ${(() => {\n      if(result) {\n        return result.map(p => `<path stroke=\"red\" stroke-width=\"5\" fill=\"none\" d=\"${p.pts.map((d, i) => `${i === 0 ? 'M' : 'L'}${d.x},${d.y}`)} Z\" />`).join('\\n')\n      }\n    })()}\n  </svg>`\n})()","pinCode":false,"dname":"64522723-de41-4160-aa0d-254aefd21213","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Offsetting`","pinCode":false,"dname":"476e2e89-0779-44e4-af96-f2f35f7fb1aa","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"await visibility(), (() => {\n  const w = 300\n  const h = 300\n\n  const N = 24\n  const p = new Polygon(...array(N).map(i => {\n    const angle = TAU/N * i - PI/2\n    const radius = 70 + (i % 2) * 40\n    return PVector(w/2 + Math.cos(angle) * radius, h/2 + Math.sin(angle) * radius)\n  }))\n\n  const p2 = Polygon.offset(p, Math.sin(now/500) * 30, 'round')\n\n  return svg`<svg width=\"${w}\" height=\"${h}\">\n    <path fill=\"none\" stroke=\"black\" stroke-width=\"3\" d=\"${pathFromPolygon(p)}\" />\n    <path fill=\"none\" stroke=\"red\" d=\"${pathFromPolygon(p2)}\" />\n  </svg>`\n})()","pinCode":false,"dname":"90933271-da9c-4b05-bbe9-b665aa822539","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### Alternate hatching with multiple Polygons`","pinCode":false,"dname":"488d3015-409d-4113-ade7-d5150bd2c4d3","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"hatchMultiplePolygons = ((polys = [], originalAngle = 0, spacing = 2, alternate = false) => {\n  const boundingPoly = new Polygon(...polys.map(p => p.pts).flat())\n  //bounding box\n  const originalBB = boundingPoly.getBoundingBox()\n  const bb = {\n    origin: originalBB.origin.clone().sub(spacing * 2),\n    width: originalBB.width + 4 * spacing,\n    height: originalBB.height + 4 * spacing\n  }\n\n  // hashes\n  let angle = ((originalAngle % TAU) + TAU) % PI\n  if(angle > PI/2) angle -= PI\n    if(modularDist(angle, PI/2) < 0.00001) angle += 0.00001\n  const hatchDirOriginal = PVector.fromAngle(originalAngle).setMag(1000)\n  const hatchDir = PVector.fromAngle(angle).setMag(1000)\n\n  let startY, endY\n  let leftPoint, rightPoint\n\n  if(angle < 0) {\n    rightPoint = bb.origin.clone().add(PVector(bb.width, bb.height))\n    startY = bb.origin.y\n    endY = lineLineIntersection(\n      bb.origin, \n      bb.origin.clone().addY(bb.height),\n      rightPoint,\n      rightPoint.clone().sub(hatchDir)\n    ).y\n    leftPoint = PVector(bb.origin.x, endY)\n  }\n  else {\n    rightPoint = bb.origin.clone().addX(bb.width)\n    startY = lineLineIntersection(\n      bb.origin, \n      bb.origin.clone().addY(bb.height),\n      rightPoint,\n      rightPoint.clone().sub(hatchDir)\n    ).y\n    endY = bb.origin.y + bb.height\n    leftPoint = PVector(bb.origin.x, startY)\n  }\n\n  const segA = new Segment(PVector(bb.origin.x, startY), PVector(bb.origin.x, endY))\n  const segB = new Segment(leftPoint, rightPoint)\n\n  const step = hatchDir.clone().rotateBy(PI/2).setMag(spacing)\n  const stepProjection = hatchDir.clone().mult(angle < 0 ? -1 : 1).add(step)\n  const stepIntersection = lineLineIntersection(segA.a, segA.b, PVector.add(bb.origin, step), PVector.add(bb.origin, stepProjection))\n  const stepY = stepIntersection.y - bb.origin.y\n\n  const hatches = array(((endY - startY) / stepY | 0) + 1).map(i => {\n    const A = PVector(bb.origin.x, startY + i * stepY)\n    const B = A.clone().add(hatchDir)\n    const ray = new Ray(A, hatchDir)\n\n    const intersections = polys.map(p => p.segments).flat().map(seg => raySegIntersection(ray, seg))\n      .filter(d => d)\n      .sort((a, b) => a.y > b.y ? 1 : \n            a.y < b.y ? -1 : \n            a.x > b.x ? 1 :\n            a.x < b.x ? -1 : 0)\n\n    if(intersections.length < 2) return null\n\n    if(alternate && i % 2) intersections.reverse()\n\n    const segments = []\n    for(let i = 0; i < intersections.length && intersections[i + 1]; i += 2) {\n      segments.push(new Segment(intersections[i], intersections[i + 1]))\n    }\n    return segments\n  }).filter(d => d).flat()\n\n  return hatches\n})","pinCode":false,"dname":"d50b16db-2bad-4fd7-bc6f-dcbf1e8a2199","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"await visibility(), (() => {\n  const w = width\n  const h = 400\n  const center = PVector(w/2, h/2)\n  const p1 = new Polygon(...array(12).map(i => PVector(Math.cos(TAU/12 * i)*h/2, Math.sin(TAU/12 * i)*h/2).add(center)))\n  const p2 = new Polygon(...array(12).map(i => PVector(Math.cos(TAU/12 * i)*(h/2 - 50), Math.sin(TAU/12 * i)*(h/2 - 50)).add(center)))\n  const p3 = new Polygon(...array(12).map(i => PVector(Math.cos(TAU/12 * i)*(h/2 - (i%2?75 : -30)), Math.sin(TAU/12 * i)*(h/2 - (i%2?75 : -30))).add(center)))\n  const hatches = hatchMultiplePolygons([p1, p2, p3])\n  \n  const basicStyle = 'fill=\"none\" stroke-width=\"4\"'\n  return svg`<svg width=\"${w}\" height=\"${h}\">\n    ${pathFromPolygon(p1, `${basicStyle} stroke=\"red\"`)}\n    ${pathFromPolygon(p2, `${basicStyle} stroke=\"blue\"`)}\n    ${pathFromPolygon(p3, `${basicStyle} stroke=\"green\"`)}\n    ${linesFromHatches(hatches, 'stroke=\"blue\"', true)}\n    ${hatches.map(seg => `<line stroke=\"blue\" x1=\"${seg.a.x}\" y1=\"${seg.a.y}\" x2=\"${seg.b.x}\" y2=\"${seg.b.y}\" />`).join('\\n')}\n  </svg>`\n})()","pinCode":false,"dname":"1c92b8eb-3fed-462c-b0ee-be9ce44b3b1d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`### SVG utilities for Polygon class`","pinCode":false,"dname":"743ab6cb-5ba2-430d-8d79-7bd9ec815758","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"pathFromPolygon = ((p, style) => {\n  const path = p.originalPath ? p.originalPath : `${p.pts.map((pt, i) => `${i === 0 ? 'M' : 'L'}${pt.x} ${pt.y}`).join(' ')} Z`\n  \n  if(style) return `<path ${style} d=\"${path}\" />`\n  else return path\n})","pinCode":false,"dname":"83fadb2d-fd32-4470-bf2a-ab4f8e3a2c10","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"pathFromHatches = ((hatches, style) => {\n  const path = `${hatches.map((seg, i) => `${i === 0 ? 'M' : 'L'}${seg.a.x} ${seg.a.y} L${seg.b.x} ${seg.b.y}`).join(' ')}`\n  \n  if(style) return `<path ${style} d=\"${path}\" />`\n  return path\n})","pinCode":false,"dname":"850cfeb3-dbc6-4fcb-9903-89a19ff9bce6","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"linesFromHatches = ((hatches, style, alternate = false) => hatches.map((seg, i) => {\n  let {a, b} = seg\n  if(alternate && i % 2) [a, b] = [b, a]\n  return `<line\n    ${style}\n    x1=\"${a.x}\" y1=\"${a.y}\" \n    x2=\"${b.x}\" y2=\"${b.y}\"\n  />`\n}).join(' '))","pinCode":false,"dname":"e0cd429a-ddc3-48db-93c2-33ad0e87bf6f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n### Triangle Class`","pinCode":false,"dname":"a1c7b32e-6db2-48f7-a8ba-fd3d9945ddce","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"await visibility(), (() => {\n  const w = width\n  const h = 500\n  const a = PVector.random2D().setMag(200).add(PVector(w/2 + randInt(-10, 11), h/2 + randInt(-10, 11)))\n  const b = PVector.random2D().setMag(200).add(PVector(w/2 + randInt(-10, 11), h/2 + randInt(-10, 11)))\n  const c = PVector.random2D().setMag(200).add(PVector(w/2 + randInt(-10, 11), h/2 + randInt(-10, 11)))\n  \n  const t = new Triangle(a, b, c)\n  \n  return svg`<svg width=\"${w}\" height=\"${h}\" viewBox=\"0 0 ${w} ${h}\">\n    <rect x=\"0\" y=\"0\" width=\"${w}\" height=\"${h}\" stroke=\"none\" fill=\"#fff29c\"/>\n    <polygon stroke=\"#301551\"  stroke-width=\"4\" fill=\"none\" points=\"${t.a.x} ${t.a.y} ${t.b.x} ${t.b.y} ${t.c.x} ${t.c.y}\"/>\n    <circle cx=\"${a.x}\" cy=\"${a.y}\" r=\"6\" fill=\"red\" />\n    <circle cx=\"${b.x}\" cy=\"${b.y}\" r=\"6\" fill=\"green\" />\n    <circle cx=\"${c.x}\" cy=\"${c.y}\" r=\"6\" fill=\"blue\" />\n\n    <!-- Centroid -->\n    <polyline points=\"${t.a.x} ${t.a.y} ${t.bc.center.x} ${t.bc.center.y}\" stroke=\"#492b7c\" />\n    <polyline points=\"${t.b.x} ${t.b.y} ${t.ca.center.x} ${t.ca.center.y}\" stroke=\"#492b7c\" />\n    <polyline points=\"${t.c.x} ${t.c.y} ${t.ab.center.x} ${t.ab.center.y}\" stroke=\"#492b7c\" />\n    <circle cx=\"${t.centroid.x}\" cy=\"${t.centroid.y}\" r=\"6\" fill=\"#492b7c\" />\n\n    <!-- Circumcenter -->\n    <polyline points=\"${t.ab.center.x + t.abPerp.x} ${t.ab.center.y + t.abPerp.y} ${t.ab.center.x - t.abPerp.x} ${t.ab.center.y - t.abPerp.y}\" stroke=\"#f6d912\" />\n    <polyline points=\"${t.bc.center.x + t.bcPerp.x} ${t.bc.center.y + t.bcPerp.y} ${t.bc.center.x - t.bcPerp.x} ${t.bc.center.y - t.bcPerp.y}\" stroke=\"#f6d912\" />\n    <polyline points=\"${t.ca.center.x + t.caPerp.x} ${t.ca.center.y + t.caPerp.y} ${t.ca.center.x - t.caPerp.x} ${t.ca.center.y - t.caPerp.y}\" stroke=\"#f6d912\" />\n    <circle cx=\"${t.circumcenter.x}\" cy=\"${t.circumcenter.y}\" r=\"6\" fill=\"#f6d912\" />\n    <circle cx=\"${t.circumcenter.x}\" cy=\"${t.circumcenter.y}\" stroke-width=\"2\" r=\"${PVector.sub(t.circumcenter, t.c).mag()}\" stroke=\"#f6d912\" fill=\"none\"/>\n  stroke=\"orange\" fill=\"none\"/>\n\n    <!-- Incenter -->\n    <polyline points=\"${t.a.x + t.aBisector.x} ${t.a.y + t.aBisector.y} ${t.a.x - t.aBisector.x} ${t.a.y - t.aBisector.y}\" stroke=\"#ed8a0a\" />\n    <polyline points=\"${t.b.x + t.bBisector.x} ${t.b.y + t.bBisector.y} ${t.b.x - t.bBisector.x} ${t.b.y - t.bBisector.y}\" stroke=\"#ed8a0a\" />\n    <polyline points=\"${t.c.x + t.cBisector.x} ${t.c.y + t.cBisector.y} ${t.c.x - t.cBisector.x} ${t.c.y - t.cBisector.y}\" stroke=\"#ed8a0a\" />\n    <circle cx=\"${t.incenter.x}\" cy=\"${t.incenter.y}\" r=\"5\" fill=\"#ed8a0a\" />\n    <circle cx=\"${t.incenter.x}\" cy=\"${t.incenter.y}\" stroke=\"#ed8a0a\" stroke-width=\"2\" r=\"${t.inCircleRadius}\" fill=\"none\"/>\n  \n    <!-- Orthocenter -->\n    <polyline points=\"${t.a.x + t.bcPerp.x} ${t.a.y + t.bcPerp.y} ${t.a.x - t.bcPerp.x} ${t.a.y - t.bcPerp.y}\" stroke=\"lightblue\" />\n    <polyline points=\"${t.b.x + t.caPerp.x} ${t.b.y + t.caPerp.y} ${t.b.x - t.caPerp.x} ${t.b.y - t.caPerp.y}\" stroke=\"lightblue\" />\n    <polyline points=\"${t.c.x + t.abPerp.x} ${t.c.y + t.abPerp.y} ${t.c.x - t.abPerp.x} ${t.c.y - t.abPerp.y}\" stroke=\"lightblue\" />\n    <circle cx=\"${t.orthocenter.x}\" cy=\"${t.orthocenter.y}\" r=\"5\" fill=\"lightblue\" />\n  </svg>`\n})()","pinCode":false,"dname":"1524ca82-4eab-4242-bc67-a96185c4f96a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Triangle = (class Triangle extends Polygon {\n  constructor(a, b, c) {\n    super(a, b, c)\n    \n    this.a = a.clone()\n    this.b = b.clone()\n    this.c = c.clone()\n    \n    this.ab = new Segment(this.a, this.b)\n    this.bc = new Segment(this.b, this.c)\n    this.ca = new Segment(this.c, this.a)\n    \n    // https://www.mathsisfun.com/geometry/triangle-centers.html\n    // center of mass\n    this.centroid = segSegIntersection(new Segment(this.a, this.bc.center), new Segment(this.b, this.ca.center))\n    \n    const ab = PVector.sub(this.b, this.a)\n    const ac = PVector.sub(this.c, this.a)\n    const ba = PVector.sub(this.a, this.b)\n    const bc = PVector.sub(this.c, this.b)\n    const ca = PVector.sub(this.a, this.c)\n    const cb = PVector.sub(this.b, this.c)\n    \n    this.abPerp = ab.clone().rotateBy(Math.PI/2).setMag(10000)\n    this.bcPerp = bc.clone().rotateBy(Math.PI/2).setMag(10000)\n    this.caPerp = ca.clone().rotateBy(Math.PI/2).setMag(10000)\n    \n    this.circumcenter = segSegIntersection(\n      new Segment(PVector.add(this.ab.center, this.abPerp), PVector.sub(this.ab.center, this.abPerp)),\n      new Segment(PVector.add(this.bc.center, this.bcPerp), PVector.sub(this.bc.center, this.bcPerp))\n    )\n    \n    this.aBisector = ab.clone().rotateBy((ac.angle2D() - ab.angle2D())/2).setMag(10000)\n    this.bBisector = bc.clone().rotateBy((ba.angle2D() - bc.angle2D())/2).setMag(10000)\n    this.cBisector = ca.clone().rotateBy((cb.angle2D() - ca.angle2D())/2).setMag(10000)\n    \n    this.incenter = segSegIntersection(\n      new Segment(PVector.add(this.a, this.aBisector), PVector.sub(this.a, this.aBisector)),\n      new Segment(PVector.add(this.b, this.bBisector), PVector.sub(this.b, this.bBisector))\n    )\n    \n    this.inCircleRadius = Math.min(\n      PVector.sub(segSegIntersection(new Segment(PVector.add(this.a, this.aBisector), PVector.sub(this.a, this.aBisector)), this.bc), this.incenter).mag(),\n      PVector.sub(segSegIntersection(new Segment(PVector.add(this.b, this.bBisector), PVector.sub(this.b, this.bBisector)), this.ca), this.incenter).mag(),\n      PVector.sub(segSegIntersection(new Segment(PVector.add(this.c, this.cBisector), PVector.sub(this.c, this.cBisector)), this.ab), this.incenter).mag()\n    )\n    \n    this.orthocenter = segSegIntersection(\n      new Segment(PVector.add(this.a, this.bcPerp), PVector.sub(this.a, this.bcPerp)),\n      new Segment(PVector.add(this.b, this.caPerp), PVector.sub(this.b, this.caPerp))\n    )\n  }\n})","pinCode":false,"dname":"a6131c47-5891-4040-b4aa-1e5f85b3de9a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n## Hexagonal Grid\nHexGrid is a custom class to compute an hexagonal grid based on [Red Blob Games' Hexagonal Grids](https://www.redblobgames.com/grids/hexagons/)`","pinCode":false,"dname":"87cbeb77-d87b-4484-b066-4e3608a02506","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"HexGrid = (class HexGrid {\n  constructor(x, y, w, h, hexSize = 10, type = 'flat') {\n    this.x = x\n    this.y = y\n    this.w = w\n    this.h = h\n\n    // type can be either 'flat' or 'pointy'\n    this.type = type === 'flat' || type === 'pointy' ? type : 'flat'\n\n    this.hexHeight = Math.sqrt(3) * hexSize\n    this.hexWidth = 2 * hexSize\n    if(this.type === 'pointy') [this.hexWidth, this.hexHeight] = [this.hexHeight, this.hexWidth] // swap\n\n    this.hexPoints = this.getHexPoints()\n\n    this.nx = this.type === 'flat' ? \n      2 + (w / (this.hexWidth * 3/4)) :\n      2 + (w / (this.hexWidth * 1/2))\n\n    this.ny = this.type === 'flat' ? \n      2 + (h / (this.hexHeight * 1/2)) :\n      2 + (h / (this.hexHeight * 3/4))\n\n    this.centers = this.getCenters()\n    \n    this.w = this.centers.sort((a, b) => b.x - a.x)[0].x - this.x\n    this.h = this.centers.sort((a, b) => b.y - a.x)[0].y - this.y\n    \n    delete this.nx\n    delete this.ny\n  }\n\n  getHexPoints() {\n    if(this.type === 'flat') {\n      return [\n        { x:  this.hexWidth / 2, y:  0                  },\n        { x:  this.hexWidth / 4, y:  this.hexHeight / 2 },\n        { x: -this.hexWidth / 4, y:  this.hexHeight / 2 },\n        { x: -this.hexWidth / 2, y:  0                  },\n        { x: -this.hexWidth / 4, y: -this.hexHeight / 2 },\n        { x:  this.hexWidth / 4, y: -this.hexHeight / 2 },\n      ]\n    }\n    else {\n      return [\n        { x:  0,                 y: -this.hexHeight / 2 },\n        { x:  this.hexWidth / 2, y: -this.hexHeight / 4 },\n        { x:  this.hexWidth / 2, y:  this.hexHeight / 4 },\n        { x:  0,                 y:  this.hexHeight / 2 },\n        { x: -this.hexWidth / 2, y:  this.hexHeight / 4 },\n        { x: -this.hexWidth / 2, y: -this.hexHeight / 4 },\n      ]\n    }\n  }\n\n  getCenters() {\n    const centers = []\n    \n    for(let i = 0; i < this.ny; i ++) {\n      let isOut = false\n      for(let j = 0; j < this.nx && !isOut; j ++) {\n        let x = this.x\n        let y = this.y\n        \n        if(this.type === 'flat') {\n          x += j * this.hexWidth * 3/2 + (i % 2) * this.hexWidth * 3/4\n          y += i * this.hexHeight * 1/2\n        }\n        else {\n          x += j * this.hexWidth + (i % 2) * this.hexWidth * 1/2\n          y += i * this.hexHeight * 3/4\n        }\n        \n        if(x - this.hexWidth/2 < this.x + this.w && y - this.hexHeight/2 < this.y + this.h) {\n          centers.push({ x, y })\n        }\n        else isOut = true\n      }\n    }\n\n    return centers\n  }\n})","pinCode":false,"dname":"05a6b88c-95ac-49c8-b00a-f24a9b0ea28f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n## Simplex Noise\nPurely out of laziness ðŸ™ƒ`","pinCode":false,"dname":"994f10ac-9269-45a2-9d01-7f7d49f77e6a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"SimplexNoise = (require('simplex-noise@2.4'))","pinCode":false,"dname":"42576d22-6537-462d-b3b7-59279b3dad61","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"simplex = (new SimplexNoise())","pinCode":false,"dname":"979ddd7f-1922-49f1-a791-37c91af4733a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`\\`\\`\\`js\nimport { simplex } from '@makio135/utilities'\n\\`\\`\\``","pinCode":false,"dname":"61ab95fa-11dc-4369-82d9-c2e2080e138a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`___\n## Imports`","pinCode":false,"dname":"ca5589a6-8ac1-48f2-a80d-0fe76edfffd5","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"PVector = (require('pvectorjs/index.js'))","pinCode":false,"dname":"8b140160-6ee7-4d90-a0d6-fbd1351bab0a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"ClipperLib = (require(\"https://makio135.gitlab.io/js/clipper.min.js\").catch(() => window.ClipperLib))","pinCode":false,"dname":"cabd5eaa-69c2-42b0-8f22-9888b77c232b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"import { toc }  from '2d-to-3d/64641700df65baed'","pinCode":false,"dname":"3b1baa0b-a100-4e9f-8899-0ee76bf671a0","codeMode":"javascript2"}}}],"version":"2.19.1"}