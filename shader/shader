{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Shader\n\nThis notebook provides a little helper for fragment shaders. It is heavily inspired by Inigo Quilez’s [Shadertoy](https://www.shadertoy.com). To import into your notebook:\n\n~~~js\nimport {shader} from \"@mbostock/shader\"\n~~~\n\nFor example:`","pinCode":false,"dname":"c67955ce-c767-4fc2-a0c6-93f5679037d0","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shader({width: 640, height: 100})`\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(vec2(fragCoord.xy / iResolution.xy), 0.0, 1.0);\n}`","pinCode":false,"dname":"d5e9ffea-abb2-474c-b427-e7203a10a2fa","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shader({width: 640, height: 100})`\nconst float size = 25.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = fragCoord.xy;\n  float k = float(mod(p.x, size * 2.0) < size == mod(p.y, size * 2.0) < size);\n  fragColor = vec4(vec3(k), 1.0);\n}`","pinCode":false,"dname":"5a9034ca-6f56-4786-b63f-9574d2ad1b9a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`If *width* is not specified, it defaults to 640. If *height* is not specified, it defaults to 480. A *devicePixelRatio* option may also be specified; it defaults to the native value. Shaders can reference the const vec3 iResolution for the canvas dimensions; *z* stores the devicePixelRatio.`","pinCode":false,"dname":"c21236bf-a90d-45df-96d3-58248b6d677d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`The *iTime* option enables time-dependent shaders with the same behavior as on Shadertoy: it defines a uniform float iTime whose value is in seconds. (iMouse and others are not yet implemented; maybe in the future.) If you also pass in the *visibility* option using Observable’s built-in [visibility function](/@observablehq/awaiting-visibility), Shader will only render when the canvas is visible.`","pinCode":false,"dname":"4f5d19f6-7a36-4090-8980-67d58e338cf7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shader({height: 100, iTime: true, visibility})`\nconst float size = 25.0;\n\nmat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (fragCoord.xy - iResolution.xy / 2.0) * rotate2d(iTime / 10.0);\n  float k = float(mod(p.x, size * 2.0) < size == mod(p.y, size * 2.0) < size);\n  fragColor = vec4(vec3(k), 1.0);\n}`","pinCode":false,"dname":"89a6e6de-9a50-48cd-adb3-87851d325def","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`More generally, the *uniforms* option allows you to declare uniforms. These can then by updated programmatically by calling *canvas*.update. Currently only float uniforms are supported.`","pinCode":false,"dname":"8c919275-b22c-4f66-a4b3-71872dbac11c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"canvas = (shader({height: 100, uniforms: {angle: \"float\"}})`\nconst float size = 25.0;\n\nmat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (fragCoord.xy - iResolution.xy / 2.0) * rotate2d(angle);\n  float k = float(mod(p.x, size * 2.0) < size == mod(p.y, size * 2.0) < size);\n  fragColor = vec4(vec3(k), 1.0);\n}`)","pinCode":false,"dname":"a3450ee6-9214-4b86-9fb3-2f028666b6f9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"canvas.update({angle: now / 10000.0 % (2 * Math.PI)})","pinCode":false,"dname":"2bb2ed71-419d-4f6d-8d4a-194e10eb6c2f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`If you pass an *inputs* object, the shader can reference uniforms whose value corresponds to the input’s value. If a corresponding uniform is not declared, it is assumed to be a float.`","pinCode":false,"dname":"bdb77a2d-a2da-4df2-bf15-e03847d632af","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"viewof angle = (Inputs.range([-Math.PI, Math.PI], {label: \"angle\"}))","pinCode":false,"dname":"9abc989c-c8ed-48da-9ba9-5b5d9a1effad","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"viewof size = (Inputs.range([10, 100], {value: 25, transform: Math.log, label: \"size\"}))","pinCode":false,"dname":"31c44743-94bb-4276-b4fe-0afbb4af746c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shader({height: 100, inputs: {angle: viewof angle, size: viewof size}})`\n\nmat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (fragCoord.xy - iResolution.xy / 2.0) * rotate2d(angle);\n  float k = float(mod(p.x, size * 2.0) < size == mod(p.y, size * 2.0) < size);\n  fragColor = vec4(vec3(k), 1.0);\n}`","pinCode":false,"dname":"7c17bc0d-c8ca-4e5c-b761-4a8e2068cc60","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Implementation`","pinCode":false,"dname":"e9c6539a-7215-4d56-9874-46189b91ba6c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shader = (function shader({\n  width = 640,\n  height = 480,\n  devicePixelRatio = window.devicePixelRatio,\n  invalidation, // when the canvas is considered disposed\n  visibility, // if present, only draw when resolves\n  uniforms = {}, // declare your uniforms here\n  inputs = {}, // bind inputs to uniforms\n  iMouse = false, // not yet supported!\n  iTime = false, // enable built-in iTime uniform\n  sources = [], // extra sources (lib functions etc.)\n  preserveDrawingBuffer = false // if you want “Download PNG” to work\n} = {}) {\n  uniforms = new Map(Object.entries(uniforms).map(([name, type]) => [name, {type}]));\n  inputs = new Map(Object.entries(inputs));\n  for (const {type} of uniforms.values()) if (type !== \"float\") throw new Error(`unknown type: ${type}`);\n  for (const name of inputs.keys()) if (!uniforms.has(name)) uniforms.set(name, {type: \"float\"});\n  if (iTime && !uniforms.has(\"iTime\")) uniforms.set(\"iTime\", {type: \"float\"});\n  if (visibility !== undefined && typeof visibility !== \"function\") throw new Error(\"invalid visibility\");\n  return function() {\n    const source = String.raw.apply(String, arguments);\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width * devicePixelRatio;\n    canvas.height = height * devicePixelRatio;\n    canvas.style = `max-width: 100%; width: ${width}px; height: auto;`;\n    const gl = canvas.getContext(\"webgl\", {preserveDrawingBuffer});\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, `precision highp float;\n${Array.from(uniforms, ([name, {type}]) => `uniform ${type} ${name};`).join(\"\\n\")}\nconst vec3 iResolution = vec3(\n  ${(width * devicePixelRatio).toFixed(1)}, \n  ${(height * devicePixelRatio).toFixed(1)}, \n  ${(devicePixelRatio).toFixed(1)}\n);\n`, ...sources, source, `\nvoid main() {\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n`);\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, `\nattribute vec2 a_vertex;\n\nvoid main() {\n  gl_Position = vec4(a_vertex, 0.0, 1.0);\n}\n`);\n    const vertexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, Float32Array.of(-1, -1, +1, -1, +1, +1, -1, +1), gl.STATIC_DRAW);\n    const program = createProgram(gl, vertexShader, fragmentShader);\n    gl.useProgram(program);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    const a_vertex = gl.getAttribLocation(program, \"a_vertex\");\n    gl.enableVertexAttribArray(a_vertex);\n    gl.vertexAttribPointer(a_vertex, 2, gl.FLOAT, false, 0, 0);\n    for (const [name, u] of uniforms) u.location = gl.getUniformLocation(program, name);\n    const ondispose = invalidation === undefined ? Inputs.disposal(canvas) : invalidation;\n    let frame;\n    let disposed = false;\n    ondispose.then(() => disposed = true);\n    async function render() {\n      if (visibility !== undefined) await visibility();\n      frame = undefined;\n      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n    }\n    Object.assign(canvas, {\n      update(values = {}) {\n        if (disposed) return false;\n        for (const name in values) {\n          const u = uniforms.get(name);\n          if (!u) throw new Error(`unknown uniform: ${name}`);\n          gl.uniform1f(u.location, values[name]);\n        }\n        frame || requestAnimationFrame(render);\n        return true;\n      }\n    });\n    for (const [name, input] of inputs) {\n      const u = uniforms.get(name);\n      if (!u) throw new Error(`unknown uniform: ${name}`);\n      gl.uniform1f(u.location, input.value);\n      const update = () => {\n        gl.uniform1f(u.location, input.value);\n        frame || requestAnimationFrame(render);\n      };\n      input.addEventListener(\"input\", update);\n      ondispose.then(() => input.removeEventListener(\"input\", update));\n    }\n    if (iTime) {\n      frame = true; // always rendering\n      const u_time = gl.getUniformLocation(program, \"iTime\");\n      let timeframe;\n      (async function tick() {\n        if (visibility !== undefined) await visibility();\n        gl.uniform1f(u_time, performance.now() / 1000);\n        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n        return timeframe = requestAnimationFrame(tick);\n      })();\n      ondispose.then(() => cancelAnimationFrame(timeframe));\n    } else {\n      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n    }\n    return canvas;\n  };\n})","pinCode":false,"dname":"701b440c-8b3c-4272-b2e8-e7feab232402","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"createShader = (function createShader(gl, type, ...sources) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, sources.join(\"\\n\"));\n  gl.compileShader(shader);\n  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;\n  throw new Error(gl.getShaderInfoLog(shader));\n})","pinCode":false,"dname":"9e7cf0af-0a40-46fa-8a7b-f8f123af6f72","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"createProgram = (function createProgram(gl, ...shaders) {\n  const program = gl.createProgram();\n  for (const shader of shaders) gl.attachShader(program, shader);\n  gl.linkProgram(program);\n  if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program;\n  throw new Error(gl.getProgramInfoLog(program));\n})","pinCode":false,"dname":"e2f7357c-3c27-4eba-a766-fe05ecd6e028","codeMode":"javascript2"}}}],"version":"2.19.1"}