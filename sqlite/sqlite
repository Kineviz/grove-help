{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# SQLite\n\nThis notebook demonstrates how to load and query a SQLite database in an Observable notebook using an Emscripten port of SQLite, [SQL.js](https://github.com/sql-js/sql.js). As an example, we’re going to load the Los Angeles Times’ [Consumer Price Index database](https://github.com/datadesk/cpi), which is derived from data published by the Bureau of Labor Statistics. This is a 93.5MB database, so you might have to wait a little bit for it to load.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cpi = (SQLite.open(\"https://raw.githubusercontent.com/datadesk/cpi/d582252c644b90d48918a4cba951baf3c03c9629/cpi/cpi.db\"))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`To see what’s in the database, we can query the table metadata:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cpi.exec(\"SELECT * FROM sqlite_master WHERE type = 'table'\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`For example, here’s the entire contents of the cu.series table:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cpi.exec(\"SELECT * FROM 'cu.series'\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Or, a more restrictive query:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cpi.exec(`SELECT *\nFROM 'cu.series'\nWHERE item_code = 'SA0'\nAND area_code = 'A214'\nORDER BY begin_year ASC`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Or with positional parameters:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cpi.exec(`SELECT *\nFROM 'cu.series'\nWHERE item_code = ?\nAND area_code = ?\nORDER BY begin_year ASC`, ['SA0', 'A214'])","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Implementation\n\nTo use this in your notebook:\n\n\\`\\`\\`js\nimport {SQLite} from \"@mbostock/sqlite\"\n\\`\\`\\``","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"SQLite = (class SQLite {\n  constructor(buffer) {\n    Object.defineProperties(this, {\n      _db: {value: new SQL.Database(buffer && new Uint8Array(buffer))}\n    });\n  }\n  dispose() {\n    this._db.close();\n  }\n  async exec(sql, params) {\n    if (params !== undefined) {\n      let i = -1;\n      sql = sql.replace(/\\?/g, () => {\n        const param = params[++i];\n        return Array.isArray(param)\n          ? new Array(param.length).fill(\"?\")\n          : \"?\";\n      });\n      params = params.flat(1);\n    }\n    const [result] = await this._db.exec(sql, params);\n    if (!result) return [];\n    const {columns, values} = result;\n    return values.map(row => {\n      const object = {};\n      for (let i = 0; i < row.length; ++i) object[columns[i]] = row[i];\n      return object;\n    });\n  }\n  static async open() {\n    return new SQLite(await fetch(...arguments).then(response => response.arrayBuffer()));\n  }\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"SQL = {\n  const [init, path] = await Promise.all([\n    require(\"sql.js@1\"),\n    require.resolve(\"sql.js@1/dist/\").then(path => path.replace(/\\.js$/, \"\"))\n  ]);\n  return init({locateFile: file => path + file});\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"SQLiteDatabaseClient = (class SQLiteDatabaseClient {\n  constructor(buffer) {\n    Object.defineProperties(this, {\n      _db: {value: Promise.resolve(buffer).then(buffer => new SQLite(buffer))}\n    });\n  }\n  async query(sql, params) {\n    return (await this._db).exec(sql, params);\n  }\n  async queryRow(sql, params) {\n    return (await this.query(sql, params))[0];\n  }\n  async explain(sql, params) {\n    const rows = (await this.query(`EXPLAIN QUERY PLAN ${sql}`, params));\n    const text = rows.map(row => row.detail).join(\"\\n\");\n    const pre = document.createElement(\"PRE\");\n    pre.className = \"observablehq--inspect\";\n    pre.appendChild(document.createTextNode(text));\n    return pre;\n  }\n  async describe(object) {\n    if (object !== undefined) {\n      const [row] = await this.query(`SELECT * FROM '${object}' LIMIT 1`);\n      const value = Object.entries(row).map(([column_name, value]) => ({\n        column_name,\n        data_type: typeof value === \"string\" ? \"character varying\"\n            : typeof value === \"number\" ? \"integer\"\n            : undefined,\n        column_default: null,\n        is_nullable: \"YES\"\n      }));\n      const table = html`\n        <table>\n          <thead>\n            <tr>\n              <th>column_name</th>\n              <th>data_type</th>\n              <th>column_default</th>\n              <th>is_nullable</th>\n            </tr>\n          </thead>\n          <tbody>\n            ${value.map(({column_name, data_type, column_default, is_nullable}) => html`\n              <tr>\n                <td>${column_name}</td>\n                <td>${data_type}</td>\n                <td>${column_default}</td>\n                <td>${is_nullable}</td>\n              </tr>\n            `)}\n          </tbody>\n        </table>\n      `;\n      table.value = value;\n      return table;\n    } else {\n      const rows = await this.query(`SELECT name FROM sqlite_master WHERE type = 'table'`);\n      const table = html`\n        <table>\n          <thead>\n            <tr>\n              <th>name</th>\n            </tr>\n          </thead>\n          <tbody>\n            ${rows.map(({name}) => html`\n              <tr>\n                <td>${name}</td>\n              </tr>\n            `)}\n          </tbody>\n        </table>\n      `;\n      table.value = [{table_schema: \"public\", table_name: \"names\"}];\n      return table;\n    }\n  }\n})","pinCode":false}}}],"version":"2.19.1"}