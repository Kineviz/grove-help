{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Introduction to Views\n\nIn Observable, a *view* is a user interface element that directly controls a *value* in the notebook. A view consists of two parts:\n\n* The *view*, which is typically an interactive DOM element.\n* The *value*, which is any JavaScript value.\n\nFor example, a view could be an HTML range input whose value is a number:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof x = (html`<input type=range min=0 max=1 step=any>`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"x","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`A view could be a text input whose value is a string:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof message = (html`<input type=text placeholder=\"Say hello\">`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"message","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`A view could be a dropdown menu to choose from a set of options:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof color = (html`<select>\n  <option>red\n  <option>orange\n  <option>yellow\n  <option selected>green\n  <option>blue\n  <option>violet\n</select>`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"color","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`(See [Observable Inputs](/@observablehq/inputs) for inputs that are more convenient and more usable than the native HTML inputs.) But views arenâ€™t limited to built-in HTML input types! A view can have any visual representation you desire, and any value, too. For example, a view could be a map that lets you specify any point on Earth:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof point = {\n  const height = width / 2;\n  const context = DOM.context2d(width, height);\n  const projection = d3.geoEqualEarth().fitSize([width, height], {type: \"Sphere\"});\n  const path = d3.geoPath(projection, context);\n  let mousedown = false;\n\n  context.beginPath(), path(graticule), context.strokeStyle = \"#ccc\", context.stroke();\n  context.beginPath(), path(land), context.fill();\n  context.beginPath(), path(sphere), context.strokeStyle = \"#000\", context.stroke();\n  context.lineWidth = 2, context.strokeStyle = \"#f00\";\n  const image = context.getImageData(0, 0, context.canvas.width, context.canvas.height);\n\n  function render(coordinates) {\n    context.canvas.value = coordinates;\n    context.clearRect(0, 0, width, height);\n    context.putImageData(image, 0, 0);\n    context.beginPath(), path({type: \"Point\", coordinates}), context.stroke();\n  }\n\n  context.canvas.onmousedown = event => {\n    mousedown = true;\n    context.canvas.onmousemove(event);\n  };\n\n  context.canvas.onmousemove = ({layerX, layerY}) => {\n    if (!mousedown) return;\n    render(projection.invert([layerX, layerY]));\n    context.canvas.dispatchEvent(new CustomEvent(\"input\"));\n  };\n\n  context.canvas.onmouseup = event => {\n    mousedown = false;\n  };\n\n  render([0, 0]);\n  return context.canvas;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"point","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`A view could be a blank canvas for the user to draw a squiggle:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof stroke = {\n  const height = 280;\n  const context = DOM.context2d(width, height);\n  const curve = d3.curveBasis(context);\n  const canvas = context.canvas;\n  let stroke = [[102,211],[103,210],[108,200],[120,187],[142,154],[159,121],[173,90],[185,66],[192,52],[197,41],[199,35],[199,33],[199,32],[199,31],[199,31],[199,30],[199,31],[195,39],[187,53],[177,75],[166,103],[155,129],[147,144],[135,171],[132,178],[124,194],[120,203],[118,208],[116,213],[115,216],[114,218],[114,219],[113,220],[113,218],[114,214],[122,203],[134,185],[141,175],[148,168],[154,161],[159,157],[163,155],[167,153],[169,153],[171,153],[172,153],[173,155],[173,162],[173,171],[173,181],[173,193],[173,204],[173,210],[173,215],[174,218],[176,220],[178,221],[179,221],[183,222],[189,222],[197,216],[209,205],[222,188],[230,174],[235,164],[238,157],[239,152],[239,149],[238,148],[235,148],[230,148],[225,149],[221,153],[218,159],[216,165],[216,172],[216,180],[218,188],[224,196],[230,203],[236,206],[246,209],[253,209],[259,206],[265,199],[271,190],[280,174],[283,168],[287,159],[289,155],[290,151],[293,145],[296,139],[303,128],[310,113],[315,100],[320,86],[320,79],[321,70],[319,67],[312,66],[303,66],[291,74],[282,86],[273,102],[267,121],[262,141],[260,162],[260,176],[260,195],[263,210],[269,220],[275,225],[282,227],[288,226],[299,216],[311,192],[317,172],[328,139],[334,117],[341,92],[345,72],[347,65],[348,55],[349,50],[349,48],[347,47],[344,47],[340,51],[332,62],[327,72],[319,90],[314,109],[310,129],[308,152],[308,169],[308,188],[309,205],[314,218],[319,226],[326,231],[331,232],[337,232],[341,228],[345,223],[348,217],[351,211],[355,205],[357,201],[360,195],[361,192],[361,187],[362,182],[362,180],[362,178],[362,177],[362,176],[362,175],[361,175],[359,174],[358,174],[356,174],[355,174],[353,174],[352,175],[351,176],[349,180],[348,185],[347,190],[347,197],[347,203],[349,206],[353,208],[358,209],[362,209],[366,204],[368,197],[370,189],[370,181],[370,176],[370,171],[369,167],[368,164],[367,162],[366,162],[365,162],[365,162],[365,162],[366,162],[371,162],[379,162],[389,162],[399,161],[413,154],[421,146],[425,142]];\n\n  context.beginPath();\n  curve.lineStart();\n  for (const p of stroke) curve.point(...p);\n  curve.lineEnd();\n  context.stroke();\n\n  canvas.value = stroke;\n  stroke = null;\n\n  canvas.ontouchstart =\n  canvas.onmousedown = event => {\n    stroke = canvas.value = [];\n    canvas.onmousemove(event);\n  };\n\n  canvas.ontouchend =\n  canvas.onmouseup = () => {\n    stroke = null;\n  };\n\n  canvas.ontouchmove =\n  canvas.onmousemove = event => {\n    if (stroke === null) return;\n    event.preventDefault();\n    stroke.push([event.layerX, event.layerY]);\n    context.clearRect(0, 0, width, height);\n    context.beginPath();\n    curve.lineStart();\n    for (const p of stroke) curve.point(...p);\n    curve.lineEnd();\n    context.stroke();\n    canvas.dispatchEvent(new CustomEvent(\"input\"));\n  };\n\n  return canvas;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"stroke","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`If there is a value youâ€™d like the user to control in your notebook, represent that value as a view. By doing so, you wonâ€™t need to manage event listeners and mutable stateâ€”you can simply refer to the value, and whenever the user changes it, your code will run automatically. For example, you have chosen <span style=\"display:inline-block;background-color:${color.toLowerCase()};width:1em;height:1em;\"></span> ${color} as your color in the menu above; change it and watch this cell update.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`A viewâ€™s value is exposed as *element*.value. For example, here Iâ€™ll define a static view (one whose value never changes), for the purposes of illustration:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof silly = {\n  const element = html`<div>I am a silly view!</div>`;\n  element.value = \"I am a silly value.\";\n  return element;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"silly","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The \\`viewof\\` operator is just shorthand for defining the view and its value in the same cell. You can define them as separate cells if you prefer:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"explicitView = (html`<input type=range>`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"explicitValue = (Generators.input(explicitView))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`And, just as you can reference *explicitView* from another cell, you can reference the view defined by viewof from another cell, too. For example, the view *x* defined at the top of this notebook is a range input:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof x.type","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`To trigger the re-evaluation of any cell that references a viewâ€™s value, the view must emit an *input* event. Hereâ€™s another silly view that counts clicks:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof count = {\n  const element = html`<div style=\"display: inline-block; font-size: 64px; user-select: none;\">ðŸ¤ª</div>`;\n  element.value = 0;\n  element.onmousedown = () => {\n    element.style.transition = \"none\";\n    element.style.transform = `scale(1.5) rotate(${Math.random() * 90 - 45}deg)`;\n  };\n  element.onclick = () => {\n    ++element.value;\n    element.dispatchEvent(new Event(\"input\", {bubbles: true}));\n    requestAnimationFrame(() => {\n      element.style.transition = \"transform 250ms ease\";\n      element.style.transform = \"inherit\";\n    });\n  };\n  return element;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"count","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`As you might have guessed, the reason that HTML input elements work by default as views is that these elements have a value property and they emit *input* events when you interact with them. (There is a little extra logic for dealing with idiosyncrasies; see the [Generators.input](https://github.com/observablehq/stdlib/blob/master/src/generators/input.js) source for details. And a view doesnâ€™t need to be a DOM element; it only needs to support the [EventTarget interface](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget). For an example of a non-element view, see the [Synchronized Inputs](/@observablehq/synchronized-inputs) notebook.)\n\nNext time you find yourself reaching for an event listener or mutating global state, try a view instead. Now youâ€™re thinking with dataflow.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Further Reading\n\n[Observable Inputs](/@observablehq/inputs)\n<br>[Introduction to Generators](/@observablehq/introduction-to-generators)\n<br>[Synchronized Inputs](/@observablehq/synchronized-inputs)\n<br>[Multi-Value Inputs](/@mbostock/multi-value-inputs)\n<br>[Wait Until Button](/@mbostock/wait-until-button)`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Appendix`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"sphere = ({type: \"Sphere\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"graticule = (d3.geoGraticule10())","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"land = (topojson.feature(world, world.objects.land))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"world = (FileAttachment(\"land-50m.json\").json())","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"topojson = (require(\"topojson-client@3\"))","pinCode":false}}}],"version":"2.19.1"}