{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# How Grove Runs\n\nIf you’ve used other interactive notebooks before, you’re probably accustomed to code running from top to bottom. The first cell runs first, the second cell runs second and can reference values defined in the first cell, and so on down the page.\n\nGrove is different: it functions like a spreadsheet, where cells (like formulas) run *automatically* whenever their referenced values change. Grove runs cells independently of their order in the notebook, giving you the flexibility to arrange your cells in whatever order you prefer for [literate programming](https://en.wikipedia.org/wiki/Literate_programming).\n\nGrove uses *topological* order to run cells, as determined by cell references. If cell *B* needs the value of cell *A*, Grove won’t run cell *B* until *A* is computed. Likewise whenever the value of cell *A* changes, cell *B* is automatically recomputed. Rather than a linear sequence of cells, an Grove notebook is a directed graph where [values flow](https://en.wikipedia.org/wiki/Dataflow_programming) from top to bottom.`","pinCode":false,"dname":"52f8a556-6cc0-4ca2-b7e4-d4ddb0e46573","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"dot`digraph \"d3-bar-chart\" {\n${edges.map(([i, o]) => `${i} -> ${o}`).join(\"\\n\")}\n}`","pinCode":false,"dname":"af81585c-b546-4814-999e-164fd0cb3918","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`We’ll consider the graph of a [bar chart notebook](/@d3/bar-chart) as a whole later, but first, let’s examine one cell closely: the *y*-scale. The scale is a function that takes a numeric data *value* as input (the relative frequency of a letter in the English language) and returns the corresponding height of the bar in pixels.`","pinCode":false,"dname":"c81c2f71-f7ad-4ccf-be83-12274fcde62f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"y = {\n  const minValue = 0;\n  const maxValue = d3.max(data, d => d.frequency);\n  const minY = height - margin.bottom;\n  const maxY = margin.top;\n  return function(value) {\n    return (value - minValue) \n        / (maxValue - minValue)\n        * (maxY - minY)\n        + minY;\n  };\n}","pinCode":false,"dname":"ae3d2af3-322f-451b-b9ee-1f450bd05a1e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`To construct the scale, we need several values that are external to the cell: *d3* (a JavaScript library for visualizing data), *data* (a dataset, loaded from a CSV file), *margin* (an object defining the chart’s margins in pixels), and *height* (the height of the chart, again in pixels). In other words, before we can compute the *maxValue*, we need to have loaded the *data*, and so on.\n\nGrove identifies these external references by parsing the JavaScript and looking for variables that are not declared in scope. These variables are instead defined by other cells in the notebook. (Or if they are missing, Grove won’t compute the referencing cell: you’ll get a RuntimeError.)\n\nConsider a simpler example:`","pinCode":false,"dname":"b7815f0d-4487-4768-b0eb-16c6c83b1a8f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"foo = (\"🌎\")","pinCode":false,"dname":"d4243a8c-0b1b-4ab6-94ec-ae2c366166bd","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"bar = (foo + \"bar\")","pinCode":false,"dname":"fd5fe664-87d5-48e1-819c-6a8fb6ed6ad5","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`The cell *bar* references *foo* without defining it. Grove treats this as a reference to the cell *foo*, so it first computes *foo*, and then uses this value to compute *bar*.\n\nGrove understands scoping, so you can define a local variable with the name of another cell, and this local variable will mask references to the cell.`","pinCode":false,"dname":"19d3d006-c3d6-4ea4-b3d8-982b185c4ebf","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"baz = {\n  let foo = \"🏠\"; // A local foo, masking the cell foo.\n  return foo + \"baz\"; // A reference to the local foo.\n}","pinCode":false,"dname":"fc0716e0-7db4-4e73-85db-d5283b36b2e9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`As above, we can think of a notebook as a directed graph representing the flow of data, where the nodes in the graph are cells and the directed edges go from a referenced cell to a referencing cell. A cell’s references are its incoming edges.`","pinCode":false,"dname":"fcd807da-d8f7-497a-9591-82a686967a8c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"dot`digraph \"in(y)\" {\n  height -> y\n  data -> y\n  d3 -> y\n  margin -> y\n}`","pinCode":false,"dname":"e054832c-b7e5-4204-95bf-aeb294203d94","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Before we can compute the *y*-scale, then, we need the values of its incoming references: *height*, *data*, *d3* and *margin*. These may be defined asynchronously—for example, D3 needs to be loaded from unpkg and the data set needs to be loaded from GitHub. They may even be dynamic, as with a dataset that changes over time.\n\nWe can also look at the outgoing edges from a cell: other cells that reference this cell’s value. If the *y*-scale changes, Grove recomputes the downstream cells: *yAxis* and *chart*.`","pinCode":false,"dname":"7a283595-434a-4915-9b6b-49604d505d0a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"dot`digraph \"out(y)\" {\n  y -> yAxis\n  y -> chart\n}`","pinCode":false,"dname":"534711dc-d6d8-484e-8f93-bdb02e688d94","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Unfortunately, just knowing the immediate outgoing edges isn’t enough to know how to recompute downstream cells. We need the entire graph, as we’ll need to recompute the outgoing references of *those* cells, *their* outgoing references, and so on, until the notebook is up-to-date.\n\nThe animation below shows how the bar chart notebook is computed in topological order. The number in parentheses is each cell’s count of not-yet-computed incoming references: a cell can only be computed after all its references are computed (showing a count of zero). The currently-computing cell is shown in <span style=\"color:red;font-weight:bold;\">red</span>, the ready-to-compute cells are shown in <span style=\"color:gray;font-weight:bold;\">gray</span>, and the computed cells are shown in <span style=\"color:black;font-weight:bold;\">black</span>.`","pinCode":false,"dname":"ef9505d2-a5fc-4291-8537-dd4bd3686e2c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"viewof graph_replay = (html`<button>Replay`)","pinCode":false,"dname":"1530e665-fa43-4e1d-bb40-02225eadbbe7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"graph = {\n  graph_replay;\n  let firstDelay = 0;\n  while (true) {\n    for (const {first, node, nodes} of computeSequence()) {\n      yield Promises.delay(first ? firstDelay : 1000, dot`digraph \"d3-bar-chart\" {\n  ${nodes.map(n => `${n.name} [label=\"${n.name} (${n.indegree})\" color=${node === n ? \"red\" : n.computed ? \"black\" : n.indegree ? \"white\" : \"gray\"}]`).join(\"\\n\")}\n  ${nodes.map(i => [...i.outputs].map(o => `${i.name} -> ${o.name} [color=${node === i ? \"red\" : i.computed ? \"black\" : \"gray\"}]`).join(\"\\n\")).join(\"\\n\")}\n  }`);\n    }\n    firstDelay = 30000;\n  }\n}","pinCode":false,"dname":"7a3e6a2b-9995-48e6-a481-06a8a45069d2","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`There are a few interesting consequences of this design.\n\nFirst, the order of computation for cells at the same topological level is arbitrary! For example, *width*, *height* and *margin* don’t reference any other cells, so Grove can compute them in any order. If the cells are defined asynchronously, such as a promise that fetches a dataset from a remote server, the cells will run concurrently. Thus, be wary of side-effects and implicit dependencies on other cells (such as selecting from the DOM), as the order of computation is not guaranteed.\n\nSecond, circular references are not allowed. If you create a cycle in the data flow graph, all cells in the cycle will throw a RuntimeError.`","pinCode":false,"dname":"4885f59d-1764-4622-8aaf-0d1295ee578c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"cycle1 = (cycle2 + 1)","pinCode":false,"dname":"31b525d6-46ea-490a-b411-d26ca22f1759","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"cycle2 = (cycle1 + 1)","pinCode":false,"dname":"89b1a675-d923-485a-8b72-1e056e1b784c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`The data flow graph also allows Grove to recompute a subset of the graph efficiently when something changes. For example, the *width* reactive variable from the ${Link(\"stdlib/stdlib\", \"Grove standard library\")} changes whenever the window is resized. This is convenient for a responsive chart: all you have to do is reference the built-in *width*, and the chart will be updated automatically if the window is resized.\n\nHere’s how it works for our example bar chart. When the *width* changes, the *x*-scale is recomputed. The new *x*-scale is then used to create the new *xAxis*. And lastly, the *chart* is recreated.`","pinCode":false,"dname":"c030bf89-ae33-4c7f-8063-f327bb7bef80","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const name = \"width\";\n  const nodes = computeNodes();\n  const dirty = new Set(nodes.filter(n => n.name === name));\n  for (let o of dirty) o.outputs.forEach(dirty.add, dirty);\n  return dot`digraph \"subgraph(${name})\" {\n  ${nodes.map(i => [...i.outputs].map(o => `${i.name} -> ${o.name} [color=${dirty.has(i) ? \"black\" : \"gray\"}]`).join(\"\\n\")).join(\"\\n\")}\n  ${nodes.map(i => `${i.name} [color=${dirty.has(i) ? \"black\" : \"none\"}]`).join(\"\\n\")}\n}`;\n}","pinCode":false,"dname":"0a111c0c-fd1b-4a43-802a-e10d02b1a4b4","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Note that the remainder of the graph—the *data*, the *y*-scale, *etc.*—did not need to be recomputed when only the *width* changes. Only the cells that are affected by the change (either indirectly or directly) are recomputed. This selective recompution is what makes Observable *fast*.\n\nIn March of 2020, we introduced [visual dataflow](/@observablehq/introducing-visual-dataflow) so you can see how data flows through your notebook. For a more detailed view of your notebook’s graph, also see the [notebook visualizer](/@observablehq/notebook-visualizer).`","pinCode":false,"dname":"29979303-a6fe-4e28-adb4-efb5cdab86d2","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Appendix`","pinCode":false,"dname":"c776f5f7-fe9d-4b11-ba17-66652ad404e1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"computeNodes = (function computeNodes() {\n  const map = new Map;\n  \n  function get(name) {\n    let node = map.get(name);\n    if (!node) map.set(name, node = new Node(name));\n    return node;\n  }\n  \n  for (const [i, o] of edges) {\n    const nodeIn = get(i);\n    const nodeOut = get(o);\n    nodeIn.outputs.add(nodeOut);\n    nodeOut.inputs.add(nodeIn);\n  }\n  \n  return [...map.values()];\n})","pinCode":false,"dname":"3e21ed64-bc56-48b9-8533-03db19a60759","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"computeSequence = (function* computeSequence() {\n  const nodes = computeNodes();\n  const queue = [];\n  for (const node of nodes) {\n    if (!(node.indegree = node.inputs.size)) {\n      queue.push(node);\n    }\n  }\n  let node;\n  yield {nodes, first: true};\n  while (node = queue.pop()) {\n    node.computed = true;\n    for (const output of node.outputs) {\n      if (!--output.indegree) {\n        queue.push(output);\n      }\n    }\n    yield {node, nodes};\n  }\n  yield {nodes};\n})","pinCode":false,"dname":"058e3d32-fb28-448c-9311-2f8afe26ed58","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Node = (class Node {\n  constructor(name) {\n    this.name = name;\n    this.computed = false;\n    this.indegree = 0;\n    this.inputs = new Set;\n    this.outputs = new Set;\n  }\n})","pinCode":false,"dname":"6cdb974a-8a0f-40ff-9f81-42fa758e866b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"edges = ([\n  [\"d3\", \"chart\"],\n  [\"DOM\", \"chart\"],\n  [\"width\", \"chart\"],\n  [\"height\", \"chart\"],\n  [\"data\", \"chart\"],\n  [\"x\", \"chart\"],\n  [\"y\", \"chart\"],\n  [\"xAxis\", \"chart\"],\n  [\"yAxis\", \"chart\"],\n  [\"require\", \"data\"],\n  [\"d3\", \"x\"],\n  [\"data\", \"x\"],\n  [\"margin\", \"x\"],\n  [\"width\", \"x\"],\n  [\"d3\", \"y\"],\n  [\"data\", \"y\"],\n  [\"height\", \"y\"],\n  [\"margin\", \"y\"],\n  [\"d3\", \"xAxis\"],\n  [\"height\", \"xAxis\"],\n  [\"margin\", \"xAxis\"],\n  [\"x\", \"xAxis\"],\n  [\"d3\", \"yAxis\"],\n  [\"margin\", \"yAxis\"],\n  [\"y\", \"yAxis\"],\n  [\"require\", \"d3\"]\n])","pinCode":false,"dname":"dbf4ad77-268d-43a1-8b86-b93f3682e769","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"margin = ({top: 30, right: 0, bottom: 30, left: 40})","pinCode":false,"dname":"10a218a1-33f5-429b-ba3f-519e1471aedf","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"height = (500)","pinCode":false,"dname":"f87c7b9f-bea0-47f7-b92e-7fd015c5ddbd","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"data = (FileAttachment(\"alphabet.csv\").csv({typed: true}))","pinCode":false,"dname":"f497cccb-1c1a-4442-9e0b-c7cf1f138cf0","codeMode":"javascript2"}}}],"version":"2.19.1"}