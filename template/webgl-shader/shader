{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Shader\n\nThis notebook provides a little helper for fragment shaders. It is heavily inspired by Inigo Quilez’s [Shadertoy](https://www.shadertoy.com). To import into your notebook:\n\n~~~js\nimport {shader} from \"@mbostock/shader\"\n~~~\n\nFor example:`","pinCode":false,"dname":"63171d52-a477-4b67-b230-8a9a72227af9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shader({width: 640, height: 100})`\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(vec2(fragCoord.xy / iResolution.xy), 0.0, 1.0);\n}`","pinCode":false,"dname":"c435921f-ab59-447e-acdf-80ca0734ef94","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shader({width: 640, height: 100})`\nconst float size = 25.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = fragCoord.xy;\n  float k = float(mod(p.x, size * 2.0) < size == mod(p.y, size * 2.0) < size);\n  fragColor = vec4(vec3(k), 1.0);\n}`","pinCode":false,"dname":"01832760-6519-4304-85b1-a68363899532","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`If *width* is not specified, it defaults to 640. If *height* is not specified, it defaults to 480. A *devicePixelRatio* option may also be specified; it defaults to the native value. Shaders can reference the const vec3 iResolution for the canvas dimensions; *z* stores the devicePixelRatio.`","pinCode":false,"dname":"8bce9da6-a9a1-44ec-a0fd-0db8b0a55886","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`The *iTime* option enables time-dependent shaders with the same behavior as on Shadertoy: it defines a uniform float iTime whose value is in seconds. (iMouse and others are not yet implemented; maybe in the future.) If you also pass in the *visibility* option using Observable’s built-in [visibility function](/@observablehq/awaiting-visibility), Shader will only render when the canvas is visible.`","pinCode":false,"dname":"9471ee1c-0169-4f48-a57e-64060565cb2e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shader({height: 100, iTime: true, visibility})`\nconst float size = 25.0;\n\nmat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (fragCoord.xy - iResolution.xy / 2.0) * rotate2d(iTime / 10.0);\n  float k = float(mod(p.x, size * 2.0) < size == mod(p.y, size * 2.0) < size);\n  fragColor = vec4(vec3(k), 1.0);\n}`","pinCode":false,"dname":"b0ab7d47-4df4-4f90-a710-04b05609ee3b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`More generally, the *uniforms* option allows you to declare uniforms. These can then by updated programmatically by calling *canvas*.update. Currently only float uniforms are supported.`","pinCode":false,"dname":"f72b5d09-d9e6-4da2-a87a-1d1a931e1c36","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"canvas = (shader({height: 100, uniforms: {angle: \"float\"}})`\nconst float size = 25.0;\n\nmat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (fragCoord.xy - iResolution.xy / 2.0) * rotate2d(angle);\n  float k = float(mod(p.x, size * 2.0) < size == mod(p.y, size * 2.0) < size);\n  fragColor = vec4(vec3(k), 1.0);\n}`)","pinCode":false,"dname":"c74072da-4f33-413e-9ea4-a6ad09e6f47a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"canvas.update({angle: now / 10000.0 % (2 * Math.PI)})","pinCode":false,"dname":"6ea5df33-183a-4958-9fb4-38d06571101a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`If you pass an *inputs* object, the shader can reference uniforms whose value corresponds to the input’s value. If a corresponding uniform is not declared, it is assumed to be a float.`","pinCode":false,"dname":"c5c12bf6-140b-401d-b734-4a97d548620e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"viewof angle = (Inputs.range([-Math.PI, Math.PI], {label: \"angle\"}))","pinCode":false,"dname":"b2656606-39de-4d5c-8e2a-d8e77c85d925","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"viewof size = (Inputs.range([10, 100], {value: 25, transform: Math.log, label: \"size\"}))","pinCode":false,"dname":"bb6a5d20-ba3f-47fe-9300-7db156ff9991","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shader({height: 100, inputs: {angle: viewof angle, size: viewof size}})`\n\nmat2 rotate2d(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (fragCoord.xy - iResolution.xy / 2.0) * rotate2d(angle);\n  float k = float(mod(p.x, size * 2.0) < size == mod(p.y, size * 2.0) < size);\n  fragColor = vec4(vec3(k), 1.0);\n}`","pinCode":false,"dname":"38def4fb-93d8-4fe4-bce0-6b6fe2afa104","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Implementation`","pinCode":false,"dname":"584aebbc-59c6-43f3-a48b-9370821588dd","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"shader = (function shader({\n  width = 640,\n  height = 480,\n  devicePixelRatio = window.devicePixelRatio,\n  invalidation, // when the canvas is considered disposed\n  visibility, // if present, only draw when resolves\n  uniforms = {}, // declare your uniforms here\n  inputs = {}, // bind inputs to uniforms\n  iMouse = false, // not yet supported!\n  iTime = false, // enable built-in iTime uniform\n  sources = [], // extra sources (lib functions etc.)\n  preserveDrawingBuffer = false // if you want “Download PNG” to work\n} = {}) {\n  uniforms = new Map(Object.entries(uniforms).map(([name, type]) => [name, {type}]));\n  inputs = new Map(Object.entries(inputs));\n  for (const {type} of uniforms.values()) if (type !== \"float\") throw new Error(`unknown type: ${type}`);\n  for (const name of inputs.keys()) if (!uniforms.has(name)) uniforms.set(name, {type: \"float\"});\n  if (iTime && !uniforms.has(\"iTime\")) uniforms.set(\"iTime\", {type: \"float\"});\n  if (visibility !== undefined && typeof visibility !== \"function\") throw new Error(\"invalid visibility\");\n  return function() {\n    const source = String.raw.apply(String, arguments);\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width * devicePixelRatio;\n    canvas.height = height * devicePixelRatio;\n    canvas.style = `max-width: 100%; width: ${width}px; height: auto;`;\n    const gl = canvas.getContext(\"webgl\", {preserveDrawingBuffer});\n    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, `precision highp float;\n${Array.from(uniforms, ([name, {type}]) => `uniform ${type} ${name};`).join(\"\\n\")}\nconst vec3 iResolution = vec3(\n  ${(width * devicePixelRatio).toFixed(1)}, \n  ${(height * devicePixelRatio).toFixed(1)}, \n  ${(devicePixelRatio).toFixed(1)}\n);\n`, ...sources, source, `\nvoid main() {\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n`);\n    const vertexShader = createShader(gl, gl.VERTEX_SHADER, `\nattribute vec2 a_vertex;\n\nvoid main() {\n  gl_Position = vec4(a_vertex, 0.0, 1.0);\n}\n`);\n    const vertexBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, Float32Array.of(-1, -1, +1, -1, +1, +1, -1, +1), gl.STATIC_DRAW);\n    const program = createProgram(gl, vertexShader, fragmentShader);\n    gl.useProgram(program);\n    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\n    const a_vertex = gl.getAttribLocation(program, \"a_vertex\");\n    gl.enableVertexAttribArray(a_vertex);\n    gl.vertexAttribPointer(a_vertex, 2, gl.FLOAT, false, 0, 0);\n    for (const [name, u] of uniforms) u.location = gl.getUniformLocation(program, name);\n    const ondispose = invalidation === undefined ? Inputs.disposal(canvas) : invalidation;\n    let frame;\n    let disposed = false;\n    ondispose.then(() => disposed = true);\n    async function render() {\n      if (visibility !== undefined) await visibility();\n      frame = undefined;\n      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n    }\n    Object.assign(canvas, {\n      update(values = {}) {\n        if (disposed) return false;\n        for (const name in values) {\n          const u = uniforms.get(name);\n          if (!u) throw new Error(`unknown uniform: ${name}`);\n          gl.uniform1f(u.location, values[name]);\n        }\n        frame || requestAnimationFrame(render);\n        return true;\n      }\n    });\n    for (const [name, input] of inputs) {\n      const u = uniforms.get(name);\n      if (!u) throw new Error(`unknown uniform: ${name}`);\n      gl.uniform1f(u.location, input.value);\n      const update = () => {\n        gl.uniform1f(u.location, input.value);\n        frame || requestAnimationFrame(render);\n      };\n      input.addEventListener(\"input\", update);\n      ondispose.then(() => input.removeEventListener(\"input\", update));\n    }\n    if (iTime) {\n      frame = true; // always rendering\n      const u_time = gl.getUniformLocation(program, \"iTime\");\n      let timeframe;\n      (async function tick() {\n        if (visibility !== undefined) await visibility();\n        gl.uniform1f(u_time, performance.now() / 1000);\n        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n        return timeframe = requestAnimationFrame(tick);\n      })();\n      ondispose.then(() => cancelAnimationFrame(timeframe));\n    } else {\n      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);\n    }\n    return canvas;\n  };\n})","pinCode":false,"dname":"9d296820-532b-4633-a9d0-795a2b15bbeb","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"createShader = (function createShader(gl, type, ...sources) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, sources.join(\"\\n\"));\n  gl.compileShader(shader);\n  if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;\n  throw new Error(gl.getShaderInfoLog(shader));\n})","pinCode":false,"dname":"a6d5fcd3-b66c-4d53-a9d9-41dd3f4957d8","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"createProgram = (function createProgram(gl, ...shaders) {\n  const program = gl.createProgram();\n  for (const shader of shaders) gl.attachShader(program, shader);\n  gl.linkProgram(program);\n  if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program;\n  throw new Error(gl.getProgramInfoLog(program));\n})","pinCode":false,"dname":"eba3783a-f3c4-4a1d-ad5e-97e977d90900","codeMode":"javascript2"}}}],"version":"2.19.1"}