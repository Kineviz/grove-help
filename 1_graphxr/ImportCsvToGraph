{"blocks":[{"type":"header","data":{"text":"One method","level":2}},{"type":"codeTool","data":{"codeData":{"value":"viewof file2 = Inputs.file({\n  label: \"Select a CSV File\",\n  accept: \".csv\",\n  required: true,\n})","pinCode":false,"dname":"659eb1de-dabb-4e4a-a946-b82313cccd75","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Inputs.button(\"Click to Import GraphXR\", {\n  reduce: async () => {\n    let file = new File([await file2.blob()], file2.name, file2.type);\n    csvPlainFile.import(file, file.name);\n  },\n})","pinCode":false,"dname":"9c98e601-3fd5-4fb4-9f7b-fa633f90cb8c","codeMode":"javascript2"}}},{"type":"header","data":{"text":"Two method","level":2}},{"type":"codeTool","data":{"codeData":{"value":"names$csv = FileAttachment(\"names.csv\")","pinCode":false,"dname":"f9525d88-fd64-4b92-bbd8-e80ccbc3753e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Inputs.button(\"Click to Import GraphXR\", {\n  reduce: async () => {\n    let file = new File(\n      [await names$csv.blob()],\n      names$csv.name.substring(names$csv.name.lastIndexOf(\"/\") + 1),\n      { type: names$csv.mimeType }\n    );\n    csvPlainFile.import(file, file.name);\n  },\n})","pinCode":false,"dname":"734fe71c-f7eb-4b54-a059-7d157f5b2636","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"csvPlainFile = new CSVPlainFile(window.opener._drawing.graph, window.opener._drawing);","pinCode":false,"dname":"0dbdb287-6b91-4e91-b468-db0556d05cd1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"genRelations = function (graph, relations, tokens) {\n  for (let i = 0; i < relations.length; i++) {\n    let relation = relations[i];\n    let target = _.filter(tokens, (token) => {\n      return token.data.detail.data.token_start === relation.child;\n    })[0];\n    let source = _.filter(tokens, (token) => {\n      return token.data.detail.data.token_start === relation.head;\n    })[0];\n    if (source && target) {\n      graph.addEdge(source, target, _.assign({ name: \"EXPERIENCE_IN\" }, relation));\n    }\n  }\n}","pinCode":false,"dname":"199fac4d-9b6e-4550-9f24-cb11f4767ada","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"CSVPlainFile = class  {\n     constructor(graph, drawing) {\n        this.graph = graph;\n        this.drawing = drawing;\n    }\n    randomizeNodePosition(node) {\n        node.position.x = Math.random() - 0.5;\n        node.position.y = Math.random() - 0.5;\n        node.position.z = Math.random() - 0.5;\n    }\n\n    importCSV(csvString, callback = (err, res) => { }, name = '', prefix ='') {\n \n        let dataList = Common.convertCSV2JSON(csvString)\n\n        if(dataList.length <= 0){\n            return callback( new Error(\"0 valid entry found in csv. Please check data format. We only support regular comma separated csv with single line of header\"));\n        }\n        try {\n            let nodes = dataList.map((data, index) => {\n                //start fit neo4j data\n                data[':ID'] && (data['id'] = data[':ID']) && (delete data[':ID'])\n                data[':TYPE'] && (data['type'] = data[':TYPE']) && (delete data[':TYPE'])\n                data[':LABEL'] && (data['type'] = data[':LABEL']) && (delete data[':LABEL'])\n                data[':START_ID'] && (data['sourceId'] = data[':START_ID']) && (delete data[':START_ID'])\n                data[':END_ID'] && (data['targetId'] = data[':END_ID']) && (delete data[':END_ID'])\n                //end fit neo4j data\n\n                let label = prefix + name.split('.')[0];\n\n                let node = data.id == undefined ? new Node(genUniqNodeId()) : new Node(`${label}_${data.id}`);\n\n                node.data.detail = {\n                    type: label,\n                    data: data\n                }\n                // node.name = data.label;\n                node.color.setStyle(TypeColor.getColorByType(label));\n                this.randomizeNodePosition(node);\n                return node;\n            })\n\n            this.graph.addNodes(nodes);\n\n            this.drawing.forceStartLayout();\n            callback(null, \"done\")\n\n        } catch (error) {\n            callback(error)\n        }\n    }\n\n    import(file, fileName) {\n        console.log(\"importing csv plain file\")\n        Common.showLoading(\"tips.statTips.importing\");\n        let self = this;\n        async.waterfall([\n            function (callback) {\n              \tconst reader = new FileReader();\n                reader.onloadend = function (e) {\n                  let content = e.target.result;\n                  callback(null, content);\n                };\n                reader.onerror = function (e) {\n                  callback(e,null);\n                };\n                const reader2 = new FileReader();\n                reader2.onloadend = function (e) {\n                  let csvResult = e.target.result.split(/\\r|\\n|\\r\\n/);\n                  reader.readAsText(file, jschardet.detect(csvResult.toString()).encoding);\n                };\n                reader2.onerror = function (e) {\n                  callback(e,null);\n                };\n                reader2.readAsBinaryString(file);\n            },\n            (csvString, callback) => {\n                this.importCSV(csvString, callback, fileName);\n            }\n        ], function (err, result) {\n            if (err) {\n                console.error(err);\n                Common.showHints( err.message || `tips.actionTips.importedFailed######${fileName}`);\n            } else {\n                console.log(\"Import successful\")\n                Common.showHints(`tips.actionTips.importedSuccessfully#######${fileName}`, Common.showTipType.success);\n            }\n\n        })\n    }\n\n    export(fileName) {\n        console.log(\"To Be implemented\")\n    }\n}\n\n","pinCode":false,"dname":"6a9de4f4-9605-4c83-8eb2-ac94798e5671","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"// iconv = import(\"https://cdn.skypack.dev/iconv-lite@0.6.3\")","pinCode":false,"dname":"20503b01-2d6f-46fd-be18-e0a026e08e4a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"genUniqNodeId = function () {\n    return (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase()\n}","pinCode":false,"dname":"56cc45e2-d673-4e6f-898f-2f4f3f0a72fa","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"isArrayWithAtLeastOneObject = (arr)=>{\n    return Array.isArray(arr) && _.max(arr.map( o=> _.isObject(o)))\n}","pinCode":false,"dname":"56fb800d-146b-40a4-bb4b-4c676530d5a4","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"isPureObjectOrArrayWithAtLeastOneObject = ( item ) => {\n    return _.isObject( item ) && ( !_.isArray( item ) || isArrayWithAtLeastOneObject(item) )\n}","pinCode":false,"dname":"099efca9-998e-452c-b3ba-ee8278bcae22","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Common = window.opener.Common","pinCode":false,"dname":"3c410191-cf46-4506-9d5a-ea235a16de6b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"pluralize = require(\"pluralize\")","pinCode":false,"dname":"197a34fa-3fe2-4819-9378-3cc73511ef87","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"async = require(\"async\")","pinCode":false,"dname":"3ecc6399-8d46-4500-bc4d-6cd2d4b5ecd7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"colors = [\"#1f77b4\", \"#aec7e8\", \"#ff7f0e\", \"#ffbb78\", \"#2ca02c\", \"#98df8a\", \"#d62728\", \"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"#c49c94\", \"#e377c2\", \"#f7b6d2\", \"#7f7f7f\", \"#c7c7c7\", \"#bcbd22\", \"#dbdb8d\", \"#17becf\", \"#9edae5\",\n'#c51162','#aa00ff','#6200ea','#304ffe','#0d47a1','#00b8d4','#00bfa5','#00c853','#64dd17','#aeea00','#ffd600','#ffab00','#3e2723','#f5f687','#730068'\n]","pinCode":false,"dname":"a219a4df-bb70-4e46-85e1-f6bbe1b3d9d2","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"TypeColor = \nclass  {\n    \n    static get colors(){\n        return colors;\n    }\n\n    static getColorByType(type) {\n        let customConfig = LabelsConfig.instance().getLabelConfig(type);\n        if (customConfig && customConfig.background_color) {\n            return customConfig.background_color\n        } else {\n            const color = this.autoGenerateColor(type);\n            LabelsConfig.instance().updateLabel({ label: type, background_color: color });\n            return color;\n        }\n    }\n\n    static rename(newType, oldType) {\n        \n    }\n    static clear() {\n        \n    }\n\n    static deleteLabel(label) {\n        \n    }\n\n    static updateColor(type, color) {\n        LabelsConfig.instance().updateLabel({ label: type, background_color: color });\n    }\n\n    static get labels() {\n        return LabelsConfig.instance().getLabels().sort((a, b) => a > b ? 1 : -1);\n    }\n\n    static autoGenerateColor(type) {\n\n        // 1. emtpy type use default color\n        if (!type || type == '') {\n            return '#ffffff';\n        }\n\n        // 2. Remark type use special color\n        if (type == 'Remark') {\n            return '#e67e22';\n        }\n\n        /*\n        // 3. Mutipler type,  e.g.  tag1:tag2, use tag1 as color type\n        if ((/\\:/ig).test(type)) {\n\n            let types = type.split(':')\n            if (types.length > 0 && !this.colorMap[type]) {\n                let color = \"#FFFFFF\"\n                types.forEach(subType => {\n                    let subTypeColor = this.colorMap[subType] ? this.colorMap[subType] : \"#ffffff\"\n                    color = this.avgcolor(color, subTypeColor)\n                });\n                // this.colorMap[type] = color\n\n            }\n        } */\n\n        // try to find an unused color\n        const usedcolors = LabelsConfig.instance().getLabels().map(l => LabelsConfig.instance().getLabelConfig(l).background_color);\n        for (const color of colors) {\n            if (!usedcolors.includes(color)) {\n                return color;\n            }\n        }\n\n        // fall back to indexing\n        return colors[LabelsConfig.instance().getLabels().length % colors.length];        \n    }\n\n    static avgcolor(color1, color2) {\n        let avg = (a, b) => {\n            return (a + b) / 2;\n        },\n            t16 = (c) => {\n                return parseInt(('' + c).replace('#', ''), 16)\n            },\n            hex = (c) => {\n                return (c >> 0).toString(16)\n            },\n            hex1 = t16(color1),\n            hex2 = t16(color2),\n            r = (hex) => {\n                return hex >> 16 & 0xFF\n            },\n            g = (hex) => {\n                return hex >> 8 & 0xFF\n            },\n            b = (hex) => {\n                return hex & 0xFF\n            },\n            res = '#' + hex(avg(r(hex1), r(hex2))) +\n                hex(avg(g(hex1), g(hex2))) +\n                hex(avg(b(hex1), b(hex2)));\n        return res;\n    }\n\n    \n}\n","pinCode":false,"dname":"bd3c6cf1-1b5f-401e-99cc-88ce22775860","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Node = window.opener._GXR.Node","pinCode":false,"dname":"a8a87996-25ae-4500-a8d3-b458dd54e11a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Edge = window.opener._GXR.Edge","pinCode":false,"dname":"87facd96-cc46-479f-8993-da4c79f90cdd","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md5 = window.opener.md5","pinCode":false,"dname":"84453369-3a6c-41f6-85f4-84a79ef6f806","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"LabelsConfig = {\nlet _share_instance = null\nreturn class {\n\n    static get collectionsPrefix() {\n        return \"Collection \";\n    }\n\n    static instance() {\n        if (_share_instance == null) {\n            _share_instance = new this()\n            return _share_instance\n        }\n\n        return _share_instance\n    }\n\n    static getLabels() {\n        return this.instance().getLabels();\n    }\n\n    static findAutoCaption(nodeData) {\n        for (const cap of ['Caption', 'caption', 'Label', 'label', 'Title', 'title', 'Name', 'name']) {\n            if (nodeData[cap]) {\n                return [cap];\n            }\n        }\n        return [];\n    }\n\n    static lableCaptions(label, nodeData) {\n        return this.instance().lableCaptions(label, nodeData);\n    }\n\n    static addConfig(config){\n        return this.instance().addConfig(config);\n    }\n\n    static getConfig(label) {\n        return this.instance().getConfig(label);\n    }\n\n    static lableCaptionsStr(label, nodeData) {\n        let captionsObj = this.lableCaptions(label, nodeData);\n        if(Object.keys(captionsObj).length === 0){\n            return null;\n        }else{\n            return Object.keys(captionsObj).map(propName => {\n                return captionsObj[propName]\n            }).join(' | ')\n        }\n    }\n\n    static lableCaptionsNodeName(node) {\n        return this.lableCaptionsStr(\n            node.data.detail.type,\n            node.data.detail.data\n            ) || node.id\n    }\n\n    constructor() {\n        this.configs = {}\n    }\n\n    rename(newName, oldName) {\n        if (this.configs[oldName]) {\n            this.configs[newName] = this.configs[oldName];\n            delete this.configs[oldName];\n        }\n    }\n\n    getLabels() {\n        return Object.keys(this.configs).filter(k=>k); // filter out faslsy label names that crept into our metadata\n    }\n\n    getLabelConfig(label) {\n        let labelConfig = this.configs[String(label)] || {label};\n         if(window.atob && labelConfig.template && (/^[0-9a-zA-Z\\=\\/\\+]+$/g).test(labelConfig.template)){\n            try {\n                labelConfig.template = window.atob(labelConfig.template)\n            } catch (error) {\n                console.error(\"template:\",error)\n            }\n         }\n        return labelConfig;\n    }\n\n    lableCaptions(label, nodeData) {\n        let config = this.getLabelConfig(label);\n        let oldCaptions = config.caption_property && config.caption_property !== '' ? [config.caption_property] : [];\n        let captions = config.captions || oldCaptions;\n        return captions.reduce((captionsObj, captionPropName) => {\n            captionsObj[captionPropName] = nodeData[captionPropName];\n            return captionsObj;\n        }, {})\n    }\n\n    init(labelConfigs) {\n        if (labelConfigs && labelConfigs instanceof Array) {\n            labelConfigs.forEach(labelConfig => {\n                if (labelConfig) {\n                    if(Array.isArray(labelConfig.captions)){\n                        labelConfig.captions = [...new Set(labelConfig.captions)];\n                    }\n                    this.addConfig(labelConfig)\n                }\n            })\n        }\n    }\n\n    getInvisibleLabels() {\n        let invisible = []\n        Object.keys(this.configs).forEach(name => {\n            if (this.configs[name].visible == false) {\n                invisible.push(name)\n            }\n        })\n\n        return invisible\n    }\n\n    addConfig(config) {\n        //\"hiddenConfig\" can not allow overwrite, it only from config.js\n        let hiddenConfig = Object.assign(this.configs[config.label]?.hiddenConfig || {}, config.hiddenConfig || {} );\n        config.hiddenConfig = hiddenConfig;\n        this.configs[config.label] = config\n    }\n\n    getConfig(label){\n      return this.configs[label] || {\n        \"captions\" : [],\n        \"avatar_property\" : \"\",\n        \"size_property\" : \"\",\n        \"label\" : label,\n        \"background_color\" : \"\",\n        \"icon\" : \"\",\n        \"caption_color\" : \"\",\n        \"template\" :\"\",\n        \"visible\" : true,\n        \"properties\" : {},\n        \"hidden\": {},\n        \"hiddenConfig\":{},\n        \"order\": []\n      }\n    }\n\n    updateLabel(config) {\n        //\"hiddenConfig\" can not allow overwrite, it only from config.js\n        let hiddenConfig = Object.assign(this.configs[config.label]?.hiddenConfig || {}, config.hiddenConfig || {} );\n        config.hiddenConfig = hiddenConfig;\n        this.configs[config.label] = Object.assign(this.getConfig(config.label), config, { isUserAction: true })\n    }\n\n    deleteLabel(label) {\n        delete this.configs[label];\n    }\n}\n}","pinCode":false,"dname":"f5eec740-ada0-427b-b45a-b0e3bd492f19","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"jschardet = import(\"https://cdn.skypack.dev/jschardet@3.0.0\")","pinCode":false,"dname":"dd0d888c-5951-4070-be19-08299687adfe","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"parse = async function (file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onloadend = function (e) {\n      let content = e.target.result;\n      resolve(content);\n    };\n    reader.onerror = function (e) {\n      reject(e);\n    };\n    const reader2 = new FileReader();\n    reader2.onloadend = function (e) {\n      let csvResult = e.target.result.split(/\\r|\\n|\\r\\n/);\n      reader.readAsText(file, jschardet.detect(csvResult.toString()).encoding);\n    };\n    reader2.onerror = function (e) {\n      reject(e);\n    };\n    reader2.readAsBinaryString(file);\n  });\n}","pinCode":false,"dname":"43912e4d-0a02-4340-ac33-b85dd14a05e0","codeMode":"javascript2"}}}],"version":"2.19.1"}