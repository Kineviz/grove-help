{"blocks":[{"type":"header","data":{"text":"One method","level":2}},{"type":"codeTool","data":{"codeData":{"value":"viewof file2 = Inputs.file({\n  label: \"Select a JSON File\",\n  accept: \".json\",\n  required: true,\n})","pinCode":false,"dname":"659eb1de-dabb-4e4a-a946-b82313cccd75","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Inputs.button(\"Click to Import GraphXR\", {\n  reduce: async () => {\n    let file = new File([await file2.blob()], file2.name, file2.type);\n    jsonArrayFile.import(file, file.name);\n  },\n})","pinCode":false,"dname":"9c98e601-3fd5-4fb4-9f7b-fa633f90cb8c","codeMode":"javascript2"}}},{"type":"header","data":{"text":"Two method","level":2}},{"type":"codeTool","data":{"codeData":{"value":"UBIAI$json = FileAttachment(\"UBIAI.json\")","pinCode":false,"dname":"6abc3323-4b68-47cb-b4d0-296fd01056b9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Inputs.button(\"Click to Import GraphXR\", {\n  reduce: async () => {\n    let file = new File(\n      [await UBIAI$json.blob()],\n      UBIAI$json.name.substring(UBIAI$json.name.lastIndexOf(\"/\") + 1),\n      { type: UBIAI$json.mimeType }\n    );\n    jsonArrayFile.import(file, file.name);\n  },\n})","pinCode":false,"dname":"734fe71c-f7eb-4b54-a059-7d157f5b2636","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"jsonArrayFile = new JSONArrayFile(window.opener._drawing.graph, window.opener._drawing);","pinCode":false,"dname":"0dbdb287-6b91-4e91-b468-db0556d05cd1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"genRelations = function (graph, relations, tokens) {\n  for (let i = 0; i < relations.length; i++) {\n    let relation = relations[i];\n    let target = _.filter(tokens, (token) => {\n      return token.data.detail.data.token_start === relation.child;\n    })[0];\n    let source = _.filter(tokens, (token) => {\n      return token.data.detail.data.token_start === relation.head;\n    })[0];\n    if (source && target) {\n      graph.addEdge(source, target, _.assign({ name: \"EXPERIENCE_IN\" }, relation));\n    }\n  }\n}","pinCode":false,"dname":"199fac4d-9b6e-4550-9f24-cb11f4767ada","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"JSONArrayFile = class  {\n    constructor(graph, drawing) {\n        this.graph = graph;\n        this.drawing = drawing;\n    }\n    randomizeNodePosition(node) {\n        node.position.x = Math.random() - 0.5;\n        node.position.y = Math.random() - 0.5;\n        node.position.z = Math.random() - 0.5;\n    }\n\n    importCSV(csvFile) {\n\n    }\n\n    createNode(label, data, id) {\n        id = id || data.id || md5(_.map(data, v => v).join('_'));\n\n        let node = this.graph.getNodeById(id);\n        if (!node) {\n            node = new Node(id);\n        }\n        node.data.detail = {\n            type: label,\n            data: data\n        }\n        // node.name = data.label;\n        node.color.setStyle(TypeColor.getColorByType(label));\n        this.randomizeNodePosition(node);\n        this.graph.addNodes([node]);\n        return node\n    }\n\n    // support array of JSON obj, \n    // not support array of number, string, etc\n    parseJSON(parentLabel, parent, label, data, allRel ='_graphxr_auto_root_rel') {\n        allRel += `_${parentLabel}_${label}`;\n        // Array.isArray()\n        // if (Array.isArray(data) && _.min(data.map(d=>_.isObject(d)))) {  // at least one element is object or array\n        if( isArrayWithAtLeastOneObject(data) ) {\n            let newDataObj = {};\n            let subObjects = [];\n            data.forEach((item, k) => {\n                if (_.isObject(item)) {\n                    subObjects.push(item);\n                } else {\n                    newDataObj[k] = item;\n                }\n            });\n\n            let keySingular = pluralize.singular(label);\n          let nodes = [];\n            subObjects.forEach(item => {\n               let node = this.parseJSON(parentLabel, parent, keySingular, item);\n              if(node instanceof Node){\n                nodes.push(node);\n              }\n            });\n\n            if(_.size(newDataObj) > 0){\n              let node =  this.parseJSON(parentLabel, parent, label, newDataObj, allRel);\n              if(node instanceof Node){\n                nodes.push(node);\n              }\n            }\n          return nodes;\n         } else {\n\n            // let id = data.id || data.ID || data.uid || data.UID;\n            // if(!id){\n                // id = md5(allRel);\n            // }\n            let id = Common.genUniqId();\n\n            // let thisObj = _.omitBy(data, v => _.isObject(v));\n            let thisObj = _.omitBy(data, v => isPureObjectOrArrayWithAtLeastOneObject(v));\n            \n            let node = this.createNode(label, thisObj, id);\n            if (parentLabel !== null && parent) {\n                this.graph.addEdge(parent, node, {\n                    name: parentLabel + '-' + label\n                })\n            }\n            // let deepKeys = _.keys(_.pickBy(data, v => _.isObject(v)))\n            let deepKeys = _.keys(_.pickBy(data, v => isPureObjectOrArrayWithAtLeastOneObject(v)))\n            if(_.isEqual(deepKeys,[\"tokens\", \"relations\"])){\n              let key = \"tokens\";\n              let tokens = this.parseJSON(label, node, key, data[key], allRel);\n              genRelations(this.graph, data['relations'],tokens);\n            } else {\n              deepKeys.forEach(key => {\n               this.parseJSON(label, node, key, data[key], allRel);\n              })\n            }\n            return node;\n        }\n\n    }\n\n    creactNodeWithIBMI2Node(ibmI2Node) {\n        let node = new Node(ibmI2Node.ID);\n        let type = !(['', null, undefined].includes(ibmI2Node.Subtype)) ? ibmI2Node.Subtype : (ibmI2Node.Labels || []).pop();\n\n        node.data.detail = {\n            type: type,\n            data: Object.assign({}, {\n                id: ibmI2Node.ID,\n                label: type\n            }, ibmI2Node.Properties)\n        }\n        node.name = type;\n        node.color.setStyle(TypeColor.getColorByType(type));\n        this.randomizeNodePosition(node);\n        return node\n    }\n\n    handleIBMI2JSON(ibmI2JSON) {\n\n        let nodesSet = {};\n        ibmI2JSON.Nodes.forEach(n => {\n            nodesSet[n.ID] = this.creactNodeWithIBMI2Node(n);\n        })\n\n        let edges = ibmI2JSON.Edges.map(e => {\n\n            if (!nodesSet[e.EndA.ID]) {\n                nodesSet[e.EndA.ID] = this.creactNodeWithIBMI2Node(e.EndA);\n            }\n            if (!nodesSet[e.EndB.ID]) {\n                nodesSet[e.EndB.ID] = this.creactNodeWithIBMI2Node(e.EndB);\n            }\n\n            let edge = new Edge(nodesSet[e.EndA.ID], nodesSet[e.EndB.ID], {\n                name: e.EdgeType\n            })\n            return edge\n        })\n\n         this.graph.addNodes(_.values(nodesSet));\n        this.graph.addEdges(edges);\n\n        return {\n            nodes: Object.keys(nodesSet).map(id => this.graph.nodeSet[id]),\n            edges: edges.map(e => this.graph.edgeSet[e.id])\n          }\n    }\n\n    import(file, fileName) {\n        console.log(\"importing JSON array file\")\n        Common.showLoading(\"tips.statTips.importing\");\n\n        let self = this;\n        async.waterfall([\n            //1. try read\n            function (callback) {\n                let reader = new FileReader();\n                reader.onload = function (event) {\n                    callback(null, reader.result)\n                };\n\n                reader.onerror = function (error) {\n                    callback(error, null)\n                };\n                reader.readAsText(file);\n            },\n            //2. try parse the string to JSON list then nodes\n            function (jsonString, callback) {\n                try {\n                    let dataList = [];\n                    jsonString = String(jsonString);\n                    let splitLinesJSONStrs = jsonString.split('\\n')\n                        .map(st => String(st).trim())\n                        .filter(st => st.length > 1);\n\n                    if (splitLinesJSONStrs.filter(jsonStr => (/^[\\{\\[].+[\\]\\}]$/).test(jsonStr)).length === splitLinesJSONStrs.length) {\n                        dataList = splitLinesJSONStrs.map(JSON.parse);\n                    } else {\n                        dataList = JSON.parse(jsonString);\n                    }\n                    //IBM I2 JSON\n                    if (!Array.isArray(dataList)\n                        && dataList.Nodes\n                        && Array.isArray(dataList.Nodes)\n                        && Array.isArray(dataList.Edges)) {\n                        self.handleIBMI2JSON(dataList);\n                    } else {\n                        self.parseJSON(null, null, fileName.split('.')[0], dataList);\n                    }\n\n                    self.drawing.forceStartLayout();\n                    callback(null, \"done\")\n\n                } catch (error) {\n                    callback(error)\n                }\n            }\n        ], function (err, result) {\n            if (err) {\n                console.error(err);\n                Common.showHints(`tips.actionTips.importedFailed######${fileName}`);\n            } else {\n                console.log(\"Import successful\")\n                Common.showHints(`tips.actionTips.importedSuccessfully#######${fileName}`, Common.showTipType.success);\n            }\n\n        })\n    }\n\n    export(fileName) {\n        console.log(\"To Be implemented\")\n    }\n}\n\n","pinCode":false,"dname":"6a9de4f4-9605-4c83-8eb2-ac94798e5671","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"json = UBIAI$json.json()","pinCode":false,"dname":"17a29957-9533-4d31-b04d-1e56a10d9925","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"_.reduce(json[0].tokens,(p,o)=>{\n  p.push(o.token_start)\n  return p;\n},[]).sort((a,b)=>{return a>b?1:-1})","pinCode":false,"dname":"2a8054f8-7995-4e6c-ae24-fdc01954d661","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"_.reduce(json[0].tokens,(p,o)=>{\n  p.push(o.token_end)\n  return p;\n},[]).sort((a,b)=>{return a>b?1:-1})","pinCode":false,"dname":"4ab99137-a087-441d-a495-bc99eac82b17","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Array.from(_.reduce(json[0].relations,(p,o)=>{\n  p.add(o.child)\n  return p;\n},new Set())).sort((a,b)=>{return a>b?1:-1})","pinCode":false,"dname":"c3568190-503e-4ee7-9cb0-76e3fea9f8e1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Array.from(_.reduce(json[0].relations,(p,o)=>{\n  p.add(o.head)\n  return p;\n},new Set())).sort((a,b)=>{return a>b?1:-1})","pinCode":false,"dname":"0c6b7177-293b-4240-adaf-6064d21ece65","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"genUniqNodeId = function () {\n    return (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase()\n}","pinCode":false,"dname":"56cc45e2-d673-4e6f-898f-2f4f3f0a72fa","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"isArrayWithAtLeastOneObject = (arr)=>{\n    return Array.isArray(arr) && _.max(arr.map( o=> _.isObject(o)))\n}","pinCode":false,"dname":"56fb800d-146b-40a4-bb4b-4c676530d5a4","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"isPureObjectOrArrayWithAtLeastOneObject = ( item ) => {\n    return _.isObject( item ) && ( !_.isArray( item ) || isArrayWithAtLeastOneObject(item) )\n}","pinCode":false,"dname":"099efca9-998e-452c-b3ba-ee8278bcae22","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Common = window.opener.Common","pinCode":false,"dname":"3c410191-cf46-4506-9d5a-ea235a16de6b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"pluralize = require(\"pluralize\")","pinCode":false,"dname":"197a34fa-3fe2-4819-9378-3cc73511ef87","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"async = require(\"async\")","pinCode":false,"dname":"3ecc6399-8d46-4500-bc4d-6cd2d4b5ecd7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"colors = [\"#1f77b4\", \"#aec7e8\", \"#ff7f0e\", \"#ffbb78\", \"#2ca02c\", \"#98df8a\", \"#d62728\", \"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"#c49c94\", \"#e377c2\", \"#f7b6d2\", \"#7f7f7f\", \"#c7c7c7\", \"#bcbd22\", \"#dbdb8d\", \"#17becf\", \"#9edae5\",\n'#c51162','#aa00ff','#6200ea','#304ffe','#0d47a1','#00b8d4','#00bfa5','#00c853','#64dd17','#aeea00','#ffd600','#ffab00','#3e2723','#f5f687','#730068'\n]","pinCode":false,"dname":"a219a4df-bb70-4e46-85e1-f6bbe1b3d9d2","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"TypeColor = \nclass  {\n    \n    static get colors(){\n        return colors;\n    }\n\n    static getColorByType(type) {\n        let customConfig = LabelsConfig.instance().getLabelConfig(type);\n        if (customConfig && customConfig.background_color) {\n            return customConfig.background_color\n        } else {\n            const color = this.autoGenerateColor(type);\n            LabelsConfig.instance().updateLabel({ label: type, background_color: color });\n            return color;\n        }\n    }\n\n    static rename(newType, oldType) {\n        \n    }\n    static clear() {\n        \n    }\n\n    static deleteLabel(label) {\n        \n    }\n\n    static updateColor(type, color) {\n        LabelsConfig.instance().updateLabel({ label: type, background_color: color });\n    }\n\n    static get labels() {\n        return LabelsConfig.instance().getLabels().sort((a, b) => a > b ? 1 : -1);\n    }\n\n    static autoGenerateColor(type) {\n\n        // 1. emtpy type use default color\n        if (!type || type == '') {\n            return '#ffffff';\n        }\n\n        // 2. Remark type use special color\n        if (type == 'Remark') {\n            return '#e67e22';\n        }\n\n        /*\n        // 3. Mutipler type,  e.g.  tag1:tag2, use tag1 as color type\n        if ((/\\:/ig).test(type)) {\n\n            let types = type.split(':')\n            if (types.length > 0 && !this.colorMap[type]) {\n                let color = \"#FFFFFF\"\n                types.forEach(subType => {\n                    let subTypeColor = this.colorMap[subType] ? this.colorMap[subType] : \"#ffffff\"\n                    color = this.avgcolor(color, subTypeColor)\n                });\n                // this.colorMap[type] = color\n\n            }\n        } */\n\n        // try to find an unused color\n        const usedcolors = LabelsConfig.instance().getLabels().map(l => LabelsConfig.instance().getLabelConfig(l).background_color);\n        for (const color of colors) {\n            if (!usedcolors.includes(color)) {\n                return color;\n            }\n        }\n\n        // fall back to indexing\n        return colors[LabelsConfig.instance().getLabels().length % colors.length];        \n    }\n\n    static avgcolor(color1, color2) {\n        let avg = (a, b) => {\n            return (a + b) / 2;\n        },\n            t16 = (c) => {\n                return parseInt(('' + c).replace('#', ''), 16)\n            },\n            hex = (c) => {\n                return (c >> 0).toString(16)\n            },\n            hex1 = t16(color1),\n            hex2 = t16(color2),\n            r = (hex) => {\n                return hex >> 16 & 0xFF\n            },\n            g = (hex) => {\n                return hex >> 8 & 0xFF\n            },\n            b = (hex) => {\n                return hex & 0xFF\n            },\n            res = '#' + hex(avg(r(hex1), r(hex2))) +\n                hex(avg(g(hex1), g(hex2))) +\n                hex(avg(b(hex1), b(hex2)));\n        return res;\n    }\n\n    \n}\n","pinCode":false,"dname":"bd3c6cf1-1b5f-401e-99cc-88ce22775860","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Node = window.opener._GXR.Node","pinCode":false,"dname":"a8a87996-25ae-4500-a8d3-b458dd54e11a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Edge = window.opener._GXR.Edge","pinCode":false,"dname":"87facd96-cc46-479f-8993-da4c79f90cdd","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md5 = window.opener.md5","pinCode":false,"dname":"84453369-3a6c-41f6-85f4-84a79ef6f806","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"LabelsConfig = {\nlet _share_instance = null\nreturn class {\n\n    static get collectionsPrefix() {\n        return \"Collection \";\n    }\n\n    static instance() {\n        if (_share_instance == null) {\n            _share_instance = new this()\n            return _share_instance\n        }\n\n        return _share_instance\n    }\n\n    static getLabels() {\n        return this.instance().getLabels();\n    }\n\n    static findAutoCaption(nodeData) {\n        for (const cap of ['Caption', 'caption', 'Label', 'label', 'Title', 'title', 'Name', 'name']) {\n            if (nodeData[cap]) {\n                return [cap];\n            }\n        }\n        return [];\n    }\n\n    static lableCaptions(label, nodeData) {\n        return this.instance().lableCaptions(label, nodeData);\n    }\n\n    static addConfig(config){\n        return this.instance().addConfig(config);\n    }\n\n    static getConfig(label) {\n        return this.instance().getConfig(label);\n    }\n\n    static lableCaptionsStr(label, nodeData) {\n        let captionsObj = this.lableCaptions(label, nodeData);\n        if(Object.keys(captionsObj).length === 0){\n            return null;\n        }else{\n            return Object.keys(captionsObj).map(propName => {\n                return captionsObj[propName]\n            }).join(' | ')\n        }\n    }\n\n    static lableCaptionsNodeName(node) {\n        return this.lableCaptionsStr(\n            node.data.detail.type,\n            node.data.detail.data\n            ) || node.id\n    }\n\n    constructor() {\n        this.configs = {}\n    }\n\n    rename(newName, oldName) {\n        if (this.configs[oldName]) {\n            this.configs[newName] = this.configs[oldName];\n            delete this.configs[oldName];\n        }\n    }\n\n    getLabels() {\n        return Object.keys(this.configs).filter(k=>k); // filter out faslsy label names that crept into our metadata\n    }\n\n    getLabelConfig(label) {\n        let labelConfig = this.configs[String(label)] || {label};\n         if(window.atob && labelConfig.template && (/^[0-9a-zA-Z\\=\\/\\+]+$/g).test(labelConfig.template)){\n            try {\n                labelConfig.template = window.atob(labelConfig.template)\n            } catch (error) {\n                console.error(\"template:\",error)\n            }\n         }\n        return labelConfig;\n    }\n\n    lableCaptions(label, nodeData) {\n        let config = this.getLabelConfig(label);\n        let oldCaptions = config.caption_property && config.caption_property !== '' ? [config.caption_property] : [];\n        let captions = config.captions || oldCaptions;\n        return captions.reduce((captionsObj, captionPropName) => {\n            captionsObj[captionPropName] = nodeData[captionPropName];\n            return captionsObj;\n        }, {})\n    }\n\n    init(labelConfigs) {\n        if (labelConfigs && labelConfigs instanceof Array) {\n            labelConfigs.forEach(labelConfig => {\n                if (labelConfig) {\n                    if(Array.isArray(labelConfig.captions)){\n                        labelConfig.captions = [...new Set(labelConfig.captions)];\n                    }\n                    this.addConfig(labelConfig)\n                }\n            })\n        }\n    }\n\n    getInvisibleLabels() {\n        let invisible = []\n        Object.keys(this.configs).forEach(name => {\n            if (this.configs[name].visible == false) {\n                invisible.push(name)\n            }\n        })\n\n        return invisible\n    }\n\n    addConfig(config) {\n        //\"hiddenConfig\" can not allow overwrite, it only from config.js\n        let hiddenConfig = Object.assign(this.configs[config.label]?.hiddenConfig || {}, config.hiddenConfig || {} );\n        config.hiddenConfig = hiddenConfig;\n        this.configs[config.label] = config\n    }\n\n    getConfig(label){\n      return this.configs[label] || {\n        \"captions\" : [],\n        \"avatar_property\" : \"\",\n        \"size_property\" : \"\",\n        \"label\" : label,\n        \"background_color\" : \"\",\n        \"icon\" : \"\",\n        \"caption_color\" : \"\",\n        \"template\" :\"\",\n        \"visible\" : true,\n        \"properties\" : {},\n        \"hidden\": {},\n        \"hiddenConfig\":{},\n        \"order\": []\n      }\n    }\n\n    updateLabel(config) {\n        //\"hiddenConfig\" can not allow overwrite, it only from config.js\n        let hiddenConfig = Object.assign(this.configs[config.label]?.hiddenConfig || {}, config.hiddenConfig || {} );\n        config.hiddenConfig = hiddenConfig;\n        this.configs[config.label] = Object.assign(this.getConfig(config.label), config, { isUserAction: true })\n    }\n\n    deleteLabel(label) {\n        delete this.configs[label];\n    }\n}\n}","pinCode":false,"dname":"f5eec740-ada0-427b-b45a-b0e3bd492f19","codeMode":"javascript2"}}}],"version":"2.19.1"}