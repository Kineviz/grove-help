{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Interacting with promises as values\n\nOne of the great things about Observable is how well it works with JavaScript Promises. Behind the scenes, it works with [Promise.all](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all), which allows non-Promise values to be passed-through.\n\nWhich is great, but what if you want to tinker with Promise semantics yourself?`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Promise.all([1, 2, Promise.resolve(3), new Promise(r => r(4))])","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The first way is just to use Promises that don't cross cell boundaries - that are declared and used within a block. For example:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let x = new Promise((resolve, reject) => {\n    setTimeout(reject, 100);\n  });\n  let caught = x.catch(rejected => {\n    return `I'm okay, I'll get over it`;\n  });\n  return caught;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`## A function that returns a promise\n\nAnother way is to wrap a Promise in a functor (or what d3 calls d3.constant now) - a function that returns a Promise. This way, it just gets passed-through Promise.all and we can interact with it as a Promise from other cells by calling the function.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"promiseValue = {\n  let val = new Promise((resolve, reject) => {\n    setTimeout(() => resolve(10), 100);\n  });\n  return () => val;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  return promiseValue().then(p => {\n    return p + 1;\n  });\n}","pinCode":false}}}],"version":"2.19.1"}