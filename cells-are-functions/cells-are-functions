{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Cells are Functions\n\nSay you have some cell *foo* whose value is false. (For demonstration purposes, this cell happens to be mutable so that we can easily change its value, but you could just as easily edit the code or use an input.)`","pinCode":false,"dname":"c9b35586-8934-4c5e-967c-81a42d634bbf","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"mutable foo = (false)","pinCode":false,"dname":"334b8306-72f4-4d54-abb1-a7f09d7e591f","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Now say you have another cell which loops, observing the value of *foo* once a second, and breaking when *foo* is false. The loop also increments a counter so that we can observe it.`","pinCode":false,"dname":"94fbc5e0-2e1a-4d03-b56d-22b7d8635ffe","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"loop1 = {\n  while (foo) {\n    await Promises.tick(1000);\n    ++mutable count1;\n  }\n}","pinCode":false,"dname":"d04738e3-6c7a-4b67-8eab-9e6f2da5aa30","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"mutable count1 = (0)","pinCode":false,"dname":"983ac0d5-93f2-458d-b48f-a0e75f0eabe4","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Initially, the loop doesn’t run because *foo* is false. But if we toggle *foo*’s value by clicking the button below once, the loop starts.`","pinCode":false,"dname":"db99e4d8-0237-4025-86fa-23706eab502f","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const button = html`<button>Set foo to ${!foo}`;\n  button.onclick = () => mutable foo = !foo;\n  return button;\n}","pinCode":false,"dname":"5ca2b107-f835-4d60-8a11-9df2545a1080","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Seems good so far: the loop’s running. But what happens when we set *foo* back to false by clicking the button again? Oops! It doesn’t stop. It runs… forever! And if we keep toggling, we now have multiple infinite loops! Ack! Why is that?\n\nIn Observable, each cell is a function; this function is called automatically [by the runtime](/@mbostock/how-observable-runs) with the values of any *other* cell it references.\n\nHere’s what the loop looks like to the runtime (omitting the counter for brevity):`","pinCode":false,"dname":"220d7621-c1df-4670-8a37-8863b792f3e1","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"loop2 = (async function loop2(foo) {\n  while (foo) {\n    await Promises.tick(1000);\n  }\n})","pinCode":false,"dname":"d6b951a7-c7ac-458d-bd1d-629b2caca8ad","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`If *foo* is initially false, the runtime invokes the loop as:`","pinCode":false,"dname":"7e917946-134e-46f8-af40-329272d032e2","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"loop2(false)","pinCode":false,"dname":"27135c3e-f5e7-4cd6-8849-27e2f9053fc4","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`When *foo* is set to true, the runtime again invokes the loop as:`","pinCode":false,"dname":"d741948c-5790-4d8a-8165-ccb4d11a73e4","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"loop2(true)","pinCode":false,"dname":"a2489982-e0be-406b-98da-11456c35ec19","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The true loop never terminates because the value of *foo* it sees never changes. When the value of *foo* changes, the cell is [invalidated](/@mbostock/disposing-content) and re-evaluated, but the old cell still runs to completion. It has to—[promises aren’t cancellable](https://github.com/tc39/proposal-cancelable-promises).\n\nTo make this clearer, we could have written an identical while-true loop, like so:`","pinCode":false,"dname":"b487ce1a-2d8f-40b1-9cee-2ef29782e535","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"loop3 = {\n  if (!foo) return;\n  while (true) await Promises.tick(1000);\n}","pinCode":false,"dname":"2d32237f-8314-4b96-87c8-c058c17dc08f","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`So, how should we implement this loop?\n\nThe most natural approach is to use a generator. Unlike promises, [generators](/@mbostock/introduction-to-generators) *are* automatically terminated on invalidation by the runtime. (But, even a generator can only be terminated when it yields! And if a generator yields a promise, that promise still runs to completion.)`","pinCode":false,"dname":"8586bbdf-2b24-4e7b-bd22-a37b00f3a553","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const button = html`<button>Set foo to ${!foo}`;\n  button.onclick = () => mutable foo = !foo;\n  return button;\n}","pinCode":false,"dname":"d2d3807a-7a82-4a67-9bff-888ccc7dbfd9","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"loop4 = {\n  if (!foo) return;\n  while (true) yield Promises.tick(100);\n}","pinCode":false,"dname":"c84a3ffa-b27d-4ee1-97e4-016844dd969c","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`If you want to avoid a generator, you can do something similar using the [invalidation promise](https://github.com/observablehq/notebook-stdlib/blob/master/README.md#invalidation) and [Promise.race](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise/race): this will throw an error when the cell is invalidated, causing the loop to terminate. This error is never shown because the cell is immediately re-evaluated, giving it a new value.`","pinCode":false,"dname":"5dfa22b5-28eb-49e3-b37c-8d596783eafc","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"loop5 = {\n  if (!foo) return;\n  const abort = invalidation.then(() => Promise.reject(\"abort\"));\n  while (true) await Promise.race([abort, Promises.tick(100)]);\n}","pinCode":false,"dname":"8d7cc386-1c9d-4dde-a5a7-58b97d916c80","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Similarly, we could explicitly set the loop condition to false on invalidation:`","pinCode":false,"dname":"3874aac6-17c0-4c5f-9d33-2f59a4078c33","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"loop6 = {\n  let run = foo;\n  invalidation.then(() => run = false);\n  while (run) await Promises.tick(100);\n}","pinCode":false,"dname":"7544be29-4dda-481f-8998-447ca704258d","codeMode":"javascript2","hide":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`For a related topic, see [Animation Loops](/@mbostock/animation-loops).`","pinCode":false,"dname":"5369229b-d24c-4f7a-bef3-c9a600317c3d","codeMode":"javascript2","hide":false}}}],"version":"2.19.1"}