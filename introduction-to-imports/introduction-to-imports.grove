{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Introduction to Imports\n\nObservable lets you quickly reuse code by importing named cells from other notebooks.\n`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`## Example of Importing a Function`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Let’s say you saw Mike Bostock's notebook of [color scales](https://observablehq.com/@mbostock/color-ramp) used to visualize quantitative data. That notebook defines a \\`ramp\\` function that returns a canvas for a given \\`color\\` function, where the \\`color\\` function returns a color for a given ${tex`t \\in [0,1]`} from left to right. To create the dreaded angry rainbow yourself, import and call \\`ramp\\`:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { ramp }  from 'introduction-to-imports/1104ceb0818de884'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"ramp(t => `hsl(${t * 360}, 100%, 50%)`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`**Note**: For the source of the \\`import\\` statement, use the Observable username and notebook name; that is:\n\n\\`from\\` @_username_/_notebookName_\n\nYou can get these from the URL of the notebook from which you are importing.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`## Why Import vs. Copy-Paste?`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You could instead copy-paste the \\`ramp\\` function from that notebook into this one—it’s only a few lines of code. But imports have a few advantages.\n`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`### Cell Dependencies`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`First, the cell you want to reuse may depend on other cells. If you copy-paste, you have to copy-paste those other cells too, and make sure that they don’t conflict with existing cells in your notebook. If you import, the dependencies are loaded automatically, so you don’t have to think about it.\n\nFor example, consider a notebook on an interrupted Sinu–Mollweide map projection that requires the D3 and TopoJSON libraries, along with geometry representing the Earth’s landmasses. You can import the map and display it without worrying about how the sausage is made.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { map }  from 'introduction-to-imports/3009e58635e3ac37'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"map","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`### Re-used Code Stays Up-to-Date`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Second, by importing, it’s easier to keep the reused code up-to-date. Imports target the latest published version, so if Mike improves his map notebook, the new map will automatically appear here.\n\n(The risk of importing the latest version is that your notebook may break if the imported notebook changes in a non-backwards-compatible way. Observable also supports versioned imports; however, version numbers aren’t currently exposed in the user interface, so for now you must specify the version manually. In the future, imports will be pinned to the latest published version at the time you write the import statement, and can be re-pinned on-demand.)`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`### \"Rewrite\" Code Using \\`import\\` - \\`with\\``","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Third, and most excitingly, Observable imports let you inject dependencies using \\`import\\`-\\`with\\`! This lets you “rewrite” imported code as you might do when copy-pasting, without the problems of code duplication.\n\nConsider Mike Bostock's D3 treemap notebook that visualizes the Flare dataset. To reuse this treemap implementation to visualize a different dataset, inject a new definition of \\`data\\` in the \\`with\\` clause on import:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { chart as treemap } with { treemap_data as data } from 'introduction-to-imports/a1fd3857bac219b0'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"treemap","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"treemap_data = (FileAttachment(\"d3.json\").json())","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`As long as the new data conforms to the same shape as the old data (here, a tree of objects with *children* and *value* properties), you can reuse the existing code without copy-paste and the terrible challenge of designing a reusable chart abstraction!`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`### Adding Dynamic Definitions to Previously Static Code`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`\nBest of all, because [Observable is reactive](/@observablehq/how-observable-runs), you can even inject dynamic definitions into code that was previously static!\n\nFor example, below is a histogram of a synthetic beta distribution using ${tex`\\alpha`} and ${tex`\\beta`} values that are controlled by sliders. Whenever ${tex`\\alpha`} or ${tex`\\beta`} change, Observable automatically updates the histogram—even though the implementation is reused from a static histogram of unemployment rates.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { chart as histogram } with { histogram_data as data } from 'introduction-to-imports/8d5ef3030dfd3bad'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof alphabeta = {\n  const form = html`<form style=\"font: 12px var(--sans-serif);\">\n  <label style=\"display: block;\">\n    <input name=a type=range min=0 max=5 step=0.01 style=\"width:180px;\">\n    ${tex`\\alpha`} = <output name=oa></output>\n  </label>\n  <label style=\"display: block;\">\n    <input name=b type=range min=0 max=5 step=0.01 style=\"width:180px;\">\n    ${tex`\\beta`} = <output name=ob></output>\n  </label>\n</form>`;\n  form.oninput = () => {\n    form.value = [form.a.valueAsNumber, form.b.valueAsNumber];\n    form.oa.value = form.a.valueAsNumber;\n    form.ob.value = form.b.valueAsNumber;\n  };\n  form.oninput();\n  return form;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"histogram","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"histogram_data = (new Array(10000).fill().map(() => randb(...alphabeta)))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`### Nuances When Using Imports`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Here are a few additional nuances of imports:\n\n- Like [ES imports](http://exploringjs.com/es6/ch_modules.html), Observable imports are live bindings. If you import a value that changes over time ([a generator cell](/@mbostock/generator-cells-functions-and-objects)), such as a countdown to a certain date in the future, the imported value will change over time, too.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { interval }  from 'introduction-to-imports/34b302df6d20aafa'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"interval","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`\n- You can only import named cells, and you must name each cell you want to import explicitly. No anonymous cells allowed; if a notebook uses side effects, as is sometimes common with anonymous cells, you must name and import the cells with side effects, too. (See [Naming Cells](#howToNameCells) for a refresher on naming cells.)\n\n- Imported cells are lazily evaluated: if you import a cell but you don’t reference it anywhere, the code won’t run. Try uncommenting the cell below and then hit Shift-Enter. Notice that the generator *i* begins at zero—it doesn’t start until referenced.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { i }  from 'introduction-to-imports/b5f8f4ac4587424b'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`\n- Also like ES imports, only the cells you import are available (*bound*) in the local notebook, even if those cells depend on other cells. Those dependent cells are *run*—they’re just not exposed in the scope of the local notebook.\n\n- You can use circular imports, but only if you don’t use the *with* clause when importing. Import-with effectively creates a local copy of the imported module with your overrides, so a circular import-with would create an infinitely recursive module, a bit like seeing your reflection in a mirrored room.\n\n- You can import the same notebook multiple times and references will resolve exactly. (Note, however, that the versions of the imported notebooks must also match, or they are considered different notebooks.)`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { map as map2 }  from 'introduction-to-imports/3009e58635e3ac37'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"map === map2","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`### Import Visualizer for Debugging`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`If you find yourself using lots of imports in your notebooks, you might find our [import visualizer](/@observablehq/notebook-import-visualizer) helpful for debugging. For example, here are the imports used by this notebook. *So meta!*`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"graph","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"shared = (md`### Public, Unlisted, and Private imports\n\nThe examples so far have imported from publicly shared notebooks. But you can import from unlisted notebooks, too:`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { functionFromUnlistedNotebook }  from 'introduction-to-imports/00ff3ac693572256'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"functionFromUnlistedNotebook","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can even import from private notebooks; however, if you publish a notebook that imports a private notebook, the imported private notebook won’t be accessible to your readers, which may prevent your notebook from functioning as intended. Don’t forget to share or publish your imports before you publish.\n\nLastly, imports aren’t intended to replace libraries (like [lodash](https://lodash.com) or [D3](https://d3js.org)); if you want to design, build and support a reusable library, go for it and publish to npm! But if you want a lightweight way to reuse code across notebooks without resorting to copy-paste, reach for import.\n\n---`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"howToNameCells = (md `## Naming Cells`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can assign a name to a JavaScript cell in one of the four following ways:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Naming a cell expression:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"expressionName = (8)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Naming a block:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"blockName = { return 80; }","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Naming a function declaration:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"functionName = (function functionName() {return 800;})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Naming a class:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"className = (class className {})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`See the title of this section for an example of how to name a Markdown cell.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`## Appendix`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"url = (\"https://api.observablehq.com/@observablehq/introduction-to-imports.js?v=3\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"orient = (\"LR\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { graphic as graph } with { url, orient } from 'introduction-to-imports/6e03337c4b8d8cec'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"randb = (function randb(alpha, beta) {\n  const u = randg(alpha);\n  return u / (u + randg(beta));\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"randg = (function randg(shape) {\n  let oalph = shape, a1, a2, u, v, x, mat;\n  if (!shape) shape = 1;\n  if (shape < 1) shape += 1;\n  a1 = shape - 1 / 3;\n  a2 = 1 / Math.sqrt(9 * a1);\n  do {\n    do {\n      x = randn();\n      v = 1 + a2 * x;\n    } while (v <= 0);\n    v = v * v * v;\n    u = Math.random();\n  } while (\n    u > 1 - 0.331 * Math.pow(x, 4) &&\n    Math.log(u) > 0.5 * x * x + a1 * (1 - v + Math.log(v))\n  );\n  if (shape === oalph) return a1 * v; // alpha > 1\n  do u = Math.random(); while (u === 0); // alpha < 1\n  return Math.pow(u, 1 / oalph) * a1 * v;\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"randn = (function randn() {\n  let u, v, x, y, q;\n  do {\n    u = Math.random();\n    v = 1.7156 * (Math.random() - 0.5);\n    x = u - 0.449871;\n    y = Math.abs(v) + 0.386595;\n    q = x * x + y * (0.19600 * y - 0.25472 * x);\n  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));\n  return v / u;\n})","pinCode":false}}}],"version":"2.19.1"}