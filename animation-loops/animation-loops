{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Animation Loops\n\nThere are several ways to implement animations in Observable. Each approach has its plusses and minuses, but a [generator loop](#o2) should be your default choice: it is concise, reasonably fast and the easiest to implement correctly.`","pinCode":false,"dname":"c4fecf63-94c8-4ed0-8091-fd7a3c0b7fd5","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"o1 = (md`## Option 1: Timer Loop\n\nThe vanilla way of animating is to call [requestAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame) recursively. A *tick* function draws to the canvas sixty times a second. This implementation stores the timer handle so it can break the loop when the cell is [invalidated](/@mbostock/disposing-content). It is also careful to call *tick* synchronously the first time it runs to avoid a blank flash on the first frame. If an external value changes, such as the *width*, *height* or *radius*, the old canvas and animation loop are discarded, and a new loop starts on a fresh canvas.`)","pinCode":false,"dname":"68bf0915-64c1-43cc-b159-43d389ab8e1a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const context = DOM.context2d(width, height);\n  let frame;\n  \n  (function tick() {\n    const x = (Math.sin(Date.now() / 1000) + 1) / 2 * (width - 2 * radius) + radius;\n    context.clearRect(0, 0, width, height);\n    context.beginPath();\n    context.arc(x, height / 2, radius, 0, 2 * Math.PI);\n    context.fill();\n    frame = requestAnimationFrame(tick);\n  })();\n  \n  invalidation.then(() => cancelAnimationFrame(frame));  \n  return context.canvas;\n}","pinCode":false,"dname":"2d47545f-a762-44b9-af54-512006ee9ea7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Pros: Familiar.\n\nCons: Verbose; requires explicit invalidation; slow if external values change.`","pinCode":false,"dname":"69737aed-caed-400c-978b-390f126dda93","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"o2 = (md`## Option 2: Generator Loop ✨\n\nAn idiomatic alternative to the timer loop in Observable is a generator loop that yields the same DOM element (the canvas) repeatedly. This is more concise than the timer loop above, and invalidation is handled automatically. Like the timer loop, if an external value changes, the old generator is discarded and a new one is created with a fresh canvas.`)","pinCode":false,"dname":"68ca09a6-ab08-4a5e-8741-e385f4d72835","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const context = DOM.context2d(width, height);\n  while (true) {\n    const x = (Math.sin(Date.now() / 1000) + 1) / 2 * (width - 2 * radius) + radius;\n    context.clearRect(0, 0, width, height);\n    context.beginPath();\n    context.arc(x, height / 2, radius, 0, 2 * Math.PI);\n    context.fill();\n    yield context.canvas;\n  }\n}","pinCode":false,"dname":"f93b7ce7-165c-492e-ace3-74c5d81f6544","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Pros: Concise.\n\nCons: Slow if external values change.`","pinCode":false,"dname":"cb3587da-cbf7-4764-b8f9-5757cd12dfea","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"o3 = (md`## Option 3: Now\n\nThe most concise approach is a “pure” cell referencing [*now*](https://github.com/observablehq/notebook-stdlib/blob/master/README.md#now), a reactive variable representing the current time provided by the [standard library](https://github.com/observablehq/notebook-stdlib). Although concise, this approach is wasteful since a new canvas is created on every frame; however, modern browsers are surprisingly efficient at recycling elements, so this may be a viable approach for simple animations.`)","pinCode":false,"dname":"1e0a62af-7385-4ed1-8f88-ad8c99bb7caa","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const context = DOM.context2d(width, height);\n  const x = (Math.sin(now / 1000) + 1) / 2 * (width - 2 * radius) + radius;\n  context.beginPath();\n  context.arc(x, height / 2, radius, 0, 2 * Math.PI);\n  context.fill();\n  return context.canvas;\n}","pinCode":false,"dname":"9e0d83c9-912e-4ca1-a133-1d3d8fa6df85","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Pros: Even more concise!\n\nCons: Slow.`","pinCode":false,"dname":"dec1ff7d-ce85-4077-8dff-242969b8287f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"o4 = (md`## Option 4: Now and This\n\nThe pure approach (option 3) can be optimized by recycling the canvas from the previous frame using [*this*](/@tmcw/untitled/5), making it as fast as the other options. Although slightly more concise than a generator (option 2), this approach is not generally recommended because it is easy to respond incorrectly to external values changing. For example, the implementation below has a bug where the canvas is not resized if the *width* or *height* changes.`)","pinCode":false,"dname":"f5a4066a-3e06-4854-a687-1579e487f14a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const context = this ? this.getContext(\"2d\") : DOM.context2d(width, height);\n  const x = (Math.sin(now / 1000) + 1) / 2 * (width - 2 * radius) + radius;\n  context.clearRect(0, 0, width, height);\n  context.beginPath();\n  context.arc(x, height / 2, radius, 0, 2 * Math.PI);\n  context.fill();\n  return context.canvas;\n}","pinCode":false,"dname":"63b25cea-6f79-4234-b8c0-88c1895f4272","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Pros: Concise.\n\nCons: Brittle.`","pinCode":false,"dname":"ba10a7c0-0eee-47b3-8455-af0f24808fad","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`## Reusable Loops\n\nBe careful about calling requestAnimationFrame, setTimeout or setInterval from a reusable function: the invalidation promise is local to each cell! If your function cell references *invalidation*, it resolves when the function cell is rerun, *not* when the calling cell is rerun, and thus your notebook may leak!\n\nYou can fix this by explicitly passing in the invalidation promise from the calling cell, but a more self-contained pattern is to switch to a generator function. Generators can clean up after themselves using a try-finally block or by implementing *generator*.return directly.`","pinCode":false,"dname":"c4983482-25ad-4c2a-8e9b-83d7e08b2c58","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"animate = (function* animate() {\n  while (true) {\n    yield Promises.tick(250, (Math.sin(Date.now() / 1000) + 1) / 2 * (width - 2 * radius) + radius);\n  }\n})","pinCode":false,"dname":"62a7e3c9-510c-404e-9533-e0cff0cbda55","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const context = DOM.context2d(width, height);\n  for (const x of animate()) {\n    yield x.then(x => {\n      context.clearRect(0, 0, width, height);\n      context.beginPath();\n      context.arc(x, height / 2, radius, 0, 2 * Math.PI);\n      context.fill();\n      return context.canvas;\n    });\n  }\n}","pinCode":false,"dname":"35cf2e3c-539f-4db8-bb18-680363c8f832","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"height = (33)","pinCode":false,"dname":"d9bcad6e-ff80-44f5-8891-8a550b0720ee","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"radius = (height / 2 - 5)","pinCode":false,"dname":"2120c552-d3ea-4ecc-aa22-c53115a95282","codeMode":"javascript2"}}}],"version":"2.19.1"}