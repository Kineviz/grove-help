{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Introduction to Mutable State\n\n<img src=\"${await FileAttachment(\"image.png\").url()}\" style=\"height: 280px;\" />\n\n${Link(\"introduction-to-notebooks/introduction-to-notebooks\",\"Grove notebooks are made of cells.\")} Each cell is defined by a bit of code (just click on the left margin!) and will react to updates in any other cells it references.\n\nTo take full advantage of this reactivity, **we generally want to [avoid mutation](https://observablehq.com/@tmcw/observable-anti-patterns-and-code-smells#mutation) in our Observable code**. Instead of reaching into the contents of other cells and setting values imperatively, each cell should usually return a new value when it runs. Any cells that reference that value will run _every time_ the upstream cell recomputes.\n\nBut once in a while, you might run into a situation where this reactivity becomes a bit tricky to work with. For example:\n- What if I want a cell to update _some_ but not _all_ of the times another cell’s value changes? \n- What if I want a long-running cell — like an animation loop — to use another cell’s value, but not reset itself when that value changes?\n- What if I want to be able to set a cell’s value programmatically?\n\nIn situations like these you have two main options:\n- Rewrite your code to use a functional style and avoid mutation (generally the best idea!), or\n- Use Observable’s \\`mutable\\` keyword to define a cell with a _mutable_ value — one that is meant to be changed by other cells.\n\nIn this notebook we’ll look at the second option — using the \\`mutable\\` keyword to define values that can be changed from within other cells, and how we can use both reactive and non-reactive references to those values in other cells as needed. \n\n*Note: The \\`mutable\\` keyword is easy to misuse in a way that makes it more difficult to successfully write Observable notebooks! Think of it as an **escape hatch** for those rare cases where you find the need to bypass Observable’s reactive dataflow model.*\n\n-----`","pinCode":false,"dname":"1df106e2-ae47-4b86-b503-8711619d9536","codeMode":"javascript2","vimEnabled":false,"insertMode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`## When is \\`mutable\\` useful?`","pinCode":false,"dname":"acf89850-5ddf-4f6f-b4f8-d10657fe777e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`In Observable, a cell will automatically run each time any value it depends on changes.\n\nFor example, here’s a cell that increments a \\`count\\` by 1 every second:`","pinCode":false,"dname":"d6273f09-d65a-4f01-ac63-5cabc078cb13","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"count = {\n  let i = 0;\n  while (true) yield Promises.delay(1000, ++i);\n}","pinCode":false,"dname":"eb6a0dbf-4004-4c6e-9b74-e312983f8e19","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`And here’s a second cell that depends on \\`count\\`, doubling it:`","pinCode":false,"dname":"95cbe12a-8f8e-4cc3-b323-cc4e2c49fc4a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"doubleCount = (count * 2)","pinCode":false,"dname":"bb606252-03f7-4075-ac43-8acd94daa5cd","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Every time \\`count\\` yields a value, \\`doubleCount\\` is re-evaluated by the Observable runtime. *But what if we’d like to have a cell that updates only when \\`count\\` is an even number?* We might try something like this:`","pinCode":false,"dname":"351ceb3f-5f1f-46d1-9d99-fa5a46fb2da4","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"evenCount = {\n  yield count % 2 === 0 ? count : this;\n}","pinCode":false,"dname":"584bd2d7-84d4-4caa-99ae-bcc1fd104f94","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Unfortunately, \\`evenCount\\` — and every downstream cell that might depend on it — necessarily updates every time that \\`count\\` does, regardless of whether or not a new even number has been produced.\n\nInstead, you can use Observable’s \\`mutable\\` keyword to define a cell with a mutable value — one that is meant to be changed by other cells. `","pinCode":false,"dname":"53ca8090-89da-40cd-8a0f-5bcbae5d79d9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`## How does \\`mutable\\` work?`","pinCode":false,"dname":"e73045c5-cad9-44a5-bd1f-fdb49d00df39","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Let’s build another counter that ticks every second, this time using two mutable values, one that only updates when the counter is even, and another that only updates when the counter is divisible by 5.`","pinCode":false,"dname":"68a9335d-abd8-4a1f-8b80-509b4ddff72d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"counter = {\n  let i = 0;\n  while (true) {\n    if (i % 2 === 0) mutable counterEven = i;\n    if (i % 5 === 0) mutable counterFives = i;\n    yield Promises.delay(1000, ++i);\n  }\n}","pinCode":false,"dname":"03849862-1db0-41fb-85a3-a5f9080f5966","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"mutable counterEven = (0)","pinCode":false,"dname":"cfa783a2-fb9f-4590-a0dc-ca3113333037","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"mutable counterFives = (0)","pinCode":false,"dname":"86d8ca01-eae0-4d5b-87d9-9ab02fbea3db","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`By using \\`mutable\\`, we can control the timing of when a downstream cell should be re-evaluated, by only setting its value at the appropriate moment. This can help cells share values without creating circular dependencies, and also prevent cells from updating more often than is needed — while allowing any cells that depend on them to continue receiving reactive updates as normal.\n\nFor a more practical example, let’s build a little animation, running at 60 frames per second, that shows a ball bouncing off the walls, along with a value that tells us which of the four walls it has most recently hit.\n\nFirst, in the normal reactive style, using [viewof](/@observablehq/a-brief-introduction-to-viewof):`","pinCode":false,"dname":"27c2765c-3f50-431d-a7a6-3ec4f3d3af23","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"w = (400)","pinCode":false,"dname":"bafbebe6-363f-4892-96bc-9a6b16f98d20","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"h = (233)","pinCode":false,"dname":"52202ccb-7860-4931-bf78-6796cb9d0b2c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"reactiveWalls","pinCode":false,"dname":"6aa197eb-1748-41ad-87ba-e385e5691aac","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"viewof reactiveWalls = {\n  var c = DOM.context2d(w, h);  \n  var ball = {x: w / 2, y: h / 2, r: 8, dx: 2, dy: 2};\n  var wall = null;\n  \n  while (true) {\n    ball.x += ball.dx, ball.y += ball.dy;\n    \n    c.fillStyle = \"black\";\n    c.fillRect(0, 0, w, h);\n    c.beginPath();\n    c.fillStyle = \"red\";\n    c.arc(ball.x, ball.y, ball.r, 0, 2 * Math.PI);\n    c.fill();\n    \n    if (ball.x - ball.r < 0) wall = \"left\",   ball.dx = 2;\n    if (ball.x + ball.r > w) wall = \"right\",  ball.dx = -2;\n    if (ball.y - ball.r < 0) wall = \"top\",    ball.dy = 2;\n    if (ball.y + ball.r > h) wall = \"bottom\", ball.dy = -2;\n    \n    c.canvas.value = wall;\n    yield c.canvas;\n  }  \n}","pinCode":false,"dname":"27a61342-d9a2-469a-a181-79b1864e2600","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can see that the \\`reactiveWalls\\` cell above is updating 60 times a second — every time the ball moves — even though its value isn’t changing nearly that often.\n\nAs an alternative, using \\`mutable\\`:`","pinCode":false,"dname":"6085e27b-08b3-49f0-85dc-41634c72978f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"mutable wall = (null)","pinCode":false,"dname":"e1a98f8f-0042-4765-a0e3-c499ca39d540","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"mutableWalls = {\n  var c = DOM.context2d(w, h);  \n  var ball = {x: w / 2, y: h / 2, r: 8, dx: -2, dy: -2};\n  \n  while (true) {\n    ball.x += ball.dx, ball.y += ball.dy;\n    \n    c.fillStyle = \"black\";\n    c.fillRect(0, 0, w, h);\n    c.beginPath();\n    c.fillStyle = \"blue\";\n    c.arc(ball.x, ball.y, ball.r, 0, 2 * Math.PI);\n    c.fill();\n    \n    if (ball.x - ball.r < 0) mutable wall = \"left\",   ball.dx = 2;\n    if (ball.x + ball.r > w) mutable wall = \"right\",  ball.dx = -2;\n    if (ball.y - ball.r < 0) mutable wall = \"top\",    ball.dy = 2;\n    if (ball.y + ball.r > h) mutable wall = \"bottom\", ball.dy = -2;\n    \n    yield c.canvas;\n  }  \n}","pinCode":false,"dname":"41abc169-6414-44aa-b62e-5ec4d55ba608","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`## Referencing \\`mutable\\` values\n\n*Mutable values can be referenced either reactively, or non-reactively, as appropriate.* To use the current value of a mutable without creating a dependency, use \\`mutable x\\`; to depend on it for re-evaluation, just use \\`x\\`.\n\nFor example: The blue ball most recently hit the **${wall}** wall.\n\nMutable cells aren’t the default in Observable notebooks, and you probably shouldn’t reach for them as the first tool in your toolbox. But when you have independent looping cells that need to coordinate state, or you have a downstream cell in your notebook that ought to update at a different frequency than its inputs, they can really be quite useful.\n\nAs a final example, here are two cells maintaining internal state while reading from a shared, mutable value:`","pinCode":false,"dname":"b1aa472f-c285-4679-96b7-6583eb7d9c04","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"mutable speed = (0.02)","pinCode":false,"dname":"57004e09-3209-4b4d-a41d-a0732b2bfff6","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"speedControl = {\n  var input = DOM.range(0, 0.1);\n  input.value = mutable speed;\n  input.oninput = () => mutable speed = input.valueAsNumber;\n  return input;\n}","pinCode":false,"dname":"8895ac52-af67-42d9-a6b8-0b824b53e82f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"sinXcosY = {\n  var c = DOM.context2d(w, h);\n  var i = 0;\n  \n  while (true) {\n    i += mutable speed;\n    c.clearRect(0, 0, w, h);\n    c.beginPath();\n    c.fillStyle = \"black\";\n    c.arc(Math.sin(i) * w / 3 + (w / 2), Math.cos(i) * h / 3 + (h / 2), 10, 0, 2 * Math.PI);\n    c.fill();\n    yield c.canvas;\n  }  \n}","pinCode":false,"dname":"284ecfd6-a55e-4127-98d3-31c0d94275e3","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"cosXsinY = {\n  var c = DOM.context2d(w, h);\n  var i = 0;\n  \n  while (true) {\n    i += mutable speed;\n    c.clearRect(0, 0, w, h);\n    c.beginPath();\n    c.fillStyle = \"black\";\n    c.arc(Math.cos(i) * w / 3 + (w / 2), Math.sin(i) * h / 3 + (h / 2), 10, 0, 2 * Math.PI);\n    c.fill();\n    yield c.canvas;\n  }  \n}","pinCode":false,"dname":"aa4822bf-efae-4ab8-b171-589f80459f23","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`*Thanks for the perpetual motion machine, [ClipArt ETC](http://etc.usf.edu/clipart/11300/11348/perpetual_11348.htm).*`","pinCode":false,"dname":"38ab507f-ff53-4f48-ad03-c4fe6d18fa36","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`**Addendum:** For a more complex example of multiple mutable cells controlling a single, complex graphic, see Paul Chaikin’s [Interactive Particle System](https://observablehq.com/@pamacha/interactive-particle-system).`","pinCode":false,"dname":"d00e0f7e-c218-4cf2-8508-00a1593d1921","codeMode":"javascript2"}}}],"version":"2.19.1"}