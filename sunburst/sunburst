{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Partition, Sunburst\n\nThis radial space-filling visualization created by [John Stasko](https://www.cc.gatech.edu/gvu/ii/sunburst/) shows the cumulative values of subtrees. It is commonly used to visualize software packages (the size of source code within nested packages) and file systems (the size of files within nested folders). See also the [zoomable version](/@d3/zoomable-sunburst) and the [icicle diagram](/@d3/icicle?collection=@d3/charts).`","pinCode":false,"dname":"6e72b83e-778c-4655-bcfc-4b9a6bb1b217","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"chart = (Sunburst(flare, {\n  value: d => d.size, // size of each node (file); null for internal nodes (folders)\n  label: d => d.name, // display name for each cell\n  title: (d, n) => `${n.ancestors().reverse().map(d => d.data.name).join(\".\")}\\n${n.value.toLocaleString(\"en\")}`, // hover text\n  link: (d, n) => n.children\n    ? `https://github.com/prefuse/Flare/tree/master/flare/src/${n.ancestors().reverse().map(d => d.data.name).join(\"/\")}`\n    : `https://github.com/prefuse/Flare/blob/master/flare/src/${n.ancestors().reverse().map(d => d.data.name).join(\"/\")}.as`,\n  width: 1152,\n  height: 1152\n}))","pinCode":false,"dname":"b4eafa35-e65e-4923-b84f-e4087109e04a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"flare = (FileAttachment(\"flare.json\").json())","pinCode":false,"dname":"3c60b496-fa08-4140-9ceb-1054c5877a9c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"howto(\"Sunburst\")","pinCode":false,"dname":"37cfbeae-f1a9-45a3-9633-fcd839d0c910","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Sunburst = (function Sunburst(data, { // data is either tabular (array of objects) or hierarchy (nested objects)\n  path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes\n  id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)\n  parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier\n  children, // if hierarchical data, given a d in data, returns its children\n  value, // given a node d, returns a quantitative value (for area encoding; null for count)\n  sort = (a, b) => d3.descending(a.value, b.value), // how to sort nodes prior to layout\n  label, // given a node d, returns the name to display on the rectangle\n  title, // given a node d, returns its hover text\n  link, // given a node d, its link (if any)\n  linkTarget = \"_blank\", // the target attribute for links (if any)\n  width = 640, // outer width, in pixels\n  height = 400, // outer height, in pixels\n  margin = 1, // shorthand for margins\n  marginTop = margin, // top margin, in pixels\n  marginRight = margin, // right margin, in pixels\n  marginBottom = margin, // bottom margin, in pixels\n  marginLeft = margin, // left margin, in pixels\n  padding = 1, // separation between arcs\n  radius = Math.min(width - marginLeft - marginRight, height - marginTop - marginBottom) / 2, // outer radius\n  color = d3.interpolateRainbow, // color scheme, if any\n  fill = \"#ccc\", // fill for arcs (if no color encoding)\n  fillOpacity = 0.6, // fill opacity for arcs\n} = {}) {\n\n  // If id and parentId options are specified, or the path option, use d3.stratify\n  // to convert tabular data to a hierarchy; otherwise we assume that the data is\n  // specified as an object {children} with nested objects (a.k.a. the “flare.json”\n  // format), and use d3.hierarchy.\n  const root = path != null ? d3.stratify().path(path)(data)\n      : id != null || parentId != null ? d3.stratify().id(id).parentId(parentId)(data)\n      : d3.hierarchy(data, children);\n\n  // Compute the values of internal nodes by aggregating from the leaves.\n  value == null ? root.count() : root.sum(d => Math.max(0, value(d)));\n\n  // Sort the leaves (typically by descending value for a pleasing layout).\n  if (sort != null) root.sort(sort);\n\n  // Compute the partition layout. Note polar coordinates: x is angle and y is radius.\n  d3.partition().size([2 * Math.PI, radius])(root);\n\n  // Construct a color scale.\n  if (color != null) {\n    color = d3.scaleSequential([0, root.children.length - 1], color).unknown(fill);\n    root.children.forEach((child, i) => child.index = i);\n  }\n\n  // Construct an arc generator.\n  const arc = d3.arc()\n      .startAngle(d => d.x0)\n      .endAngle(d => d.x1)\n      .padAngle(d => Math.min((d.x1 - d.x0) / 2, 2 * padding / radius))\n      .padRadius(radius / 2)\n      .innerRadius(d => d.y0)\n      .outerRadius(d => d.y1 - padding);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [\n        marginRight - marginLeft - width / 2,\n        marginBottom - marginTop - height / 2,\n        width,\n        height\n      ])\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\")\n      .attr(\"font-family\", \"sans-serif\")\n      .attr(\"font-size\", 10)\n      .attr(\"text-anchor\", \"middle\");\n\n  const cell = svg\n    .selectAll(\"a\")\n    .data(root.descendants())\n    .join(\"a\")\n      .attr(\"xlink:href\", link == null ? null : d => link(d.data, d))\n      .attr(\"target\", link == null ? null : linkTarget);\n\n  cell.append(\"path\")\n      .attr(\"d\", arc)\n      .attr(\"fill\", color ? d => color(d.ancestors().reverse()[1]?.index) : fill)\n      .attr(\"fill-opacity\", fillOpacity);\n\n  if (label != null) cell\n    .filter(d => (d.y0 + d.y1) / 2 * (d.x1 - d.x0) > 10)\n    .append(\"text\")\n      .attr(\"transform\", d => {\n        if (!d.depth) return;\n        const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;\n        const y = (d.y0 + d.y1) / 2;\n        return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;\n      })\n      .attr(\"dy\", \"0.32em\")\n      .text(d => label(d.data, d));\n\n  if (title != null) cell.append(\"title\")\n      .text(d => title(d.data, d));\n\n  return svg.node();\n})","pinCode":false,"dname":"4f4e99fd-7813-4e48-b4a2-d6d8a33ed024","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"import { howto }  from 'sunburst/7a9e12f9fb3d8e06'","pinCode":false,"dname":"149d5412-7de2-45ee-82c6-ae61f2900e52","codeMode":"javascript2"}}}],"version":"2.19.1"}