{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`<div style=\"color: grey; font: 13px/25.5px var(--sans-serif); text-transform: uppercase;\"><h1 style=\"display: none;\">Contours</h1><a href=\"https://d3js.org/\">D3</a> › <a href=\"/@d3/gallery\">Gallery</a></div>\n\n# Contours\n\nShowing the [Goldstein–Price test function](https://en.wikipedia.org/wiki/Test_functions_for_optimization).`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"value = ((x, y) =>\n  (1 + (x + y + 1) ** 2 * (19 - 14 * x + 3 * x ** 2 - 14 * y + 6 * x * y + 3 * y ** 2))\n  * (30 + (2 * x - 3 * y) ** 2 * (18 - 32 * x + 12 * x * x + 48 * y - 36 * x * y + 27 * y ** 2)))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Legend(color, {title: \"Value\", tickFormat: \",\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"chart = {\n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [0, 0, width + 28, height])\n      .style(\"display\", \"block\")\n      .style(\"margin\", \"0 -14px\")\n      .style(\"width\", \"calc(100% + 28px)\");\n\n  svg.append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"#fff\")\n      .attr(\"stroke-opacity\", 0.5)\n    .selectAll(\"path\")\n    .data(contours)\n    .join(\"path\")\n      .attr(\"fill\", d => color(d.value))\n      .attr(\"d\", d3.geoPath());\n\n  svg.append(\"g\")\n      .call(xAxis);\n\n  svg.append(\"g\")\n      .call(yAxis);\n\n  return svg.node();\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"color = (d3.scaleSequentialLog(d3.extent(thresholds), d3.interpolateMagma))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"thresholds = (d3.range(1, 20).map(i => Math.pow(2, i)))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"grid = {\n  const q = 4; // The level of detail, e.g., sample every 4 pixels in x and y.\n  const x0 = -q / 2, x1 = width + 28 + q;\n  const y0 = -q / 2, y1 = height + q;\n  const n = Math.ceil((x1 - x0) / q);\n  const m = Math.ceil((y1 - y0) / q);\n  const grid = new Array(n * m);\n  for (let j = 0; j < m; ++j) {\n    for (let i = 0; i < n; ++i) {\n      grid[j * n + i] = value(x.invert(i * q + x0), y.invert(j * q + y0));\n    }\n  }\n  grid.x = -q;\n  grid.y = -q;\n  grid.k = q;\n  grid.n = n;\n  grid.m = m;\n  return grid;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"transform = (({type, value, coordinates}) => {\n  return {type, value, coordinates: coordinates.map(rings => {\n    return rings.map(points => {\n      return points.map(([x, y]) => ([\n        grid.x + grid.k * x,\n        grid.y + grid.k * y\n      ]));\n    });\n  })};\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"contours = (d3.contours()\n    .size([grid.n, grid.m])\n    .thresholds(thresholds)\n  (grid)\n    .map(transform))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"x = (d3.scaleLinear([-2, 2], [0, width + 28]))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"y = (d3.scaleLinear([-2, 1], [height, 0]))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"xAxis = (g => g\n    .attr(\"transform\", `translate(0,${height})`)\n    .call(d3.axisTop(x).ticks(width / height * 10))\n    .call(g => g.select(\".domain\").remove())\n    .call(g => g.selectAll(\".tick\").filter(d => x.domain().includes(d)).remove()))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"yAxis = (g => g\n    .attr(\"transform\", \"translate(-1,0)\")\n    .call(d3.axisRight(y))\n    .call(g => g.select(\".domain\").remove())\n    .call(g => g.selectAll(\".tick\").filter(d => y.domain().includes(d)).remove()))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"height = (600)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { Legend }  from 'saving-svg/a33468b95d0b15b0'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\nUsing [Observable Plot](/plot/)’s built-in [contour mark](/plot/marks/contour), we can create the same chart in a few lines—or see the [complete example with custom axes](/@observablehq/plot-goldstein-price-contours). Explicit thresholds are necessary due to the skewed distribution of the value.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Plot.plot({\n  color: {scheme: \"Magma\", type: \"log\", legend: true, width: 300, label: \"Value\", tickFormat: \",\"},\n  marks: [\n    Plot.contour({\n      x1: -2,\n      x2: 2,\n      y1: -2,\n      y2: 1,\n      fill: value,\n      stroke: \"#fff\",\n      strokeOpacity: 0.5,\n      thresholds: d3.range(1, 20).map(n => 2 ** n)\n    })\n  ]\n})","pinCode":false}}}],"version":"2.19.1"}