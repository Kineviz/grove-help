{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Sticky Views\n\nLetâ€™s do an experiment. First, pick an even number ${tex`n = ${n1}`} between 0 and 100:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof n1 = (html`<input type=\"range\" min=\"0\" max=\"100\" step=\"2\">`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Now pick a number ${tex`i = ${i1}`} between 0 and ${tex`n_1`}:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof i1 = (html`<input type=\"range\" min=\"0\" max=\"${n1}\" step=\"1\">`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`But what if you change your mind about ${tex`n`}? If you go back and change ${tex`n`}, ${tex`i`} resets to its default value ${tex`n / 2`}. Oops! ðŸ¤” So letâ€™s try again, this time having ${tex`i`} preserve its existing value whenever ${tex`n`} changes.\n\nPick an even number ${tex`n = ${n2}`} between 0 and 100:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof n2 = (html`<input type=\"range\" min=\"0\" max=\"100\" step=\"2\">`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Pick a number ${tex`i = ${i2}`} between 0 and ${tex`n`}:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof i2 = (html`<input type=\"range\" min=\"0\" max=\"${n2}\" step=\"1\" value=\"${this ? this.value : n2 / 2}\">`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Now try changing ${tex`n`}; as long as ${tex`n \\geq i`}, youâ€™ll retain the existing value of ${tex`i`}. Yay! ðŸŽ‰\n\nIn Observable, \\`this\\` is the *previous* value of the current cell. For \\`viewof i2\\` above, \\`this\\` is the HTMLInputElement created previously (with the old value of \\`n2\\`), and \\`this.value\\` is the old inputâ€™s value. Thus, when \\`n2\\` changes and \\`viewof i2\\` is re-evaluated, we can initialize the new HTMLInputElement with the value of the old HTMLInputElement.\n\nWhat about the first time \\`viewof i2\\` runs, and there is no previous value? Then \\`this\\` is undefined, and we initialize the inputâ€™s value to ${tex`n_2 / 2`}. The previous value is also cleared when you edit the cellâ€™s code or rerun using Shift-Enter.\n\nIf you prefer, an alternative approach is to listen explicitly for *input* events on \\`viewof n2\\` instead of referencing \\`n2\\` reactively:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof i3 = {\n  const input = html`<input type=\"range\" min=\"0\" step=\"1\">`;\n  function inputted() { input.max = viewof n2.value; }\n  viewof n2.addEventListener(\"input\", inputted);\n  invalidation.then(() => viewof n2.removeEventListener(\"input\", inputted));\n  inputted();\n  return input;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`But event listeners are cumbersome to manage, requiring [invalidation](/@mbostock/disposing-content). And thatâ€™s why Observable exposes a cellâ€™s previous value as \\`this\\`.\n\nFor more on \\`this\\`, see [Tomâ€™s notebook](/@tmcw/untitled/5).`","pinCode":false}}}],"version":"2.19.1"}