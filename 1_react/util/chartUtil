{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Chart Util`","pinCode":false,"dname":"0719ce1d-a54b-4495-822e-fb5fddb6fef4","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"/** cast data to a type data */\n  function castType(data, type) {\n  let oldType = typeof data;\n  if (oldType === type) {\n    return data;\n  }\n  switch (oldType) {\n    case 'number': {\n      switch (type) {\n        case 'string':\n          return data.toString();\n        case 'date':\n          let date = new Date(data);\n          return isNaN(date) ? data : (date).toISOString();\n        default:\n          break;\n      }\n      break;\n    }\n    case 'string': {\n      switch (type) {\n        case 'date':\n          let date = new Date(data);\n          return isNaN(date) ? data : (date).toISOString();\n        case 'number':\n          return parseFloat(data);\n        default:\n          break;\n      }\n      break;\n    }\n    case 'boolean': {\n      switch (type) {\n        case 'string':\n          return data === true ? \"true\" : \"false\";\n        case 'number':\n          return data === true ? 1 : 0;\n        default:\n          break;\n      }\n      break;\n    }\n    default:\n      return data;\n  }\n  let ret = eval(type)(data);\n  if (typeof ret === 'object') {\n    if (ret instanceof Date) {\n      return ret.toISOString();\n    } else {\n      return ret.toString();\n    }\n  }\n  return ret;\n}\n ","pinCode":false,"dname":"04054115-f8bb-44aa-bf9e-2e6647cd6854","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"chartDataFunc = function (data, selectedProperties, emptyFills = {}, castColumns = {}, joinColumns = {}) {\n    let chartData = selectedProperties.length ? _.reduce(data, (prev, curr, index, list) => {\n        let nobj = _.cloneDeep(curr);\n        let _hasBlank = false;\n        _.each(selectedProperties, (column) => {\n            if (nanOrBlank(nobj[column])) {\n                if (!nanOrBlank(emptyFills[column])) {\n                    nobj[column] = emptyFills[column];//|| nobj[column];\n                } else {\n                    _hasBlank = true;\n                }\n            }\n            if (castColumns && castColumns[column]) {\n                nobj[column] = castType(nobj[column], castColumns[column])\n            }\n        })\n        if (_hasBlank) {\n            ///some data not right\n        }\n        let obj = _.pick(nobj, selectedProperties);\n        joinColumns && _.each(joinColumns, (v, k) => {\n            if (v && (v instanceof Array || window.opener && v instanceof window.opener.Array) && v.length > 0) {\n                obj[k] = _.values(_.pick(nobj, v)).join(groupSeparators[0]);\n            }\n        })\n        if (list.keysArr) {\n            obj.SPECIAL_GRAPHXR_NODE_ID = list.keysArr[index];\n            if (!prev.keysArr) {\n                prev.keysArr = [];\n            }\n            prev.keysArr[prev.keysArr.length] = list.keysArr[index];\n        }\n        obj.SOURCE_CHART_DATA = curr.SOURCE_CHART_DATA || curr;\n        prev.push(obj);\n        return prev;\n    }, []) : [];\n    return autoObjectsType(chartData, false);\n}","pinCode":false,"dname":"8498bccc-de84-4e25-9b81-46156cc6aa0b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"multiColors = [{\n    displayConfig: { type: ShowType.Color },\n    value: \"#5B8FF9\"\n},\n{\n    displayConfig: { type: ShowType.Color },\n    value: \"#5AD8A6\"\n},\n{\n    displayConfig: { type: ShowType.Color },\n    value: \"#5D7092\"\n},\n{\n    displayConfig: { type: ShowType.Color },\n    value: \"#F6BD16\"\n},\n{\n    displayConfig: { type: ShowType.Color },\n    value: \"#E8684A\"\n},]","pinCode":false,"dname":"507452f5-7d1c-405f-8a15-e0b34048866f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"function getRandomColor() {\n    var letters = '0123456789ABCDEF';\n    var color = '#';\n    for (var i = 0; i < 6; i++) {\n        color += letters[Math.floor(Math.random() * 16)];\n    }\n    return color;\n}","pinCode":false,"dname":"26b561e8-1614-4db5-a7e8-fccca9ddcd94","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"getMultiColors = function (num) {\n    for (let i = 0; i < num; i++) {\n        if (!multiColors[i]) {\n            let color = getRandomColor();\n            if (_.filter(multiColors, (multiColor, index) => { return multiColor === color }).length > 0) {\n                i--;\n                continue;\n            }\n            multiColors[i] = {\n                displayConfig: { type: ShowType.Color },\n                value: color\n            }\n        }\n    }\n    return {\n        displayConfig: {\n            type: ShowType.Off, onValue: multiColors.slice(0, num)\n        },\n    }\n}","pinCode":false,"dname":"195bc076-8ebb-4f80-bf4f-b196ebdc2160","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"ortDataTypesFunc = function (first, a, b) {\n    if (typeof first[a] === 'string') {\n        return -1;\n    } else if (typeof first[b] !== 'string') {\n        return 1;\n    }\n    return 0;\n}","pinCode":false,"dname":"17ccb410-3ece-41ce-a392-4faf64c025e7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"ChartTypes = ({\n    \"Base Timeline\": \"Base Timeline\",\n    \"Groups Timeline\": \"Groups Timeline\",\n    \"SubGroups Timeline\": \"SubGroups Timeline\",\n\n    \"Base Range Timeline\": \"Base Range Timeline\",\n    \"Groups Range Timeline\": \"Groups Range Timeline\",\n    \"SubGroups Range Timeline\": \"SubGroups Range Timeline\",\n\n    \"Basic Line\": \"Basic Line\",\n    \"Multi Line\": \"Multi Line\",\n    \"Transpose Multi Line\": \"Transpose Multi Line\",\n\n    \"Basic Column\": \"Basic Column\",\n    \"Multi Column\": \"Multi Column\",\n    \"Transpose Multi Column\": \"Transpose Multi Column\",\n    \"Percentage Stack Column\": \"Percentage Stack Column\",\n    \"Transpose Percentage Stack Column\": \"Transpose Percentage Stack Column\",\n\n    \"Waterfall\": \"Waterfall\",\n    \"Histogram\": \"Histogram\",\n    \"Stack Histogram\": \"Stack Histogram\",\n\n    \"Basic Area\": \"Basic Area\",\n    \"Multi Area\": \"Multi Area\",\n    \"Transpose Multi Area\": \"Transpose Multi Area\",\n    \"Stack Area\": \"Stack Area\",\n    \"Transpose Stack Area\": \"Transpose Stack Area\",\n    \"Percentage Stack Area\": \"Percentage Stack Area\",\n    \"Transpose Percentage Stack Area\": \"Transpose Percentage Stack Area\",\n\n    \"Basic Bar\": \"Basic Bar\",\n    \"Multi Bar\": \"Multi Bar\",\n    \"Transpose Multi Bar\": \"Transpose Multi Bar\",\n    \"Percentage Stack Bar\": \"Percentage Stack Bar\",\n    \"Transpose Percentage Stack Bar\": \"Transpose Percentage Stack Bar\",\n\n    \"Basic Pie\": \"Basic Pie\",\n\n    \"Basic Scatter\": \"Basic Scatter\",\n    \"Multi Scatter\": \"Multi Scatter\",\n    \"Transpose Multi Scatter\": \"Transpose Multi Scatter\",\n\n    \"Basic Bubble\": \"Basic Bubble\",\n    \"Multi Bubble\": \"Multi Bubble\",\n    \"Transpose Multi Bubble\": \"Transpose Multi Bubble\",\n\n    \"Basic Radar\": \"Basic Radar\",\n    \"Multi Radar\": \"Multi Radar\",\n    \"Transpose Multi Radar\": \"Transpose Multi Radar\",\n\n    \"Basic Rose\": \"Basic Rose\",\n    \"Multi Rose\": \"Multi Rose\",\n    \"Transpose Multi Rose\": \"Transpose Multi Rose\",\n\n    \"Continuous Heatmap\": \"Continuous Heatmap\",\n    \"Heatmap\": \"Heatmap\",\n    \"Uneven Heatmap\": \"Uneven Heatmap\",\n\n    \"Basic Word Cloud\": \"Basic Word Cloud\",\n    \"Word Cloud\": \"Word Cloud\",\n\n    // \"Circle Packing\": \"Circle Packing\",\n    // \"Sunburst\": \"Sunburst\",\n\n    \"Liquid\": \"Liquid\",\n})","pinCode":false,"dname":"27e5a0be-b6cd-460a-9533-70d7545b55e7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"getPeriod = function (a, b) {\n    if (typeof a === 'number' && typeof b === 'number') {\n        return a - b;\n    } else if (a instanceof Date && b instanceof Date) {\n        let days = (a - b) / (24 * 3600 * 1000)\n        if (days >= 28 && days <= 31) {\n            return 30;\n        } else if (days >= 365 && days <= 366) {\n            return 365;\n        } else {\n            return days;\n        }\n    } else { return a - b; }\n\n}","pinCode":false,"dname":"a1a4a39f-97ae-4ca1-9a8c-3ff8ab7c3146","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"sortDataTypesFunc = function (first, a, b) {\n    if (typeof first[a] === 'string') {\n        return -1;\n    } else if (typeof first[b] !== 'string') {\n        return 1;\n    }\n    return 0;\n}","pinCode":false,"dname":"92c85bb1-6281-4f78-aa3a-898ea4181a2e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"checkChartTypes = function (data, transpose) {\n    /**\n     * @type {[ChartTypeTemplate]}\n     */\n    const chartTypes = [];\n    if (!data || !data.length) {\n        return chartTypes;\n    }\n    if (data.length === 1) {\n        _.map(data[0], (v, k, obj) => {\n            if (\"SPECIAL_GRAPHXR_NODE_ID\" === k || \"SOURCE_CHART_DATA\" === k) {\n                return;\n            }\n            if (!isNaN(v)) {\n                if (v >= 0 && v <= 100) {\n                    chartTypes.push({\n                        type: ChartTypes['Liquid'],\n                        config: {\n                            percent: v <= 1 ? v : v / 100,\n                            statistic: {\n                                title: {\n                                    content: k,\n                                },\n                            }\n                        },\n                    })\n                }\n                let keys = _.filter(_.keys(obj), (kk, index) => { return k !== kk && \"SPECIAL_GRAPHXR_NODE_ID\" !== kk && \"SOURCE_CHART_DATA\" !== kk });\n                if (keys.length) {\n                    chartTypes.push({\n                        type: ChartTypes['Basic Pie'],\n                        config: {\n                            angleField: k,\n                            colorField: keys[0],\n                        }\n                    })\n                }\n            }\n        })\n        return chartTypes;\n    }\n    /**@type {Array<Object.<string, number|string|Date|boolean|null|NaN>>} */\n    let allData = autoObjectsType(_.cloneDeep(data), true)\n    let first = allData[0];\n    let allKeys = _.keys(first);\n    ~allKeys.indexOf(\"SPECIAL_GRAPHXR_NODE_ID\") && allKeys.splice(allKeys.indexOf(\"SPECIAL_GRAPHXR_NODE_ID\"), 1);\n    ~allKeys.indexOf(\"SOURCE_CHART_DATA\") && allKeys.splice(allKeys.indexOf(\"SOURCE_CHART_DATA\"), 1);\n    let numbers = _.filter(allKeys, (key) => {\n        return typeof first[key] === 'number'\n    });\n    if (allKeys.length === 1 && numbers.length === 1) {\n        chartTypes.push({\n            type: ChartTypes['Histogram'],\n            config: {\n                binField: numbers[0],\n            }\n        })\n    }\n    let strings = _.filter(allKeys, (key) => {\n        return typeof first[key] === 'string'\n    });\n    let twoNumbersTranspose = (anyFieldDateType, anyField, numberFields) => {\n        let sortArr = _.uniq(_.map(allData, (value) => { return value[anyField] }));\n        if (sortArr.length === allData.length) {\n            let types;\n            if (~['date', 'number'].indexOf(anyFieldDateType)) {\n                sortArr.sort((o1, o2) => { return o1 > o2 ? 1 : -1 });\n                let period = getPeriod(sortArr[1], sortArr[0]);\n                if (!isNaN(period)) {\n                    if (_.find(sortArr.slice(1), (value, index, arr) => {\n                        let nPeriod = getPeriod(value, sortArr[index]);\n                        return isNaN(nPeriod) || Math.abs(period - nPeriod) > 0.01;\n                    }) === undefined) {\n                        types = [ChartTypes['Transpose Multi Column'], ChartTypes['Transpose Percentage Stack Column'], ChartTypes['Transpose Multi Bar'], ChartTypes['Transpose Percentage Stack Bar'], ChartTypes['Transpose Multi Line'], ChartTypes['Transpose Multi Area'], ChartTypes['Transpose Stack Area']];\n                    }\n                }\n            } else if ('string' === anyFieldDateType) {\n                types = [ChartTypes['Transpose Multi Column'], ChartTypes['Transpose Percentage Stack Column'], ChartTypes['Transpose Multi Bar'], ChartTypes['Transpose Percentage Stack Bar'], ChartTypes['Transpose Multi Line'], ChartTypes['Transpose Multi Area'], ChartTypes['Transpose Stack Area'], ChartTypes['Transpose Percentage Stack Area'], ChartTypes['Transpose Multi Rose']];\n                if (allData.length >= 3) {\n                    types.push(ChartTypes['Transpose Multi Radar']);\n                }\n            }\n            types && _.each(types, (type) => {\n                if (isBarType(type)) {\n                    chartTypes.push({\n                        type: type,\n                        config: {\n                            yField: anyField,\n                            transposeFields: numberFields\n                        }\n                    })\n                } else {\n                    chartTypes.push({\n                        type: type,\n                        config: {\n                            xField: anyField,\n                            transposeFields: numberFields\n                        }\n                    })\n                }\n            })\n        }\n    }\n    let dates = _.filter(allKeys, (key) => {\n        return typeof first[key] === 'object' && first[key] instanceof Date\n    }).sort((a, b) => { return first[a] - first[b] });\n    if (dates.length == 1) {\n        let fArr = _.filter(allKeys, (v, index) => { return v !== dates[0] }).sort((a, b) => { return sortDataTypesFunc(first, a, b) });\n        if (allKeys.length === 2) {\n            chartTypes.push({\n                type: ChartTypes['Base Timeline'],\n                config: {\n                    startField: dates[0],\n                    contentField: fArr[0],\n                }\n            })\n        } else if (allKeys.length >= 3) {\n            chartTypes.push({\n                type: ChartTypes['Groups Timeline'],\n                config: {\n                    startField: dates[0],\n                    groupField: fArr[0],\n                    contentField: fArr[1],\n                }\n            })\n            chartTypes.push({\n                type: ChartTypes['SubGroups Timeline'],\n                config: {\n                    startField: dates[0],\n                    groupField: fArr[0],\n                    contentField: fArr[1],\n                }\n            })\n        }\n        if (transpose && numbers.length === 2) {\n            twoNumbersTranspose('date', dates[0], numbers)\n        }\n    } else if (dates.length >= 2) {\n        let fArr = _.filter(allKeys, (v, index) => { return v !== dates[0] && v !== dates[1] }).sort((a, b) => { return sortDataTypesFunc(first, a, b) });\n        if (allKeys.length === 3) {\n            chartTypes.push({\n                type: ChartTypes['Base Range Timeline'],\n                config: {\n                    startField: dates[0],\n                    endField: dates[1],\n                    contentField: fArr[0],\n                }\n            })\n        } else if (allKeys.length >= 4) {\n            chartTypes.push({\n                type: ChartTypes['Groups Range Timeline'],\n                config: {\n                    startField: dates[0],\n                    endField: dates[1],\n                    groupField: fArr[0],\n                    contentField: fArr[1],\n                }\n            })\n            chartTypes.push({\n                type: ChartTypes['SubGroups Range Timeline'],\n                config: {\n                    startField: dates[0],\n                    endField: dates[1],\n                    groupField: fArr[0],\n                    contentField: fArr[1],\n                }\n            })\n        }\n    }\n    /**\n     * \n     * @param {*} a yAxis\n     * @param {*} b xAxis\n     * @param {*} allData \n     * @param {*} seriesField \n     */\n    let oneNumberOneTime_or_ordinal = (a, b, allData, seriesField) => {\n        if (!allData || !allData.length || allData.length < 2) {\n            return;\n        }\n        if (typeof first[a] !== 'number') {\n            let tmp = a;\n            a = b;\n            b = tmp;\n        }\n        if (typeof first[a] !== 'number') {\n            return;\n        }\n        let pairs;\n        if (typeof first[a] === 'number' && typeof first[b] === 'number') {\n            pairs = [[a, b], [b, a]];\n        } else {\n            pairs = [[b, a]];\n        }\n        _.each(pairs, (pair, index) => {\n            let xAxis = pair[0], yAxis = pair[1], types;\n            let sortArr = _.uniq(_.map(allData, (value) => { return value[xAxis] }));\n            if (sortArr.length === allData.length) {\n                sortArr.sort((o1, o2) => { return o1 > o2 ? 1 : -1 });\n                let period = getPeriod(sortArr[1], sortArr[0]);\n                if (!isNaN(period)) {\n                    if (_.find(sortArr.slice(1), (value, index, arr) => {\n                        let nPeriod = getPeriod(value, sortArr[index]);\n                        return isNaN(nPeriod) || Math.abs(period - nPeriod) > 0.01;\n                    }) === undefined) {\n                        if (seriesField) {\n                            types = [ChartTypes['Multi Line'], ChartTypes['Multi Area'], ChartTypes['Stack Area'], ChartTypes['Percentage Stack Area'], ChartTypes['Multi Column'], ChartTypes['Percentage Stack Column'], ChartTypes['Multi Bar'], ChartTypes['Percentage Stack Bar'],];\n                        } else {\n                            types = [ChartTypes['Basic Line'], ChartTypes['Basic Area'], ChartTypes['Basic Column'], ChartTypes['Basic Bar']];\n                        }\n                    }\n                } else {\n                    if (seriesField) {\n                        types = [ChartTypes['Multi Column'], ChartTypes['Percentage Stack Column'], ChartTypes['Multi Bar'], ChartTypes['Percentage Stack Bar'], ChartTypes['Multi Line'], ChartTypes['Multi Area'], ChartTypes['Stack Area'], ChartTypes['Percentage Stack Area'], ChartTypes['Multi Rose']];\n                        if (allData.length >= 3) {\n                            types.push(ChartTypes['Multi Radar']);\n                        }\n                    } else {\n                        types = [ChartTypes['Basic Column'], ChartTypes['Waterfall'], ChartTypes['Basic Bar'], ChartTypes['Basic Line'], ChartTypes['Basic Area'], ChartTypes['Basic Pie'], ChartTypes['Basic Rose']];\n                        if (allData.length >= 3) {\n                            types.push(ChartTypes['Basic Radar']);\n                        }\n                    }\n                }\n                _.each(types, (type) => {\n                    if (type === ChartTypes['Basic Pie']) {\n                        chartTypes.push({\n                            type: type,\n                            config: {\n                                angleField: yAxis,\n                                colorField: xAxis,\n                            }\n                        })\n                    } else if (isBarType(type)) {\n                        chartTypes.push({\n                            type: type,\n                            config: {\n                                xField: yAxis,\n                                yField: xAxis,\n                                seriesField,\n                            }\n                        })\n                    } else {\n                        chartTypes.push({\n                            type: type,\n                            config: {\n                                xField: xAxis,\n                                yField: yAxis,\n                                seriesField,\n                            }\n                        })\n                    }\n                })\n            } else if ((allData.length - sortArr.length) / allData.length > 0.8) {\n                chartTypes.push({\n                    type: ChartTypes['Stack Histogram'],\n                    config: {\n                        binField: yAxis,\n                        stackField: xAxis,\n                    }\n                })\n            }\n            if (typeof first[xAxis] === 'string' && (allData.length - sortArr.length) / allData.length < 0.1) {\n                if (seriesField) {\n                    chartTypes.push({\n                        type: ChartTypes['Word Cloud'],\n                        config: {\n                            wordField: xAxis,\n                            weightField: yAxis,\n                            colorField: seriesField,\n                        }\n                    })\n                } else {\n                    chartTypes.push({\n                        type: ChartTypes['Basic Word Cloud'],\n                        config: {\n                            wordField: xAxis,\n                            weightField: yAxis,\n                        }\n                    })\n                }\n            }\n        })\n    }\n    /**\n     * \n     * @param {*} a xAxis\n     * @param {*} b yAxis\n     * @param {*} colorField \n     */\n    let oneNumberOneNumber = (a, b, colorField) => {\n        let xAxis, yAxis, types;\n        if (typeof first[a] === 'number' && typeof first[b] === 'number') {\n            xAxis = a;\n            yAxis = b;\n            if (colorField) {\n                types = [ChartTypes['Multi Scatter']];\n            } else {\n                types = [ChartTypes['Basic Scatter']];\n            }\n            _.each(types, (type) => {\n                chartTypes.push({\n                    type: type,\n                    config: {\n                        xField: xAxis,\n                        yField: yAxis,\n                        colorField\n                    }\n                })\n            })\n        }\n    }\n    if (allKeys.length === 2) {\n        oneNumberOneTime_or_ordinal(allKeys[0], allKeys[1], allData);\n        oneNumberOneNumber(allKeys[0], allKeys[1]);\n    } else if (allKeys.length === 3) {\n        if (numbers.length === 3) {\n            chartTypes.push({\n                type: ChartTypes['Basic Bubble'],\n                config: {\n                    xField: allKeys[0],\n                    yField: allKeys[1],\n                    sizeField: allKeys[2]\n                }\n            })\n            chartTypes.push({\n                type: ChartTypes['Continuous Heatmap'],\n                config: {\n                    xField: allKeys[0],\n                    yField: allKeys[1],\n                    colorField: allKeys[2]\n                }\n            })\n            transpose && _.each(numbers, (numberKey, index) => {\n                let leftTwoKeys = _.filter(allKeys, (value) => { return value !== numberKey });\n                twoNumbersTranspose('number', numberKey, leftTwoKeys);\n            });\n        } else if (numbers.length > 0 && strings.length > 0) {\n            if (numbers.length === 1) {\n                chartTypes.push({\n                    type: ChartTypes['Heatmap'],\n                    config: {\n                        xField: strings[0],\n                        yField: strings[1],\n                        colorField: numbers[0],\n                    }\n                })\n            } else if (transpose && numbers.length === 2) {\n                twoNumbersTranspose('string', strings[0], numbers)\n            }\n            _.each(strings, (maySerkey) => {\n                /**@type {Object<string, Array<Object>>} */\n                let categories = {};\n                _.each(allData, (value) => {\n                    let categoryName = value[maySerkey];\n                    if (categoryName) {\n                        if (!categories[categoryName]) {\n                            categories[categoryName] = [];\n                        }\n                        let obj = _.clone(value);\n                        delete obj[maySerkey];\n                        categories[categoryName].push(obj);\n                    }\n                })\n                let values = _.values(categories);\n                let leftTwoKeys = _.filter(allKeys, (value) => { return value !== maySerkey });\n                oneNumberOneTime_or_ordinal(leftTwoKeys[0], leftTwoKeys[1], values[0], maySerkey);\n                oneNumberOneNumber(leftTwoKeys[0], leftTwoKeys[1], maySerkey);\n            })\n        }\n    } else if (allKeys.length === 4) {\n        if (numbers.length === 3 && strings.length === 1) {\n            let threeNumKeys = _.filter(allKeys, (value) => { return value !== strings[0] });\n            chartTypes.push({\n                type: ChartTypes['Multi Bubble'],\n                config: {\n                    xField: threeNumKeys[0],\n                    yField: threeNumKeys[1],\n                    sizeField: threeNumKeys[2],\n                    colorField: strings[0],\n                }\n            })\n        }\n        if (numbers.length === 2 && strings.length === 2) {\n            chartTypes.push({\n                type: ChartTypes['Uneven Heatmap'],\n                config: {\n                    xField: strings[0],\n                    yField: strings[1],\n                    sizeField: numbers[0],\n                    colorField: numbers[1],\n                }\n            })\n        }\n    }\n    _.each(chartTypes, (chartType) => {\n        let series = chartType.config.colorField || chartType.config.seriesField;\n        if (series && !~chartType.type.indexOf(ChartTypes.Heatmap) || chartType.config.transposeFields?.length) {\n            if (chartType.config.transposeFields?.length) {\n                _.assign(chartType.config, {\n                    color: getMultiColors(chartType.config.transposeFields?.length)\n                })\n            } else {\n                let set = _.reduce(allData, (prev, curr, index) => {\n                    prev.add(curr[series]);\n                    return prev;\n                }, new Set());\n                _.assign(chartType.config, {\n                    color: getMultiColors(set.size)\n                })\n            }\n        }\n    })\n    // console.log(chartTypes);\n    return chartTypes\n}","pinCode":false,"dname":"086a61ff-60e0-4e94-a764-a49b94856e75","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"isBarType = function (type) {\n    return !!~[ChartTypes['Basic Bar'], ChartTypes['Multi Bar'], ChartTypes['Transpose Multi Bar'], ChartTypes['Percentage Stack Bar'], ChartTypes['Transpose Percentage Stack Bar'],].indexOf(type)\n}","pinCode":false,"dname":"c51278bc-f5a0-4eb0-8ebb-ea04b17e7171","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"isRadarRoseType = function (type) {\n    return !!~[ChartTypes['Basic Radar'], ChartTypes['Multi Radar'], ChartTypes['Transpose Multi Radar'], ChartTypes['Basic Rose'], ChartTypes['Multi Rose'], ChartTypes['Transpose Multi Rose']].indexOf(type)\n}","pinCode":true,"dname":"5923ef0f-4947-4482-abfd-21cd809afd0b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"isTimelineType = function (type) {\n    return !!~[ChartTypes['Base Timeline'], ChartTypes['Groups Timeline'], ChartTypes['Groups Range Timeline'], ChartTypes['SubGroups Timeline'], ChartTypes['SubGroups Range Timeline']].indexOf(type)\n}","pinCode":false,"dname":"f9b07b4e-cf37-4630-a588-a9ab57deace9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"extractDatas = function (datas, selectedFields) {\n    return _.reduce(datas, (prev, curr, index, list) => {\n        let obj = selectedFields ? _.pick(curr, selectedFields) : _.clone(curr);\n        if (_.filter(obj, (v, k) => { return nanOrBlank(v) }).length === 0) {\n            if (list.keysArr) {\n                obj.SPECIAL_GRAPHXR_NODE_ID = list.keysArr[index];\n                if (!prev.keysArr) {\n                    prev.keysArr = [];\n                }\n                prev.keysArr[prev.keysArr.length] = list.keysArr[index];\n            }\n            obj.SOURCE_CHART_DATA = curr.SOURCE_CHART_DATA || curr;\n            prev.push(obj);\n        } else {\n            // console.log(obj);\n            ///some data not right //TODO\n        }\n        return prev;\n    }, [])\n}","pinCode":true,"dname":"57de013d-2a10-4897-8c52-d86a8efbadab","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"## Dependencies","pinCode":true,"dname":"f9807a7b-d9b5-4d7d-aea2-c0047f590fcb","codeMode":"markdown"}}},{"type":"codeTool","data":{"codeData":{"value":"import { autoObjectsType, nanOrBlank } from \"https://grove-help.graphxr.com/1_react/util/helper\";","pinCode":true,"dname":"9f2189df-094d-4e5a-b240-0373be1b65a0","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"import { groupSeparators, ShowType } from \"https://grove-help.graphxr.com/1_react/util/chartConfigUtils\";","pinCode":true,"dname":"81b9b906-353f-4531-9079-6d2489207414","codeMode":"javascript2"}}}],"version":"2.19.1"}