{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Treemap, CSV\n\nIntroduced by [Ben Shneiderman](http://www.cs.umd.edu/hcil/treemap-history/), treemaps recursively partition space into rectangles according to each node’s associated value. D3 supports several treemap tiling methods. See also [nested](/@d3/nested-treemap), [zoomable](/@d3/zoomable-treemap) and [animated](/@d3/animated-treemap) treemaps.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof tile = (Inputs.select(\n  new Map([\n    [\"binary\", d3.treemapBinary],\n    [\"squarify\", d3.treemapSquarify],\n    [\"slice-dice\", d3.treemapSliceDice],\n    [\"slice\", d3.treemapSlice],\n    [\"dice\", d3.treemapDice]\n  ]),\n  {label: \"Tiling method\", value: d3.treemapBinary}\n))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"key = (Swatches(chart.scales.color))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"chart = (Treemap(flare, {\n  path: d => d.name.replace(/\\./g, \"/\"), // e.g., \"flare/animate/Easing\"\n  value: d => d?.size, // size of each node (file); null for internal nodes (folders)\n  group: d => d.name.split(\".\")[1], // e.g., \"animate\" in \"flare.animate.Easing\"; for color\n  label: (d, n) => [...d.name.split(\".\").pop().split(/(?=[A-Z][a-z])/g), n.value.toLocaleString(\"en\")].join(\"\\n\"),\n  title: (d, n) => `${d.name}\\n${n.value.toLocaleString(\"en\")}`, // text to show on hover\n  link: (d, n) => `https://github.com/prefuse/Flare/blob/master/flare/src${n.id}.as`,\n  tile, // e.g., d3.treemapBinary; set by input above\n  width: 1152,\n  height: 1152\n}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`This example uses a CSV file to represent the hierarchy as tabular data: each row in the file represents a node in the tree. If a *path* option is specified, the Treemap function can automatically impute the internal (parent) nodes and hence the CSV only needs to include leaves; however, if you use the *id* and *parentId* options instead, then the CSV file must include the internal nodes as well as the leaves. See the [JSON treemap](/@d3/json-treemap) example for using a JSON data source.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"flare = (FileAttachment(\"flare-2.csv\").csv({typed: true}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"howto(\"Treemap\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Treemap = (function Treemap(data, { // data is either tabular (array of objects) or hierarchy (nested objects)\n  path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes\n  id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)\n  parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier\n  children, // if hierarchical data, given a d in data, returns its children\n  value, // given a node d, returns a quantitative value (for area encoding; null for count)\n  sort = (a, b) => d3.descending(a.value, b.value), // how to sort nodes prior to layout\n  label, // given a leaf node d, returns the name to display on the rectangle\n  group, // given a leaf node d, returns a categorical value (for color encoding)\n  title, // given a leaf node d, returns its hover text\n  link, // given a leaf node d, its link (if any)\n  linkTarget = \"_blank\", // the target attribute for links (if any)\n  tile = d3.treemapBinary, // treemap strategy\n  width = 640, // outer width, in pixels\n  height = 400, // outer height, in pixels\n  margin = 0, // shorthand for margins\n  marginTop = margin, // top margin, in pixels\n  marginRight = margin, // right margin, in pixels\n  marginBottom = margin, // bottom margin, in pixels\n  marginLeft = margin, // left margin, in pixels\n  padding = 1, // shorthand for inner and outer padding\n  paddingInner = padding, // to separate a node from its adjacent siblings\n  paddingOuter = padding, // shorthand for top, right, bottom, and left padding\n  paddingTop = paddingOuter, // to separate a node’s top edge from its children\n  paddingRight = paddingOuter, // to separate a node’s right edge from its children\n  paddingBottom = paddingOuter, // to separate a node’s bottom edge from its children\n  paddingLeft = paddingOuter, // to separate a node’s left edge from its children\n  round = true, // whether to round to exact pixels\n  colors = d3.schemeTableau10, // array of colors\n  zDomain, // array of values for the color scale\n  fill = \"#ccc\", // fill for node rects (if no group color encoding)\n  fillOpacity = group == null ? null : 0.6, // fill opacity for node rects\n  stroke, // stroke for node rects\n  strokeWidth, // stroke width for node rects\n  strokeOpacity, // stroke opacity for node rects\n  strokeLinejoin, // stroke line join for node rects\n} = {}) {\n\n  // If id and parentId options are specified, or the path option, use d3.stratify\n  // to convert tabular data to a hierarchy; otherwise we assume that the data is\n  // specified as an object {children} with nested objects (a.k.a. the “flare.json”\n  // format), and use d3.hierarchy.\n  const root = path != null ? d3.stratify().path(path)(data)\n      : id != null || parentId != null ? d3.stratify().id(id).parentId(parentId)(data)\n      : d3.hierarchy(data, children);\n\n  // Compute the values of internal nodes by aggregating from the leaves.\n  value == null ? root.count() : root.sum(d => Math.max(0, value(d)));\n\n  // Prior to sorting, if a group channel is specified, construct an ordinal color scale.\n  const leaves = root.leaves();\n  const G = group == null ? null : leaves.map(d => group(d.data, d));\n  if (zDomain === undefined) zDomain = G;\n  zDomain = new d3.InternSet(zDomain);\n  const color = group == null ? null : d3.scaleOrdinal(zDomain, colors);\n\n  // Compute labels and titles.\n  const L = label == null ? null : leaves.map(d => label(d.data, d));\n  const T = title === undefined ? L : title == null ? null : leaves.map(d => title(d.data, d));\n\n  // Sort the leaves (typically by descending value for a pleasing layout).\n  if (sort != null) root.sort(sort);\n\n  // Compute the treemap layout.\n  d3.treemap()\n      .tile(tile)\n      .size([width - marginLeft - marginRight, height - marginTop - marginBottom])\n      .paddingInner(paddingInner)\n      .paddingTop(paddingTop)\n      .paddingRight(paddingRight)\n      .paddingBottom(paddingBottom)\n      .paddingLeft(paddingLeft)\n      .round(round)\n    (root);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-marginLeft, -marginTop, width, height])\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\")\n      .attr(\"font-family\", \"sans-serif\")\n      .attr(\"font-size\", 10);\n\n  const node = svg.selectAll(\"a\")\n    .data(leaves)\n    .join(\"a\")\n      .attr(\"xlink:href\", link == null ? null : (d, i) => link(d.data, d))\n      .attr(\"target\", link == null ? null : linkTarget)\n      .attr(\"transform\", d => `translate(${d.x0},${d.y0})`);\n\n  node.append(\"rect\")\n      .attr(\"fill\", color ? (d, i) => color(G[i]) : fill)\n      .attr(\"fill-opacity\", fillOpacity)\n      .attr(\"stroke\", stroke)\n      .attr(\"stroke-width\", strokeWidth)\n      .attr(\"stroke-opacity\", strokeOpacity)\n      .attr(\"stroke-linejoin\", strokeLinejoin)\n      .attr(\"width\", d => d.x1 - d.x0)\n      .attr(\"height\", d => d.y1 - d.y0);\n\n  if (T) {\n    node.append(\"title\").text((d, i) => T[i]);\n  }\n\n  if (L) {\n    // A unique identifier for clip paths (to avoid conflicts).\n    const uid = `O-${Math.random().toString(16).slice(2)}`;\n\n    node.append(\"clipPath\")\n       .attr(\"id\", (d, i) => `${uid}-clip-${i}`)\n     .append(\"rect\")\n       .attr(\"width\", d => d.x1 - d.x0)\n       .attr(\"height\", d => d.y1 - d.y0);\n\n    node.append(\"text\")\n        .attr(\"clip-path\", (d, i) => `url(${new URL(`#${uid}-clip-${i}`, location)})`)\n      .selectAll(\"tspan\")\n      .data((d, i) => `${L[i]}`.split(/\\n/g))\n      .join(\"tspan\")\n        .attr(\"x\", 3)\n        .attr(\"y\", (d, i, D) => `${(i === D.length - 1) * 0.3 + 1.1 + i * 0.9}em`)\n        .attr(\"fill-opacity\", (d, i, D) => i === D.length - 1 ? 0.7 : null)\n        .text(d => d);   \n  }\n\n  return Object.assign(svg.node(), {scales: {color}});\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { Swatches }  from 'treemap/a33468b95d0b15b0'","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { howto }  from 'treemap/7a9e12f9fb3d8e06'","pinCode":false}}}],"version":"2.19.1"}