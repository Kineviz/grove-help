{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Comma-Separated Tree\n\nYou’ve heard of [comma-separated values (CSV)](https://en.wikipedia.org/wiki/Comma-separated_values)? Well, a comma-separated tree (CST) is similar, with indentation to determine the hierarchy. This gives you a hierarchical data format with the convenience and readability of CSV!\n\nFor some real-world examples, see [Tree-o-Matic](/@mbostock/tree-o-matic) and [Treemap-o-Matic](/@mbostock/treemap-o-matic).\n\nLet’s try it out:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof source = (editor(`World\n Asia\n  China,1409517397\n  India,1339180127\n  Indonesia,263991379\n  Pakistan,197015955\n  Bangladesh,164669751\n  Japan,127484450\n  Philippines,104918090\n  Vietnam,95540800\n Europe\n  Russia,143989754\n  Germany,82114224\n Americas\n  United States,324459463,#333\n  Brazil,209288278\n  Mexico,129163276\n Africa\n  Nigeria,190886311\n  Ethiopia,104957438\n  Egypt,97553151`))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Each line in the textarea above represents a node in the tree. The depth of the node is determined by the number of leading spaces (the indentation): the root node has depth zero; its direct children have depth one; their children have depth two, and so on. The parent of each node is the closest preceding node with lesser depth.\n\nThe fields associated which each node are separated by commas. In this example, the first field is the *name*, the second field is the (optional) *value*, and the third field is the (optional) *color*. But you can use whatever fields you like in your CST.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cstParseRows(source)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The *cstParseRows* function returns the root *node* for the given *string*. Each *node* is an array of field values, corresponding to the comma-separated values in the input. If the *node* has children, *node*.children is the array of child nodes. If you like, you can specify a *row* function to convert this array of fields for each node into an object.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cstParseRows(source, ([name, value, color = \"#ddd\"]) => ({\n  name, \n  value: value === undefined ? undefined : +value, \n  color\n}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Alternatively, just as with CSV, you can have a header row that specifies the names of the fields you expect on each node.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof sourceWithHeader = (editor(`name,value,color\nWorld\n Asia\n  China,1409517397\n  India,1339180127\n  Indonesia,263991379\n  Pakistan,197015955\n  Bangladesh,164669751\n  Japan,127484450\n  Philippines,104918090\n  Vietnam,95540800\n Europe\n  Russia,143989754\n  Germany,82114224\n Americas\n  United States,324459463,#333\n  Brazil,209288278\n  Mexico,129163276\n Africa\n  Nigeria,190886311\n  Ethiopia,104957438\n  Egypt,97553151`))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cstParse(sourceWithHeader)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`## Handling ambiguity\n\nOne of the trade-offs in this design is to favor a valid representation, even if ambiguous, over syntax errors. (If you prefer more explicit syntax, try a different hierarchical format such as YAML and JSON.) Missing commas or quotes are treated identically to comma-separated values.\n\nFor nonsensical indentation, missing parents are ignored. Below, the children *foo* and *bar* are each indented with two spaces (level 2), but there is no intermediate parent (at level 1) between them and the *root*. Thus, both *foo* and *bar* are treated as direct children of *root*.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof malformed1 = (editor(`root\n  foo\n  bar`))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cstParseRows(malformed1)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`If later a parent is introduced at level 1, such as *baz* below, then an immediately following node at level 2 would be a child of *baz* (like normal), rather than a child of *root* and a sibling of *foo* and *bar*.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof malformed2 = (editor(`root\n  foo\n  bar\n baz\n  quux`))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cstParseRows(malformed2)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Appendix\n\nHere’s the implementation of the parser. It’s available on npm and GitHub as [cstree](https://github.com/mbostock/cstree) under the ISC license.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cstParse = (function cstParse(text, row = object => object) {\n  const lines = text.trim().split(/^/gm);\n  const [columns] = d3.csvParseRows(lines.shift());\n  const object = objectConverter(columns);\n  return cstParseLines(lines, (array, i) => row(object(array), i));\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cstParseRows = (function cstParseRows(text, row = array => array) {\n  return cstParseLines(text.trim().split(/^/gm), row);\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cstParseLines = (function cstParseLines(lines, row) {\n  const parents = [];\n  let index = -1;\n  parents.push({children: []});\n  for (let line of lines) {\n    const depth = line.match(/^\\s*/)[0].length;\n    if (depth === line.length) continue; // Skip empty rows.\n    line = line.slice(depth); // Trim indentation.\n    const value = row(d3.csvParseRows(line)[0], ++index);\n    if (value == null) continue; // Filter.\n    let parent;\n    for (let i = depth; !(parent = parents[i]); --i); // Search for parent.\n    if (!parent.children) parent.children = [];\n    parent.children.push(parents[depth + 1] = value);\n  }\n  return parents[0].children.length === 1 ? parents[0].children[0] : parents[0];\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"objectConverter = (function objectConverter(columns) {\n  return new Function(\"d\", `return {${columns.map((name, i) => {\n    return `${JSON.stringify(name)}: d[${i}]`;\n  }).join()}}`);\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"editor = (function editor(value) {\n  const textarea = document.createElement(\"textarea\");\n  textarea.value = value;\n  textarea.style.display = \"block\";\n  textarea.style.boxSizing = \"border-box\";\n  textarea.style.width = \"calc(100% + 28px)\";\n  textarea.style.font = \"var(--monospace-font, var(--mono_fonts))\";\n  textarea.style.minHeight = \"60px\";\n  textarea.style.border = \"none\";\n  textarea.style.padding = \"4px 10px\";\n  textarea.style.margin = \"0 -14px\";\n  textarea.style.background = \"rgb(247,247,249)\";\n  textarea.style.tabSize = 2;\n  textarea.style.resize = \"none\";\n  textarea.onkeypress = event => {\n    if (event.key !== \"Enter\" || event.shiftKey || event.altKey || event.metaKey || event.ctrlKey) return;\n    let i = textarea.selectionStart;\n    let j = textarea.selectionEnd;\n    let v = textarea.value;\n    if (i === j) {\n      let k = 0;\n      while (i > 0 && v[--i - 1] !== \"\\n\");\n      while (i < j && v[i] === \" \") ++i, ++k;\n      textarea.value = v.substring(0, j) + \"\\n\" + new Array(k + 1).join(\" \") + v.substring(j);\n      textarea.selectionStart = textarea.selectionEnd = j + k + 1;\n      textarea.dispatchEvent(new CustomEvent(\"input\"));\n      event.preventDefault();\n    }\n  };\n  textarea.oninput = () => textarea.style.height = `${textarea.value.match(/^/gm).length * 21 + 8}px`;\n  textarea.oninput();\n  return textarea;\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3 = (require(\"d3-dsv@1\"))","pinCode":false}}}],"version":"2.19.1"}