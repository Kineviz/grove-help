{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Generator Cells, Functions and Objects\n\nGenerators are often used to define dynamic variables in Observable: if a cell includes a yield statement, it can yield a sequence of values over time. And each time it yields a value, any referencing cells are automatically re-evaluated. A cell that yields is called a *generator cell*. `","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"i = {\n  for (let i = 0; i < 1e6; ++i) {\n    yield i;\n  }\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`But generator cells aren’t the only concept related to generators in Observable: you can also use [*generator objects*](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Generator) (or simply, *generators*) as in vanilla JavaScript. And the easiest way to create a generator object is a [*generator function*](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function*):`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"range = (function* range(n) {\n  for (let i = 0; i < n; ++i) {\n    yield i;\n  }\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`A generator function returns a new generator each time you call it. So, to define a generator cell from a generator function, call the generator function to create a generator, and then return it:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let n = 1e6;\n  return range(n);\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Equivalently:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"range(1e6)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Just as a normal function allows you to reuse code across cells, a generator function allows you to reuse generator code. And by working with generators directly, rather than only using generator cells, you can control how you pull values from the generator rather than being limited to one value per animation frame, as the Observable runtime does with a generator cell.\n\nGenerators implement the [iterable protocol](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Iteration_protocols), and JavaScript provides a variety of conveniences for working with iterables, such as the for-of loop. For example, here is how to compute the sum of the integers from 0 to 999:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let sum = 0;\n  for (const i of range(1e3)) {\n    sum += i;\n  }\n  return sum;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can also create a generator cell from a generator by yielding. For example, this cell shows the number of seconds that have elapsed since the page loaded:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  for (const i of range(Infinity)) {\n    yield Promises.tick(1000, i + 1);\n  }\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can create an array from an iterable using [spread syntax](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Spread_syntax):`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"[...range(1e3)]","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Some constructors, such as typed arrays and sets, also accept iterables:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"new Float32Array(range(1e3))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"new Set(range(1e3))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Generators can also be infinite! Just be careful you don’t go into an infinite loop when reading values from them. (Generator cells can be infinite because Observable automatically terminates them when the cell is re-evaluated, and only pulls a single value per animation frame.)`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"oscillator = (function* oscillator(period) {\n  while (true) {\n    yield Math.sin(Date.now() / period);\n  }\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Here’s a little oscillating circle—breathe in, breathe out…`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  for (const t of oscillator(1000)) {\n    yield html`<svg viewBox=\"0 0 12 12\" width=128 height=128>\n  <circle stroke=black stroke-width=${1.5 + t} fill=none cx=6 cy=6 r=${3.5 + t}></circle>\n</svg>`;\n  }\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`To summarize: a *generator* defines a sequence of values, a *generator function* returns a new generator, and a *generator cell* defines a value that changes over time in an Observable notebook.`","pinCode":false}}}],"version":"2.19.1"}