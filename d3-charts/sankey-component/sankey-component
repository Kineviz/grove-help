{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Sankey diagram component\n\nThis diagram show how energy is converted or transmitted before being consumed or lost: *supplies* are on the left, and *demands* are on the right. Data: [Department of Energy & Climate Change](http://www.decc.gov.uk/en/content/cms/tackling/2050/calculator_on/calculator_on.aspx) via [Tom Counsell](https://tamc.github.io/Sankey/)`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof linkColor = (Inputs.select(new Map([\n  [\"static\", \"#aaa\"],\n  [\"source-target\", \"source-target\"],\n  [\"source\", \"source\"],\n  [\"target\", \"target\"],\n]), {\n  value: new URLSearchParams(html`<a href>`.search).get(\"color\") || \"source-target\",\n  label: \"Link color\"\n}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof nodeAlign = (Inputs.select([\"left\", \"right\", \"center\", \"justify\"], {\n  value: \"justify\",\n  label: \"Node alignment\"\n}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"chart = (SankeyChart({\n  links: energy\n}, {\n  nodeGroup: d => d.id.split(/\\W/)[0], // take first word for color\n  nodeAlign, // e.g., d3.sankeyJustify; set by input above\n  linkColor, // e.g., \"source\" or \"target\"; set by input above\n  format: (f => d => `${f(d)} TWh`)(d3.format(\",.1~f\")),\n  width,\n  height: 600\n}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"energy = (FileAttachment(\"energy.csv\").csv({typed: true}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"howto(\"SankeyChart\", {imports: {d3: \"d3\", d3Sankey: \"d3-sankey\"}, alternatives: `[Sankey diagram example](/@d3/sankey/2?intent=fork)`})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"SankeyChart = (function SankeyChart({\n  nodes, // an iterable of node objects (typically [{id}, …]); implied by links if missing\n  links // an iterable of link objects (typically [{source, target}, …])\n}, {\n  format = \",\", // a function or format specifier for values in titles\n  align = \"justify\", // convenience shorthand for nodeAlign\n  nodeId = d => d.id, // given d in nodes, returns a unique identifier (string)\n  nodeGroup, // given d in nodes, returns an (ordinal) value for color\n  nodeGroups, // an array of ordinal values representing the node groups\n  nodeLabel, // given d in (computed) nodes, text to label the associated rect\n  nodeTitle = d => `${d.id}\\n${format(d.value)}`, // given d in (computed) nodes, hover text\n  nodeAlign = align, // Sankey node alignment strategy: left, right, justify, center\n  nodeSort, // comparator function to order nodes\n  nodeWidth = 15, // width of node rects\n  nodePadding = 10, // vertical separation between adjacent nodes\n  nodeLabelPadding = 6, // horizontal separation between node and label\n  nodeStroke = \"currentColor\", // stroke around node rects\n  nodeStrokeWidth, // width of stroke around node rects, in pixels\n  nodeStrokeOpacity, // opacity of stroke around node rects\n  nodeStrokeLinejoin, // line join for stroke around node rects\n  linkSource = ({source}) => source, // given d in links, returns a node identifier string\n  linkTarget = ({target}) => target, // given d in links, returns a node identifier string\n  linkValue = ({value}) => value, // given d in links, returns the quantitative value\n  linkPath = d3Sankey.sankeyLinkHorizontal(), // given d in (computed) links, returns the SVG path\n  linkTitle = d => `${d.source.id} → ${d.target.id}\\n${format(d.value)}`, // given d in (computed) links\n  linkColor = \"source-target\", // source, target, source-target, or static color\n  linkStrokeOpacity = 0.5, // link stroke opacity\n  linkMixBlendMode = \"multiply\", // link blending mode\n  colors = d3.schemeTableau10, // array of colors\n  width = 640, // outer width, in pixels\n  height = 400, // outer height, in pixels\n  marginTop = 5, // top margin, in pixels\n  marginRight = 1, // right margin, in pixels\n  marginBottom = 5, // bottom margin, in pixels\n  marginLeft = 1, // left margin, in pixels\n} = {}) {\n  // Convert nodeAlign from a name to a function (since d3-sankey is not part of core d3).\n  if (typeof nodeAlign !== \"function\") nodeAlign = {\n    left: d3Sankey.sankeyLeft,\n    right: d3Sankey.sankeyRight,\n    center: d3Sankey.sankeyCenter\n  }[nodeAlign] ?? d3Sankey.sankeyJustify;\n\n  // Compute values.\n  const LS = d3.map(links, linkSource).map(intern);\n  const LT = d3.map(links, linkTarget).map(intern);\n  const LV = d3.map(links, linkValue);\n  if (nodes === undefined) nodes = Array.from(d3.union(LS, LT), id => ({id}));\n  const N = d3.map(nodes, nodeId).map(intern);\n  const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);\n\n  // Replace the input nodes and links with mutable objects for the simulation.\n  nodes = d3.map(nodes, (_, i) => ({id: N[i]}));\n  links = d3.map(links, (_, i) => ({source: LS[i], target: LT[i], value: LV[i]}));\n\n  // Ignore a group-based linkColor option if no groups are specified.\n  if (!G && [\"source\", \"target\", \"source-target\"].includes(linkColor)) linkColor = \"currentColor\";\n\n  // Compute default domains.\n  if (G && nodeGroups === undefined) nodeGroups = G;\n\n  // Construct the scales.\n  const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);\n\n  // Compute the Sankey layout.\n  d3Sankey.sankey()\n      .nodeId(({index: i}) => N[i])\n      .nodeAlign(nodeAlign)\n      .nodeWidth(nodeWidth)\n      .nodePadding(nodePadding)\n      .nodeSort(nodeSort)\n      .extent([[marginLeft, marginTop], [width - marginRight, height - marginBottom]])\n    ({nodes, links});\n\n  // Compute titles and labels using layout nodes, so as to access aggregate values.\n  if (typeof format !== \"function\") format = d3.format(format);\n  const Tl = nodeLabel === undefined ? N : nodeLabel == null ? null : d3.map(nodes, nodeLabel);\n  const Tt = nodeTitle == null ? null : d3.map(nodes, nodeTitle);\n  const Lt = linkTitle == null ? null : d3.map(links, linkTitle);\n\n  // A unique identifier for clip paths (to avoid conflicts).\n  const uid = `O-${Math.random().toString(16).slice(2)}`;\n\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  const node = svg.append(\"g\")\n      .attr(\"stroke\", nodeStroke)\n      .attr(\"stroke-width\", nodeStrokeWidth)\n      .attr(\"stroke-opacity\", nodeStrokeOpacity)\n      .attr(\"stroke-linejoin\", nodeStrokeLinejoin)\n    .selectAll(\"rect\")\n    .data(nodes)\n    .join(\"rect\")\n      .attr(\"x\", d => d.x0)\n      .attr(\"y\", d => d.y0)\n      .attr(\"height\", d => d.y1 - d.y0)\n      .attr(\"width\", d => d.x1 - d.x0);\n\n  if (G) node.attr(\"fill\", ({index: i}) => color(G[i]));\n  if (Tt) node.append(\"title\").text(({index: i}) => Tt[i]);\n\n  const link = svg.append(\"g\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke-opacity\", linkStrokeOpacity)\n    .selectAll(\"g\")\n    .data(links)\n    .join(\"g\")\n      .style(\"mix-blend-mode\", linkMixBlendMode);\n\n  if (linkColor === \"source-target\") link.append(\"linearGradient\")\n      .attr(\"id\", d => `${uid}-link-${d.index}`)\n      .attr(\"gradientUnits\", \"userSpaceOnUse\")\n      .attr(\"x1\", d => d.source.x1)\n      .attr(\"x2\", d => d.target.x0)\n      .call(gradient => gradient.append(\"stop\")\n          .attr(\"offset\", \"0%\")\n          .attr(\"stop-color\", ({source: {index: i}}) => color(G[i])))\n      .call(gradient => gradient.append(\"stop\")\n          .attr(\"offset\", \"100%\")\n          .attr(\"stop-color\", ({target: {index: i}}) => color(G[i])));\n\n  link.append(\"path\")\n      .attr(\"d\", linkPath)\n      .attr(\"stroke\", linkColor === \"source-target\" ? ({index: i}) => `url(#${uid}-link-${i})`\n          : linkColor === \"source\" ? ({source: {index: i}}) => color(G[i])\n          : linkColor === \"target\" ? ({target: {index: i}}) => color(G[i])\n          : linkColor)\n      .attr(\"stroke-width\", ({width}) => Math.max(1, width))\n      .call(Lt ? path => path.append(\"title\").text(({index: i}) => Lt[i]) : () => {});\n\n  if (Tl) svg.append(\"g\")\n      .attr(\"font-family\", \"sans-serif\")\n      .attr(\"font-size\", 10)\n    .selectAll(\"text\")\n    .data(nodes)\n    .join(\"text\")\n      .attr(\"x\", d => d.x0 < width / 2 ? d.x1 + nodeLabelPadding : d.x0 - nodeLabelPadding)\n      .attr(\"y\", d => (d.y1 + d.y0) / 2)\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"text-anchor\", d => d.x0 < width / 2 ? \"start\" : \"end\")\n      .text(({index: i}) => Tl[i]);\n\n  function intern(value) {\n    return value !== null && typeof value === \"object\" ? value.valueOf() : value;\n  }\n\n  return Object.assign(svg.node(), {scales: {color}});\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`d3-sankey is not part of core D3; it must be loaded separately. Here we’re using [require](/@observablehq/require) to load it, while also ensuring that its dependencies on d3-array and d3-shape resolve to the copy of D3 that we’re using elsewhere in this notebook. We don’t want to load multiple copies of these libraries!`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3Sankey = (require.alias({\"d3-array\": d3, \"d3-shape\": d3, \"d3-sankey\": \"d3-sankey@0.12.3/dist/d3-sankey.min.js\"})(\"d3-sankey\"))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { howto }  from 'd3-charts/sankey-component/7a9e12f9fb3d8e06'","pinCode":false}}}],"version":"2.19.1"}