{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`<h1 style=\"display: none;\">Observable TimeChart</h1>\n\n# TimeChart\n\nTimeChart is an importable component for visualizing time-series data. It can show many signals time-aligned as space-efficient horizon charts. If you hover over a chart, all charts on the page show the value at that time, aiding interpretation.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeAxis({interval, start, stop})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof blues = (TimeChart(wave({max: 100, round: true}), {title: \"Blues\", interval, start, stop, max: 100, scheme: \"blues\", marginTop: -16}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof greens = (TimeChart(add(wave({max: 100, round: true, shift: 50, pow: 20}), wave({max: 20, round: true, period: 12})), {title: \"Greens\", interval, start, stop, max: 120, scheme: \"greens\", marginTop: -16}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof reds = (TimeChart(add(blues, greens), {title: \"Reds\", interval, start, stop, max: 130, scheme: \"reds\", marginTop: -16}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`To use in your notebook:\n\n~~~js\nimport {TimeChart, TimeAxis} from \"@observablehq/timechart\"\n~~~\n\nThen, call TimeChart and TimeAxis to create charts as described below.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Configuration\n\nTimeChart expects a consistent *x*-axis across plots so that you can see coincident patterns. TimeChart also expects exactly one data point per pixel to maximize data density. When you call TimeChart and TimeAxis, you pass in these options.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"interval = (d3.utcMinute.every(10))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"stop = (interval())","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"start = (interval.offset(stop, -width))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`TimeChart expects *interval* to be specified as a [d3-time interval](https://github.com/d3/d3-time), though you can also use a named time interval such as “hour” or “minute” if you prefer.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Example usage\n\nFirst we need data: an array of {*date*, *value*} objects at the expected time interval, such as hourly. TimeChart treats missing data as having zero value. We’ll use fake data here (a sine wave with random noise). You’ll want to replace this fake data with a [database client](/@observablehq/databases) or by fetching from an API.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"signups = (wave({min: 0, max: 200, period: 120, round: true}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Next we need an axis. This is a separate component so that it needn’t be repeated for each chart. Sprinkle as many as you like throughout your notebook.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeAxis({interval, start, stop})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Lastly, a chart! TimeChart takes two arguments, *data* and *options*. The *data* an array of {*date*, *value*} objects, as shown above. Three options are required, and below we pass in the corresponding cells of the same name we defined above:\n\n* *interval* - the time interval of the data (*e.g.*, hourly)\n* *start* - the start time of the chart (inclusive)\n* *stop* - the stop time of the chart (exclusive)\n\nIn addition, we recommend:\n\n* *title* - so that people know what they’re looking at\n* *max* - the maximum expected *y*-value, for consistency over time`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(signups, {interval, start, stop, title: \"Sign-ups\", max: 240})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`TimeChart generates a [horizon chart](/@d3/horizon-chart) with four bands by default. You can change the number of bands as desired. A single band will produce a conventional area chart.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(signups, {interval, start, stop, title: \"Sign-ups\", max: 240, bands: 1})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The *scheme* option, which defaults to RdGy—red for negative, gray for positive—controls which colors are used for the bands. All ColorBrewer sequential and diverging color schemes are supported; see [D3 Color Schemes](/@d3/color-schemes). You may also pass in an array of arrays as the *scheme* argument following the same structure as D3 (*e.g.*, d3.schemeBlues).`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(signups, {interval, start, stop, title: \"Sign-ups\", max: 240, scheme: \"PuRd\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Advanced usage: negative values\n\nIf the data includes negative values, these values will by default hang down from the top of the chart in red.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(posneg, {interval, start, stop})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Plotting negative values is also useful for paired signals, for example incoming (positive) and outgoing (negative) traffic volume to a network switch. Set the *marginTop* option to -16 to remove the gap between cells.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(wave({min: 0, max: 1}), {title: \"Incoming\", interval, start, stop, max: 1, format: \"+.2f\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(wave({min: 0, max: -1}), {title: \"Outgoing\", interval, start, stop, max: 1, marginTop: -16, format: \"+.2f\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The *mode* option changes the behavior of the horizon chart for negative values. The allowed values are:\n\n* *offset* - negative values to hang down from the top\n* *mirror* - reflect so that negative values grow up from the bottom\n\nThe default *offset* mode is preferred for accessibility, as *mirror* relys solely on hue to distinguish between positive and negative values. To better show the two modes, below are single-band charts without random noise.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(wave({min: -1, max: 1, noise: 0}), {interval, start, stop, bands: 1, mode: \"offset\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(wave({min: -1, max: 1, noise: 0}), {interval, start, stop, bands: 1, mode: \"mirror\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You should choose a diverging color scheme when plotting negative values: BrBG, PRGn, PiYG, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, or Spectral. If you specify a sequential color scheme (such as blues), negative values will be drawn in gray.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(posneg, {interval, start, stop, scheme: \"piyg\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(posneg, {interval, start, stop, scheme: \"rdbu\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart(posneg, {interval, start, stop, scheme: \"blues\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"posneg = (wave({min: -1, max: 1}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Advanced usage: custom defaults\n\nThe TimeChart.defaults function returns a TimeChart-like function that has the specified options as defaults. This is useful to avoid repeating options that should by shared by all charts on the page, such as *interval*, *start*, and *stop*. You can also change the default color scheme.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"timeChart = (TimeChart.defaults({interval, start, stop, scheme: \"purples\"}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"timeAxis = (TimeAxis.defaults({interval, start, stop}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"timeAxis()","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"timeChart(signups, {title: \"Sign-ups\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Advanced usage: onclick\n\nThe *onclick* option takes a function to be called when the user clicks on the chart. You can use this, for example, to open another notebook or to drive something else on the page (say with a mutable). Call this.invert(*event*) to have TimeChart lookup the data that was clicked on.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"timeChart(signups, {\n  title: \"Sign-ups\", \n  onclick(event) {\n    const {date} = this.invert(event);\n    open(`/d/e817ba556034bba5?date=${date.toISOString()}`, `target=_blank`);\n  }\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Advanced usage: views\n\nTimeChart is compatible with Observable’s viewof operator. The value of the chart is the data you pass in.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof florps = (timeChart(wave(), {title: \"Florps\"}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"florps","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Advanced usage: multiple charts in one cell\n\nTypically each chart goes in its own cell for ease of ordering and commenting. But if desired you can combine multiple charts and an axis in a cell as shown below.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"html`${timeAxis()}${[wave(), wave()].map((data, i) => timeChart(data, {title: `wave ${i}`}))}`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Implementation`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeChart = {\n  let clientX = document.body.clientWidth + 14;\n\n  function TimeChart(data, options = {}) {\n\n    // If data is a promise, render nothing, then replace it with the actual chart later.\n    if (typeof data.then === \"function\") {\n      const chart = TimeChart([], options);\n      Promise.resolve(data).then((data) => chart.replaceWith(TimeChart(data, options)));\n      return chart;\n    }\n\n    // Extract option.s\n    let {\n      interval,\n      max = d3.quantile(data, 0.99, d => Math.abs(d.value) || NaN) || 1,\n      label, // alias for title\n      title = label,\n      locale = \"en-US\",\n      dateFormat = localeFormat(locale),\n      format = localeFormat(locale),\n      marginTop = 0, // try -16 to remove the gap between cells\n      marginLeft = 0,\n      marginRight = 0,\n      height = 49, // inclusive of margin\n      width,\n      stop,\n      start,\n      bands = 4,\n      onclick,\n      curve = d3.curveStepBefore,\n      scheme = d3.schemeRdGy,\n      mode = \"offset\"\n    } = options;\n  \n    // Normalize string arguments\n    if (typeof format === \"string\") format = d3.format(format);\n    else if (typeof format !== \"function\") format = localeFormat(locale, format);\n    if (typeof dateFormat === \"string\") dateFormat = d3.utcFormat(dateFormat);\n    else if (typeof dateFormat !== \"function\") dateFormat = localeFormat(locale, dateFormat);\n    interval = maybeInterval(interval);\n    curve = maybeCurve(curve);\n    scheme = maybeScheme(scheme);\n    mode = maybeMode(mode);\n    bands = Math.floor(bands);\n    if (!(bands >= 1 && bands < scheme.length)) throw new Error(`invalid bands: ${bands}`);\n    if (stop === undefined) stop = interval();\n    if (start === undefined) start = interval.offset(stop, -width);\n    \n    // Normalize the color scheme\n    let colors;\n    if (scheme.length < 11) { // assume sequential, pad with greys\n      colors = scheme[Math.max(3, bands)];\n      if (bands < 3) colors = colors.slice(3 - bands).concat(new Array(3 - bands));\n      colors = [...d3.reverse(d3.schemeGreys[colors.length]), undefined, ...colors];\n    } else { // otherwise assume diverging\n      colors = scheme[Math.max(3, 2 * bands + 1)];\n    }\n\n    // Normalize the data to the given interval, filling in any missing data with zeroes.\n    const values = new Map(data.map(d => [+d.date, +d.value]));\n    const [ymin, ymax] = d3.extent(values, ([, value]) => value);\n    data = interval.range(start, stop).map(date => ({date, value: values.get(+date) || 0}));\n    if (width === undefined) width = data.length;\n\n    const x = d3.scaleUtc([start, stop], [marginLeft, width - marginRight]);\n    const y = d3.scaleLinear([0, max], [0, -bands * height]);\n    const clip = DOM.uid(\"clip\");\n    const path = DOM.uid(\"path\");\n\n    const svg = d3.create(\"svg\")\n        .attr(\"viewBox\", `0 ${-marginTop} ${width} ${height}`)\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .property(\"style\", `\n          display: block;\n          font: 12px var(--sans-serif, system-ui, sans-serif);\n          font-variant-numeric: tabular-nums;\n          margin: 0 0 ${+marginTop}px calc(100% - ${width}px);\n          overflow: visible;\n        `);\n\n    const tooltip = svg.append(\"title\");\n\n    svg.append(\"clipPath\")\n        .attr(\"id\", clip.id)\n      .append(\"rect\")\n        .attr(\"y\", 0)\n        .attr(\"width\", width)\n        .attr(\"height\", height);\n\n    svg.append(\"defs\").append(\"path\")\n        .attr(\"id\", path.id)\n        .attr(\"d\", d3.area()\n            .curve(curve)\n            .defined(d => !isNaN(d.value))\n            .x(d => round(x(d.date)))\n            .y0(0)\n            .y1(d => round(y(d.value)))\n          (data));\n\n    const g = svg.append(\"g\")\n        .attr(\"clip-path\", clip);\n\n    g.append(\"g\")\n      .selectAll(\"use\")\n      .data(d3.range(bands)\n        .map(i => [i, colors[i + 1 + (colors.length >> 1)]])\n        .filter(([i, color]) => color != null && ymax > max * i / bands))\n      .join(\"use\")\n        .attr(\"fill\", ([, color]) => color)\n        .attr(\"transform\", ([i]) => `translate(0,${(i + 1) * height})`)\n        .attr(\"xlink:href\", path.href);\n\n    g.append(\"g\")\n      .selectAll(\"use\")\n      .data(d3.range(bands)\n        .map(i => [i, colors[(colors.length >> 1) - 1 - i]])\n        .filter(([i, color]) => color != null && -ymin > max * i / bands))\n      .join(\"use\")\n        .attr(\"fill\", ([, color]) => color)\n        .attr(\"transform\", mode === \"mirror\"\n            ? ([i]) => `translate(0,${(i + 1) * height}) scale(1,-1)`\n            : ([i]) => `translate(0,${-i * height})`)\n        .attr(\"xlink:href\", path.href);\n\n    const overlay = svg.append(\"g\");\n\n    if (title != null) overlay.append(\"text\")\n        .attr(\"class\", \"title\")\n        .attr(\"font-weight\", \"bold\")\n        .attr(\"stroke-linecap\", \"round\")\n        .attr(\"stroke-linejoin\", \"round\")\n        .attr(\"y\", 2 * 16)\n        .attr(\"dy\", \"0.32em\")\n        .text(title + \"\");\n\n    overlay.append(\"text\")\n        .attr(\"class\", \"label\")\n        .attr(\"stroke-linecap\", \"round\")\n        .attr(\"stroke-linejoin\", \"round\")\n        .attr(\"text-anchor\", \"end\")\n        .attr(\"y\", height - 16 - 1)\n        .attr(\"dx\", -3)\n        .attr(\"dy\", \"0.32em\");\n\n    overlay.selectAll(\"text\")\n      .select(function() {\n        const clone = this.cloneNode(true);\n        return this.parentNode.insertBefore(clone, this);\n      })\n        .attr(\"fill\", \"none\")\n        .attr(\"stroke\", \"white\")\n        .attr(\"stroke-width\", 4);\n\n    overlay.append(\"line\")\n        .attr(\"class\", \"line\")\n        .attr(\"stroke\", \"white\")\n        .attr(\"stroke-dasharray\", \"1,1\")\n        .style(\"mix-blend-mode\", \"screen\")\n        .attr(\"y1\", 0)\n        .attr(\"y2\", height);\n\n    overlay.select(\"line\").clone(true)\n        .attr(\"stroke\", \"black\")\n        .attr(\"stroke-dashoffset\", 1);\n\n    const overlayLine = overlay.selectAll(\".line\");\n    const overlayLabel = overlay.selectAll(\".label\");\n    const overlayText = overlay.selectAll(\".title\");\n\n    function invert(event) {\n      const [mx] = d3.pointer(event, svg.node());\n      const i = d3.bisector(d => d.date).left(data, x.invert(mx), 0, data.length - 1);\n      return data[i];\n    }\n\n    function mousemoved(event) {\n      clientX = event.clientX;\n      const d = invert(event);\n      overlayLabel.attr(\"x\", x(d.date)).text(format(d.value));\n      overlayLine.attr(\"x1\", x(d.date) - 0.5).attr(\"x2\", x(d.date) - 0.5);\n      tooltip.text(dateFormat(d.date));\n    }\n\n    function resized() {\n      overlayText.attr(\"x\", Math.max(0, width - document.body.clientWidth) + 4);\n    }\n\n    resized();\n    addEventListener(\"resize\", resized);\n    addEventListener(\"mousemove\", mousemoved);\n    requestAnimationFrame(() => mousemoved({clientX, clientY: 0}));\n\n    Inputs.disposal(svg.node()).then(() => {\n      removeEventListener(\"resize\", resized);\n      removeEventListener(\"mousemove\", mousemoved);\n    });\n\n    return Object.assign(svg.node(), {onclick, value: data, invert});\n  }\n\n  TimeChart.defaults = defaults => {\n    return (data, options) => {\n      return TimeChart(data, {...defaults, ...options});\n    };\n  };\n\n  return TimeChart;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"TimeAxis = {\n  function TimeAxis({\n    interval,\n    width,\n    height = 33,\n    marginLeft = 0,\n    marginRight = 0,\n    stop,\n    start,\n  } = {}) {\n    interval = maybeInterval(interval);\n    if (stop === undefined) stop = interval();\n    if (start === undefined) start = interval.offset(stop, -width);\n    if (width === undefined) width = interval.range(start, stop).length;\n    return html`<svg viewBox=\"0 0 ${width} ${height}\" width=${width} height=${height} style=\"display: block; margin-left: calc(100% - ${width}px);\">\n    ${d3.create(\"svg:g\")\n        .call(d3.axisTop(d3.scaleTime([start, stop], [marginLeft, width - marginRight])).ticks(width / 120))\n        .call(g => g.select(\".domain\").remove())\n        .call(g => g.selectAll(\".tick line\").clone(true).attr(\"y2\", \"100vh\").attr(\"stroke-opacity\", 0.12))\n        .attr(\"transform\", `translate(0, 33)`)\n      .node()}\n  </svg>`;\n  }\n\n  TimeAxis.defaults = defaults => {\n    return options => {\n      return TimeAxis({...defaults, ...options});\n    };\n  };\n\n  return TimeAxis;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"round = (function round(x) {\n  return Math.round(x * 2) / 2;\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"maybeInterval = (function maybeInterval(interval) {\n  if (interval == null) throw new Error(\"missing interval\");\n  if (!(interval && typeof interval.range === \"function\")) {\n    const i = (interval + \"\").toLowerCase();\n    switch (i) {\n      case \"millisecond\":\n      case \"second\":\n      case \"minute\":\n      case \"hour\":\n      case \"day\":\n      case \"week\":\n      case \"sunday\":\n      case \"monday\":\n      case \"tuesday\":\n      case \"wednesday\":\n      case \"thursday\":\n      case \"friday\":\n      case \"saturday\":\n      case \"month\":\n      case \"year\":\n        return d3[`utc${camelize(i)}`];\n    }\n    throw new Error(`invalid interval: ${interval}`);\n  }\n  return interval;  \n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"maybeCurve = (function maybeCurve(curve) {\n  if (curve == null) throw new Error(\"missing curve\");\n  if (typeof curve !== \"function\") {\n    const c = d3[`curve${camelize(curve)}`];\n    if (c === undefined) throw new Error(`unknown curve: ${curve}`);\n    curve = c;\n  }\n  return curve;\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"maybeScheme = (function maybeScheme(scheme) {\n  if (scheme == null) throw new Error(\"missing scheme\");\n  if (!Array.isArray(scheme)) {\n    const s = (scheme + \"\").toLowerCase();\n    switch (s) {\n      case \"brbg\": return d3.schemeBrBG;\n      case \"prgn\": return d3.schemePRGn;\n      case \"piyg\": return d3.schemePiYG;\n      case \"puor\": return d3.schemePuOr;\n      case \"rdbu\": return d3.schemeRdBu;\n      case \"rdgy\": return d3.schemeRdGy;\n      case \"rdylbu\": return d3.schemeRdYlBu;\n      case \"rdylgn\": return d3.schemeRdYlGn;\n      case \"spectral\": return d3.schemeSpectral;\n      case \"blues\": return d3.schemeBlues;\n      case \"greens\": return d3.schemeGreens;\n      case \"greys\": return d3.schemeGreys;\n      case \"oranges\": return d3.schemeOranges;\n      case \"purples\": return d3.schemePurples;\n      case \"reds\": return d3.schemeReds;\n      case \"bugn\": return d3.schemeBuGn;\n      case \"bupu\": return d3.schemeBuPu;\n      case \"gnbu\": return d3.schemeGnBu;\n      case \"orrd\": return d3.schemeOrRd;\n      case \"pubu\": return d3.schemePuBu;\n      case \"pubugn\": return d3.schemePuBuGn;\n      case \"purd\": return d3.schemePuRd;\n      case \"rdpu\": return d3.schemeRdPu;\n      case \"ylgn\": return d3.schemeYlGn;\n      case \"ylgnbu\": return d3.schemeYlGnBu;\n      case \"ylorbr\": return d3.schemeYlOrBr;\n      case \"ylorrd\": return d3.schemeYlOrRd;\n    }\n    throw new Error(`invalid scheme: ${scheme}`);\n  }\n  return scheme;\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"maybeMode = (function maybeMode(mode) {\n  switch (mode = (mode + \"\").toLowerCase()) {\n    case \"offset\": case \"mirror\": return mode;\n  }\n  throw new Error(`unknown mode: ${mode}`);\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"camelize = (function camelize(string) {\n  return string\n    .toLowerCase()\n    .split(/-/g)\n    .map(([f, ...r]) => `${f.toUpperCase()}${r.join(\"\")}`)\n    .join(\"\");\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"localeFormat = (function localeFormat(locale, format) {\n  return date => date.toLocaleString(locale, format);\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"wave = (function wave({\n  min = 0,\n  max = 1, \n  shift = 0,\n  period = 24 * 6, // matching the default 10-minute interval\n  noise = 0.2,\n  pow = 1,\n  round = false\n} = {}) {\n  return interval.range(start, stop).map((date, i) => {\n    const t = (Math.sin((i - shift) / period * 2 * Math.PI) + 1) / 2;\n    const n = Math.random();\n    let value = +min + (max - min) * (t ** pow * (1 - noise) + n * noise);\n    if (round) value = Math.round(value);\n    return {date, value};\n  });\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"add = (function add(first, ...series) {\n  return first.map(({date, value}, i) => ({date, value: value + d3.sum(series, s => s[i].value)}));\n})","pinCode":false}}}],"version":"2.19.1"}