{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# d3.autoType\n\n[d3-dsv](https://github.com/d3/d3-dsv) supports *automatic type inference*. When you parse a CSV file, it can optionally detect common data types such as numbers, dates and booleans, and convert values to the corresponding JavaScript type.\n\nWhy is this useful? If you don‚Äôt perform any type conversion, you‚Äôll get strings.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"untyped = (d3.csv(url))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"untyped[0]","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Strings are fine for inspection, but before you can start working with the data, you typically need to convert strings to an appropriate type.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"\"95.35\" + \"98.84\"","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"95.35 + 98.84","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Prior to automatic type inference, you would write a *row* function. This function is called for each row in the CSV file, taking an object with string values and returning an object with values of the desired types. Thanks to [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) and [destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment), these can be written fairly concisely.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"typed = (d3.csv(url, ({date, close}) => ({date: new Date(date), close: +close})))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"typed[0]","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`While flexible and explicit, row functions can be tedious to write because you have to enumerate the column names and types.\n\nTo use automatic type inference, pass d3.autoType in place of the row function.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"auto = (d3.csv(url, d3.autoType))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"auto[0]","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`So automatic type inference is great‚Ä¶ right? What‚Äôs the catch? ü§î\n\nThe problem is that a value can have ambiguous type and d3.autoType might chose the wrong one. In these cases, you‚Äôll still need to implement your own row function to convert types explicitly. And because automatic type inference cannot be guaranteed to be correct, you should be especially careful using it. Unless you carefully review the results, it could corrupt your data and weaken your analysis or result in a misleading visualization!\n\nLet‚Äôs consider a few more interesting examples by calling d3.autoType directly to inspect how it works.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3.autoType({date: \"2007-04-23\", close: \"93.24\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`For dates, d3.autoType uses ECMAScript‚Äôs [date-time string format](https://www.ecma-international.org/ecma-262/9.0/index.html#sec-date-time-string-format), which is a small subset of ISO 8601. \\`YYYY\\` is a valid ECMAScript date:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"new Date(\"2007\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`However, it‚Äôs also coercible to a number:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"+\"2007\"","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`If the input is both a valid date and a valid number, d3.autoType favors the number. (This is usually what you want, because otherwise a four-digit number would always be converted to a date!)`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3.autoType({date: \"2007\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`When a date-only string such as \\`YYYY-MM-DD\\` is specified, the inferred time is midnight UTC; however, if a date-time string such as \\`YYYY-MM-DDTHH:MM\\` is specified without a time zone, it is assumed to be local time. This is a little confusing, but this is the behavior standardized by ECMAScript (and it‚Äôs consistent with how dates are displayed in Observable).`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3.autoType({date: \"2007-01-01\"}).date.toISOString()","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3.autoType({date: \"2007-01-01T00:00\"}).date.toISOString()","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"new Date(\"2007-01-01T00:00:00Z\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"new Date(\"2007-01-01T00:00:00\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Some values are coercible to numbers but should be preserved as strings. For example, [FIPS county codes](https://en.wikipedia.org/wiki/FIPS_county_code) are five-digit codes that identify U.S. counties. If you use d3.autoType, the conversion to number will strip leading zeroes.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3.autoType({id: \"06075\"})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`There are myriad ways of representing numbers, booleans and dates as strings. d3.autoType only supports a very small and strict subset of formats. For example, none of these values are considered numbers because they are not strictly coercible using JavaScript‚Äôs unary \\`+\\` operator:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3.autoType([\n  \"$1.00\", // currency symbol\n  \"(123)\", // parenthesis\n  \"1,234\", // comma\n  \"12px\" // suffix\n])","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Dates and booleans are likewise strict:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3.autoType([\n  \"January 1, 2018\", // not YYYY-MM-DD\n  \"TRUE\" // not lowercase\n])","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Automatic type inference is *intentionally* limited so that the behavior of d3.autoType is easier to understand and remember, which hopefully means it‚Äôs less surprising. For a given input value, the value is trimmed and then re-assigned as follows:\n\n1. If empty, then \\`null\\`.\n1. If exactly ‚Äútrue‚Äù, then \\`true\\`.\n1. If exactly ‚Äúfalse‚Äù, then \\`false\\`.\n1. If exactly ‚ÄúNaN‚Äù, then \\`NaN\\`.\n1. Otherwise, if coercible to a number, then a number.\n1. Otherwise, if a date-only or date-time string, then a Date.\n1. Otherwise, a string (the original untrimmed value).\n\nTo see d3.autoType in practice, see [this example bar chart](/@d3/bar-chart-race-explained).`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n## Appendix`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"url = (FileAttachment(\"aapl.csv\").url())","pinCode":false}}}],"version":"2.19.1"}