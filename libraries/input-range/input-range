{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`<div style=\"color: grey; font: 13px/25.5px var(--sans-serif); text-transform: uppercase;\"><h1 style=\"display: none\">Range Input / Observable Inputs</h1><a href=\"/@observablehq/inputs\">Observable Inputs</a> › Range · <a href=\"https://github.com/observablehq/inputs/blob/main/README.md#range\">API</a></div>\n\n# Input: Range\n\nA Range input specifies a number between the given *min* and *max* (inclusive). This number can be adjusted roughly by sliding, or precisely by typing. A range input is also known as a slider.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`By default, a Range chooses a floating point number between 0 and 1 with full precision, which is often more precision than desired.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof x = (Inputs.range())","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"x","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The current value of *x* is ${x.toLocaleString(\"en\")}.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The *step* option is strongly encouraged to set the desired precision (the interval between adjacent values). For integers, use *step* = 1. The up and down buttons in the number input will only work if a *step* is specified. To change the extent, pass [*min*, *max*] as the first argument.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof y = (Inputs.range([0, 255], {step: 1}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The *min*, *max* and *step* options affect only the slider behavior, the number input’s buttons, and whether the browser shows a warning if a typed number is invalid; they do not constrain the typed number.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The *value* option sets the initial value, which defaults to the middle of the range: (*min* + *max*) / 2.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof z = (Inputs.range([0, 255], {step: 1, value: 0}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"z","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`To describe the meaning of the input, supply a *label*. A *placeholder* string may also be specified; it will only be visible when the number input is empty.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof gain = (Inputs.range([0, 11], {label: \"Gain\", step: 0.1, placeholder: \"0–11\"}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"gain","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`For more control over typography, the *label* may be an HTML element.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof n = (Inputs.range([1, 10], {label: html`Top <i>n</i>`, step: 1}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can even use a ${tex`\\TeX`} label, if you’re into that sort of thing.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof psir = (Inputs.range([0, 1], {label: tex`\\psi(\\textbf{r})`}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`For an unbounded range, or simply to suppress the range input, you can use Inputs.number instead of Inputs.range. If you don’t specify an initial value, it defaults to undefined which causes referencing cells to wait for valid input.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof m = (Inputs.number([0, Infinity], {step: 1, label: \"Favorite integer\", placeholder: \"\"}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"m","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`If differences in the numeric range are not uniformly interesting — for instance, when looking at log-distributed values — pass a *transform* function to produce a [nonlinear slider](https://mathisonian.github.io/idyll/nonlinear-sliders/). The built-in Math.log and Math.sqrt transform functions are recommended. If you supply a custom function, you should also provide an *invert* function that implements the inverse transform. (Otherwise, the Range will use [Newton’s method](https://en.wikipedia.org/wiki/Newton%27s_method) which may be inaccurate.)`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Inputs.range([1, 100], {transform: Math.log})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Inputs.range([0, 1], {transform: Math.sqrt})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The *format* option allows you to specify a function that is called to format the displayed number. Note that the returned string must be a [valid floating-point number](https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#valid-floating-point-number) according to the HTML specification; no commas allowed!`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof f = (Inputs.range([0, 1], {format: x => x.toFixed(2)}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"f","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`To prevent a Range’s value from being changed, use the *disabled* option.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof d = (Inputs.range([0, 1], {disabled: true}))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d","pinCode":false}}}],"version":"2.19.1"}