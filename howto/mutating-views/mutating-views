{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Mutating Views\n\n<p style=\"background: #fffced; box-sizing: border-box; padding: 10px 20px;\">***Update Feb. 2021:*** *Observable now supports [**synchronized inputs**](/@observablehq/synchronized-inputs)! This notebook will remain for history, but please upgrade to [Observable Inputs](/@observablehq/inputs).*</p>\n\nSay your notebook has some value ${tex`x`}, and the main view of ${tex`x`} is a slider:`","pinCode":false,"dname":"94ae8759-2ae7-4679-80ee-1a13d678a329","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"x","pinCode":false,"dname":"7ec766d4-e12c-4520-9873-f0f0cd2496c2","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"viewof x = (html`<input type=range min=0 max=100 step=1>`)","pinCode":false,"dname":"460db069-6ba5-4c17-9b43-898ace24a911","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`But what if you want more than one control for ${tex`x`}? Since [views are mutable](/@mbostock/views-are-mutable-values), other cells can implement controls that mutate the main view’s value. For example, here are some buttons that increment or decrement ${tex`x`}:`","pinCode":false,"dname":"460ff41d-c0ea-4600-8dbb-eeee01d89089","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const form = html`<form onsubmit=\"return false;\">\n<button name=inc>increment</button>\n<button name=dec>decrement</button>\n</form>`;\n  form.inc.addEventListener(\"click\", () => {\n    ++viewof x.value;\n    viewof x.dispatchEvent(new CustomEvent(\"input\"));\n  });\n  form.dec.addEventListener(\"click\", () => {\n    --viewof x.value;\n    viewof x.dispatchEvent(new CustomEvent(\"input\"));\n  });\n  return form;\n}","pinCode":false,"dname":"f9acae2e-41ef-410c-ac85-e1a8a68518e2","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`After setting the view’s value, dispatch an *input* event to notify the Observable runtime. The runtime will then re-evaluate any referencing cell.\n\nYou can even have secondary views that are synchronized with the primary view. For example, here’s another slider that manipulates the value of ${tex`x`}, and moves if the value of ${tex`x`} changes.`","pinCode":false,"dname":"7ed7d537-11ce-447a-b9db-cc9967368be7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const input = html`<input type=range min=0 max=100 step=1>`;\n  viewof x.addEventListener(\"input\", () => {\n    input.value = viewof x.value;\n  });\n  input.addEventListener(\"input\", () => {\n    viewof x.value = input.value;\n    viewof x.dispatchEvent(new CustomEvent(\"input\"));\n  });\n  return input;\n}","pinCode":false,"dname":"a42d968f-141d-483b-87e6-264b5f713f17","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Secondary views must be careful to avoid circular definitions: this secondary slider references only \\`viewof x\\` and not \\`x\\`, avoiding re-evaluation when ${tex`x`} changes, and instead listening (non-reactively) for *input* events.`","pinCode":false,"dname":"f83fac33-0992-4e17-baf5-8bc7fd0268a4","codeMode":"javascript2"}}}],"version":"2.19.1"}