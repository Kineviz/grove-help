{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# How to require stubborn modules\n`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"note(htl.html`In a rush? Confused? Try the <a href='https://beta.observablehq.com/@tmcw/module-require-debugger'>module require debugger</a> to get some instant answers.`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Requiring modules in Observable is sometimes tricky: there are lots of ways to write and publish JavaScript modules. We use [unpkg](https://unpkg.com/#/) to load external modules when you call \\\\\\`require()\\\\\\`. Modules that include UMD or AMD bundled files work great with Observable.\n\nIf a module doesn't work - it says 'Invalid module' - you might be able to still get it to work. First, go to that module on GitHub: the simplest way to do this is to go to \\\\\\`https://npmjs.org/themodulename\\\\\\` and find the GitHub repository on the right. Some modules won't have that link, and in that case, your best chance is to search GitHub for the module's name.\n\nNow that you've found the repository, look through its code: does it have a UMD or AMD build somewhere in its package that you just need to require? You can also go to \\\\\\`https://unpkg.com/themodulename/\\\\\\` to look for the files in the published package.\n\nIf you do see that, for instance, the module's \\\\\\`main\\\\\\` entry point in its package.json is something like\n\n    require('./otherfile.js');\n\nAnd otherfile.js would work with Observable - it has a UMD or AMD header - then you can change the \\\\\\`require\\\\\\` call in your notebook to something like \\\\\\`require('themodule/otherfile.js')\\\\\\` and require that file directly.\n\nFor example, let's require [Chart.js](http://www.chartjs.org/) - a module that won't work off the bat but does with a little coaxing.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"require(\"chart.js@2.7.1\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`That's not good. But going to [https://unpkg.com/chart.js@2.7.1/](https://unpkg.com/chart.js@2.7.1/) shows a \\`dist\\` folder, and that has a \\`.min.js\\` file of Chart.js: maybe require that instead?`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Chart = (require(\"chart.js@2.7.1/dist/Chart.min.js\"))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Perfect! Now we can make a chart with Chart.js.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{ \n  let c = DOM.canvas(width, width / 1.6);\n  new Chart(c.getContext(\"2d\"), {\n    type: 'line',\n    data: {\n      labels: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\"],\n      datasets: [{\n        label: \"Wow!\",\n        backgroundColor: '#fae',\n        borderColor: '#fae',\n        data: (new Array(9).fill(0)).map(() => Math.random()),\n        fill: false,\n      }]\n    },\n    options: {\n      responsive: false,\n      title:{\n          display:true,\n          text:'Chart.js Line Chart'\n      },\n      tooltips: {\n          mode: 'index',\n          intersect: false,\n      },\n      hover: {\n          mode: 'nearest',\n          intersect: true\n      },\n      scales: {\n        xAxes: [{\n          display: true,\n          scaleLabel: {\n            display: true,\n            labelString: 'Month'\n          }\n        }],\n        yAxes: [{\n          display: true,\n          scaleLabel: {\n            display: true,\n            labelString: 'Value'\n          }\n        }]\n      }\n    }\n  });\n  return c;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`## Requiring modules from bundle.run\n\nSome modules won't have browser builds, but they're still usable by requiring them through [bundle.run](https://bundle.run/), an API that runs [browserify](http://browserify.org/) and [rollup](https://rollupjs.org/) and returns bundles.\n\nFor instance, the [obliterator](https://github.com/Yomguithereal/obliterator) module doesn't include a browser build, but it's written in vanilla JavaScript and uses normal \\`require\\` statements and nothing fancy, so simply requiring it through bundle.run works great: you construct the URL like\n\n    https://bundle.run/module-name@latest\n\nThough we recommend that you specify a version at the end instead of _latest_.\n`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"obliterator = (require('https://bundle.run/obliterator@1.2.1'))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`## Requiring stubborn add-ons\n\nLet's take a look at three.js 'add-ons'. These are not part of the main three.js codebase, but are super useful and often very fun, so we want access to them. OrbitControls is one of them: it lets you easily add mouse controls to a three.js scene such that dragging around on it moves the scene.\n\nChecking out [the code for orbitcontrols on GitHub](https://github.com/mrdoob/three.js/blob/dev/examples/jsm/controls/OrbitControls.js) shows that it doesn't require or import three, and it doesn't use an AMD or UMD module wrapper either. It just gloms on to the \\`THREE\\` variable, which it expects to be around.\n\nWhere there's a will there's a way: we can still do this. The trick is to:\n\n1. Require the module that an add-on wants to glom on to\n2. Then, require the add-on but ignore its inevitable error`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"THREE = {\n  const THREE = (window.THREE = await require(\"three@0.132.2\"));\n  await require(\"three@0.132.2/examples/js/controls/OrbitControls.js\").catch(\n    () => {}\n  );\n  return THREE;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`## Modules that want global configuration\n\nSome libraries like to be configured in one place. For instance, when you include the bignumber.js module - like I use in my [Project Euler](https://beta.observablehq.com/@tmcw/project-euler-https-projecteuler-net) notebook - I usually configure it to print out lots and lots of digits of numbers, instead of formatting them in scientific notation. That's all done by the .config() method off of the main module object.\n\nIn that case, the best practice is to combine _requiring the module_ with _configuring it_ to guarantee that you only have to configure it once and that all cells that use the module get it properly configured. In bignumber.js's case, that looks like:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"BigNumber = {\n  // require bignumber\n  let bn = await require('bignumber.js');\n  // Print out lots and lots of digits\n  bn.config({ EXPONENTIAL_AT: 1e+9 });\n  // return the configured object\n  return bn;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`## Modules that assign a global variable but don't return it\n\nhyperhtml is a good example of this: \\`require\\` fails to return an object, but the window gets hyperHTML attached. In this case, you can use \\`.catch\\` to catch the require failure and instead resolve to a value:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"hyperHTML = (require(\"hyperhtml\").catch(() => window.hyperHTML))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`---\n\n### Appendix`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"import { note }  from 'how-to-require-stubborn-modules/4c18891b086c8c1e'","pinCode":false}}}],"version":"2.19.1"}