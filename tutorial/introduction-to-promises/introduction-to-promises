{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Introduction to Promises\n\nA promise represents a value that is not yet known, but that *will* be known in the future. For example, when you load a file from a web server into a browser, the fileâ€™s contents arenâ€™t available right away: the file must first be transferred over the network. Rather than locking up while the file is downloading, browsers download asynchronously.\n\nThis asynchronous design, essential for fluid interaction and parallel downloads, introduces complexity: code that depends on promised values must wait until the values are resolved rather than running immediately. Fortunately, JavaScriptâ€™s [Promise API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises) (and its companion \\`await\\` operator), make it easier to work with asynchronous values.\n\nPromises are often not created by you. Instead, an asynchronous library method might return a promise, and you need to wait for the promise to resolve (or reject). D3â€™s [d3.csv](https://github.com/d3/d3-fetch/blob/master/README.md#csv) is just such a function: it [fetches](https://fetch.spec.whatwg.org/) a file from another server, parsing [comma-separated values](https://en.wikipedia.org/wiki/Comma-separated_values) into a structured array of objects. d3.csv canâ€™t return the array right away, so it instead returns a Promise.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"data = (d3.csv(\"https://gist.githubusercontent.com/mbostock/ddc6d50c313ebe6edb45519f43358c6c/raw/c443ed14c34c5c1b544949a546dd9d0acd05bad3/temperatures.csv\"))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Did you see the promise? Observable implicitly awaits promises across cell boundaries, so you often donâ€™t need to deal with a promise directly. Cells can return promises, and other cells can simply refer to the values and theyâ€™ll run when the promise resolves.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"data.map(d => +d.Year)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Observableâ€™s standard library has few built-in methods related to Promises.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Promises","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Promises.delay returns a promise that resolves to a given value after a given duration. The promise below resolves to a greeting after three seconds.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Promises.delay(3000, \"Hello, world!\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Promises.tick is similar, except it returns a promise that resolves at the next given interval. Weâ€™ll cover asynchronous generators in a later tutorial, but hereâ€™s how to make a counter that increments every second:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let i = 0;\n  while (true) {\n    yield Promises.tick(1000, ++i);\n  }\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`The implicit await of promises only happens across cell boundaries. So, if you create a promise and then refer to it within the same cell, youâ€™ll see the Promise object and not the resolved value:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let promise = Promises.delay(3000, \"Hello, \");\n  return promise + \"world!\"; // ðŸ’¥ Oops!\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can use the \\`await\\` operator to pause the execution of code in the current cell while you wait for a promise to resolve:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let greeting = await Promises.delay(3000, \"Hello, \");\n  return greeting + \"world!\";\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Equivalently, you can use *promise*.then to chain promises:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Promises.delay(3000, \"Hello, \").then(greeting => greeting + \"world!\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Promises are also used in a few other standard library methods. For example, if you require a third-party library from npm (or use dynamic import), youâ€™ll get a promise to the loaded module.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"d3 = (require(\"d3-fetch@1\"))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Some libraries and methods use asynchronous callbacks. For example, the browser built-in [setTimeout](https://developer.mozilla.org/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout) doesnâ€™t return a promise like Promises.delay; instead it calls the specified *callback* function after the specified *delay*. To use callbacks in Observable, you should adapt to promises using the Promise constructor. For example:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"Timeâ€™s up!\");\n  }, 5000);\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can use *promise*.catch to handle rejected promises.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(new Error(\"ðŸ˜±\"))\n  }, 1000);\n}).catch(e => \"caught the error! \" + e.message)","pinCode":false}}}],"version":"2.19.1"}