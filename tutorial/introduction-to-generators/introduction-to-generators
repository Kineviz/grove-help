{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Introduction to generators`","pinCode":false,"dname":"2a806aae-5b5c-43a7-b42f-07ea71001800","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"canvas","pinCode":false,"dname":"073013c2-bb94-4bdf-8114-7c210978980e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Observable uses [generators](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Generator) to represent values that change over time. Generators enable interaction, animation, realtime data streaming, and all the other exciting, dynamic capabilities of Observable notebooks.\n\nThe simplest generator is a cell that [yields](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/yield) a single value.`","pinCode":false,"dname":"4da65514-9710-4756-9487-c8253fb455d1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"yield 42","pinCode":false,"dname":"e7d45999-6cef-46ad-939f-97df2e8cc940","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`This behaves no differently than a plain expression cell.`","pinCode":false,"dname":"b9696216-cf8e-4ef3-b51f-7269ff28d4ef","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"42","pinCode":false,"dname":"c582e3cc-6b42-4730-9867-a425cebc0b45","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`A more interesting case is a cell that repeatedly yields [promises](/@mbostock/introduction-to-promises) to control when each new value resolves. (That is, to specify *when* the cell’s value changes.) For example, to define a value that starts at zero and increments once per second, use a while-true loop and [Promises.delay](https://github.com/observablehq/stdlib/blob/master/README.md#Promises_delay).`","pinCode":false,"dname":"4d400c01-4aa6-4bef-bdf0-6eeeef84e6de","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let i = 0;\n  while (true) {\n    yield Promises.delay(1000, ++i);\n  }\n}","pinCode":false,"dname":"52ce30b8-1658-48d1-a2b1-e2feb97759e1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Or, use an [async generator](/@mbostock/introduction-to-asynchronous-iteration) cell by combining [await](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await) and yield.`","pinCode":false,"dname":"052702a4-40f6-48d2-91bf-4521d5df4a24","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let i = 0;\n  while (true) {\n    await Promises.delay(1000);\n    yield ++i;\n  }\n}","pinCode":false,"dname":"aba6fa20-3559-4a2b-9a4e-3de73b14b156","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`When a yielded value resolves, referencing cells are [automatically rerun](/@observablehq/how-observable-runs), even if the new value is the same as the old one.`","pinCode":false,"dname":"99308747-f719-447b-a326-09972b95f6ab","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"tick = {\n  while (true) {\n    yield Promises.delay(1000);\n  }\n}","pinCode":false,"dname":"9d28d632-3ec6-4a00-9faf-96ad5a445f42","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"tick, md`This number updates once per second: \\`${Math.random()}\\``","pinCode":false,"dname":"2b9c5852-513f-4a35-8846-aea662300846","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Observable waits until the yielded value resolves before pulling the next value from the generator. The generator cell is magically suspended (paused) until Observable requests the the next value, at which point the cell resumes exactly where it left off. In effect, there’s an implicit await when you yield a promise.`","pinCode":false,"dname":"154aab67-4708-4c00-a935-64cbb778045b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const div = html`<div style=\"transition:background 250ms linear;height:33px;font-size:10px;text-align:center,line-height:33px\"><span class=\"r\">5</span><span class=\"g\">4</span><span class=\"b\">6</span></div>`;\n  yield div;\n  while (true) {\n     div.style.background = `rgb(${parseInt(Math.random()*255)},${parseInt(Math.random()*255)},${parseInt(Math.random()*255)})`;\n    div.querySelector(\".r\").style.color = `rgb(${parseInt(Math.random()*255)},${parseInt(Math.random()*255)},${parseInt(Math.random()*255)})`;\n    div.querySelector(\".g\").style.color = `rgb(${parseInt(Math.random()*255)},${parseInt(Math.random()*255)},${parseInt(Math.random()*255)})`;\n    div.querySelector(\".b\").style.color = `rgb(${parseInt(Math.random()*255)},${parseInt(Math.random()*255)},${parseInt(Math.random()*255)})`;\n    yield Promises.delay(1000, div);\n//     div.style.background = \"white\";\n//     yield Promises.delay(1000, div);\n//     div.style.background = \"red\";\n//     yield Promises.delay(1000, div);\n//     div.style.background = \"green\";\n//     yield Promises.delay(1000, div);\n//     div.style.background = \"blue\";\n//     yield Promises.delay(1000, div);\n  }\n}","pinCode":false,"dname":"b5de2051-68b5-41bb-b864-bacc58a0a39a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`If a generator cell yields the same DOM element as it did previously, Observable doesn’t touch the DOM. This makes yielding an element repeatedly an efficient [animation strategy](/@mbostock/animation-loops).\n\nThe previously-resolved value continues to be visible to other cells until the newly-yielded value resolves: in other words, a generator cell’s apparent value is the *most-recently resolved* value. For example, if you have a slowly-incrementing counter, you can reference it from another cell and see the current count instantly, rather than waiting for the next tick.`","pinCode":false,"dname":"e784d29a-c17d-457b-9b78-3366c9d5c215","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"minutes = {\n  let i;\n  yield i = 0;\n  while (true) yield Promises.delay(60000, ++i);\n}","pinCode":false,"dname":"83493c60-ce33-4313-87fb-1330bd594be4","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"minutes","pinCode":false,"dname":"f912571b-a7f7-4f31-970a-a0a4d5a9fcb0","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Observable pulls at most one value per animation frame (sixty times per second) from the generator. To define a cell that counts sixty times per second, yield a *resolved* value rather than a pending promise.`","pinCode":false,"dname":"e911b93d-02a1-4b12-ba40-020108f95de5","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let i = 0;\n  while (true) {\n    yield ++i;\n  }\n}","pinCode":false,"dname":"e4ecceea-f5f8-492f-956a-122c81999d4d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`When using an infinite loop, don’t forget to yield! If you never yield, the page will hang and you’ll need safe mode to repair your notebook.\n\nPer the [iterator protocol](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol), the return value of a generator is not considered part of the sequence of values; it is ignored.`","pinCode":false,"dname":"ff8bc18b-1e78-4007-8a9c-bad8e1db499f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  yield 1;\n  yield 2;\n  yield 3;\n  return \"ignored\"; // It’s ignored!\n}","pinCode":false,"dname":"edf5e070-0ab0-4a49-834c-513d3c5c3b10","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Use delegation ([yield-star expressions](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/yield*)) to yield the values of an iterable in order.`","pinCode":false,"dname":"3d063fce-21d8-401d-b505-a88c8d0c42cb","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"yield* [1, 2, 3]","pinCode":false,"dname":"b589d02d-38b9-49d3-8cc9-e7587e02c71c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"yield* new Set([1, 2, 3])","pinCode":false,"dname":"7c2aa9fc-6910-41d2-8b53-c34f9c65de41","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Delegation can also be used to compose iterables, such as the generator cell below which delegates repeatedly to a generator yielding ascending integers from 0 to 99.`","pinCode":false,"dname":"118582fe-d5cf-40ce-b392-88edb3e634de","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  while (true) {\n    yield* range(0, 100);\n  }\n}","pinCode":false,"dname":"ed6fa2c6-cb9e-4493-9f45-1b928cd91de1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Generators that yield promises are the basis for [interactive views](https://observablehq.com/@observablehq/views) in Observable. [Generators.observe](https://github.com/observablehq/stdlib/blob/master/README.md#Generators_observe) takes a push-based data source—code that invokes a callback function whenever there is new data—and converts it to a pull-based generator that yields promises. These promises resolve with the passed value when *next* is called.`","pinCode":false,"dname":"46a9d54f-965b-464a-9cb6-aec4525bf136","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"input = (html`<input type=range>`)","pinCode":false,"dname":"6a515607-2c2e-4e14-a38a-510df653fa92","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Generators.observe(next => {\n  // Yield the input’s initial value.\n  next(input.value);\n\n  // Define an event listener to yield the input’s next value.\n  const inputted = () => next(input.value);\n\n  // Attach the event listener.\n  input.addEventListener(\"input\", inputted);\n\n  // When the generator is disposed, detach the event listener.\n  return () => input.removeEventListener(\"input\", inputted);\n})","pinCode":false,"dname":"88d84e4d-b7c1-4d28-bed6-e067cb3bbb3d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`(This pattern is based on JavaScript’s proposed [Observable type](https://github.com/tc39/proposal-observable/blob/master/README.md).)\n\nIt’s tedious to add and remove event listeners to observe an input’s value, so the standard library provides [Generators.input](https://github.com/observablehq/stdlib/blob/master/README.md#Generators_input) as a convenience method on top of Generators.observe for observing inputs. This method has various smarts for dealing with different input types, such as ranges, checkboxes, and textareas.`","pinCode":false,"dname":"f1f6291e-26ec-42a5-8d71-2bc1324ca24e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Generators.input(input)","pinCode":false,"dname":"5c95b96b-8040-4dc1-8fd2-4a5a647ce697","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Yet you rarely need to use Generators.input directly: Observable’s [viewof operator](https://observablehq.com/@observablehq/views#viewOf_defined) will do it for you! If you name a cell *viewof value*, Observable implicitly creates a second (hidden) cell named *value* using Generators.input.`","pinCode":false,"dname":"bbff0985-3e7a-469f-9119-c0724dafd503","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"viewof value = (html`<input type=range>`)","pinCode":false,"dname":"18c32b73-b22c-43af-9e0d-5a5ad2d0e2c6","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"value","pinCode":false,"dname":"0d44d35a-3fcb-4752-9a21-7773dc04a16a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Many generators are infinite—they represent sequences of values that never end. Observable forcibly terminates the old generator when a generator cell is rerun by calling [*generator*.return](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Generator/return); a generator cell that is invalidated after yielding will thus never resume. To [dispose resources](/@mbostock/disposing-content) that are allocated by a generator cell, use a try-finally block. (See also [invalidation](https://github.com/observablehq/stdlib/blob/master/README.md#invalidation).)`","pinCode":false,"dname":"6421f1bf-3cf2-4cf2-a330-b20c39d534d1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  try {\n    for (let i = 0; i < 100; ++i) {\n      yield i;\n    }\n  } finally {\n    console.log(\"terminated!\");\n  }\n}","pinCode":false,"dname":"c52f7ddb-71ac-488f-bf21-26c9d3df713f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`But wait, there’s more!\n\nIn addition to generator cells, you can define your own reusable generator functions. Some from the standard library are discussed above, but you can define your own generator functions in notebooks, too. For example, here is a function that returns a generator yielding incrementing integers from *start* inclusive to *stop* exclusive.`","pinCode":false,"dname":"05a18a93-30e8-4a07-a580-510fcbf7f65e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"range = (function* range(start, stop) {\n  start = Math.floor(start);\n  stop = Math.ceil(stop);\n  while (start < stop) yield start++;\n})","pinCode":false,"dname":"b1c1b886-f333-46b0-92f0-0e8ca7f17e1a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Calling a generator function returns a new generator object. This generator can then be consumed by the runtime, just like a generator cell.`","pinCode":false,"dname":"7962c4af-72c3-4469-b3d3-ab769ae6aa4b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"range(0, 100)","pinCode":false,"dname":"362ba83f-2b8e-465b-b9c4-aaa5da74ce10","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`In addition to generator functions, the Observable standard library has several built-in reactive variables that are implemented with generators. There’s *width*, which represents the current page width and updates when the window resizes.`","pinCode":false,"dname":"9d7ea8d9-c55f-4e22-8b7b-3efb1784b875","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"width","pinCode":false,"dname":"576e73d7-7f94-4d86-b6a6-9c4ca3e27bc7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`And *now* represents the current time as elapsed milliseconds since UNIX epoch, updating sixty times a second.`","pinCode":false,"dname":"c407e13e-218c-41d3-8123-8a0ec5fdac5e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"now","pinCode":false,"dname":"58d672f8-4def-4ca2-a37a-6747fdb583bb","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`A handy trick is to take the sine of now, which gives a value that oscillates smoothly between +1 and -1.`","pinCode":false,"dname":"418609f5-e1bf-4a24-872e-c714235b6125","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Math.sin(now / 1000)","pinCode":false,"dname":"b4c51414-d54e-4896-95f7-12e944db485b","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`For more reading, here are some highlights from the [techniques collection](/collection/@observablehq/techniques):\n\n* [Custom Generators](/@mbostock/custom-generators)\n* [Generator Cells, Functions and Objects](/@mbostock/generator-cells-functions-and-objects)\n* [Animation Loops](/@mbostock/animation-loops)\n* [Disposing Resources](/@mbostock/disposing-content)\n\nThanks for reading!`","pinCode":false,"dname":"80726a24-a2f6-4161-8656-db9604aaa365","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"height = (300)","pinCode":false,"dname":"5ae91d62-3bf0-472a-a120-7a3360c586f3","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"import { canvas } with { height } from './7335bdad4ae41461'","pinCode":false,"dname":"ad7742e6-d1f1-4316-9071-981e2db3712b","codeMode":"javascript2"}}}],"version":"2.19.1"}