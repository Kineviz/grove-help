{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Introduction to Asynchronous Iteration\n\n<figure><img src=\"${await FileAttachment(\"dali.jpg\").url()}\" title=\"The Persistence of Memory (1931)\"><figcaption>Image: [Salvador Dali](https://en.wikipedia.org/wiki/The_Persistence_of_Memory)</figcaption></figure>\n\nObservable now supports [asynchronous iteration](http://2ality.com/2016/10/asynchronous-iteration.html), an exciting new feature of ES2018 that was [finalized last month](http://2ality.com/2017/02/ecmascript-2018.html) by TC39! You’ll need a [very recent browser](http://kangax.github.io/compat-table/es2016plus/#test-Asynchronous_Iterators_for-await-of_loops) to run this notebook, such as Chrome 63+, Firefox 57+ or Safari Technology Preview 48.\n\n[Asynchronous programming](/@observablehq/introduction-to-promises) (or *async*, for short) allows the browser to do multiple things at the same time, such as to download files and perform complex calculations and respond fluidly to user interaction. Async iteration is a simple extension of this concept: rather than a single async value, you have *multiple* async values and you want to step through them one at a time.\n\nFor instance, say you have several files you want to load into your notebook:`","pinCode":false,"dname":"aec3bbc6-694e-4566-9c5f-cda31db75604","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"files = ([\n FileAttachment(\"2014-acs5-B01003-state-01.json\"),\n FileAttachment(\"2014-acs5-B01003-state-04.json\"),\n FileAttachment(\"2014-acs5-B01003-state-45.json\")\n])","pinCode":false,"dname":"90d67aff-bb62-40aa-8257-1dea073e4d8f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`These files contain population estimates by county for Alabama, Arizona and South Carolina; the exact meaning isn’t important for this notebook. You can load these files in parallel using [*array*.map](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map) and the [FileAttachment API](/@observablehq/file-attachments):`","pinCode":false,"dname":"18d68478-82d9-42f1-b3ba-02eba3d52af9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"promises = (files.map(file => file.json()))","pinCode":false,"dname":"0130d291-b19b-4af2-824f-aff92bacc0c5","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"datasets = (Promise.all(promises))","pinCode":false,"dname":"25f47cff-9181-47ff-9347-302e42d22352","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can wait for these fetches to finish using [Promise.all](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise/all). Either define the all-promise in a separate cell for implicit await, as above, or use an explicit \\`await\\`, as below. Once the files are loaded, you can use normal, *synchronous* iteration—a for loop—to iterate over them and do something, like compute a sum.`","pinCode":false,"dname":"38be8266-3bb8-4ec0-8fe8-4e7c68476b5c","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let total = 0;\n  const datasets = await Promise.all(files.map(file => file.json()));\n  for (const dataset of datasets) {\n    for (let i = 1; i < dataset.length; ++i) {\n      total += +dataset[i][0];\n    }\n  }\n  return total;\n}","pinCode":false,"dname":"95e02f5a-9046-4f47-bebf-d9b84d3d34d6","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`But what if you don’t want to wait until *all* the data is loaded? What if you want to [show intermediate results](/@mbostock/showing-progress) as the files load? Observable uses [generators](https://developer.mozilla.org/docs/Web/JavaScript/Guide/Iterators_and_Generators) to allow cells to yield a value that changes over time. Wait for each file to load, then yield the incremental sum:`","pinCode":false,"dname":"d6e46950-fe32-4dd1-a614-2f4dfb40d890","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let total = 0;\n  for (const file of files) {\n    const dataset = await file.json();\n    for (let i = 1; i < dataset.length; ++i) {\n      total += +dataset[i][0];\n      yield total;\n    }\n  }\n  return total;\n}","pinCode":false,"dname":"751264b8-1476-40da-80ef-6faaa65474e9","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`By using \\`await\\` and \\`yield\\` in the same cell, you’ve written an asynchronous generator. Congrats! 🎉 But wait, there’s more! \n\nThe cell above loads the files serially; it waits for the sum to be computed for the previous file before starting to fetch for the next file. If desired, you can instead start all the fetches simultaneously, and then step through the files one-by-one to compute the sum. As long as the server can handle the load, it’s typically faster to download multiple files concurrently. And unlike Promise.all, we don’t have to wait for all the files to download—just the next file in the list.`","pinCode":false,"dname":"fef63849-ae10-4dad-9527-386538184db3","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let total = 0;\n  for (const promise of files.map(file => file.json())) {\n    const dataset = await promise;\n    for (let i = 1; i < dataset.length; ++i) {\n      total += +dataset[i][0];\n      yield total;\n    }\n  }\n  return total;\n}","pinCode":false,"dname":"b6d85199-d001-4caa-88d6-e417cacec6aa","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`This pattern—iterating over an array of promises, and waiting for each one to resolve sequentially—can be expressed more succinctly using the new for-await-of loop:`","pinCode":false,"dname":"19ae70ea-5349-4a43-a2b2-9a9e3dc59835","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let total = 0;\n  for await (const dataset of files.map(file => file.json())) {\n    for (let i = 1; i < dataset.length; ++i) {\n      total += +dataset[i][0];\n      yield total;\n    }\n  }\n  return total;\n}","pinCode":false,"dname":"ae242d41-9e7e-4db7-b05e-7d8c77b921fd","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`So, async iteration is a way to *consume* (iterate over) async values, while an async generator is a way to *produce* (yield) async values. The async generators above are implicit—they are cells that both \\`await\\` and \\`yield\\`. But you can also make an explicit async generator function in Observable using vanilla JavaScript:`","pinCode":false,"dname":"0af550fc-dd18-41ad-a53f-b69019738475","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"foo = (async function* foo() {\n  for (let i = 1; i <= 1000; ++i) {\n    await Promises.delay(100);\n    yield i;\n  }\n})","pinCode":false,"dname":"9d86bd6c-d19f-44f6-921c-cbeefe453a14","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Calling *foo* returns an async generator that yields an incrementing number every 100 milliseconds. It starts at 1 and goes up to 1000. You can show these numbers in a notebook cell by simply returning the generator:`","pinCode":false,"dname":"e8605ed2-09ff-4dea-bb66-e2a8c7d5353e","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"foo()","pinCode":false,"dname":"aed1f8b6-3eca-48aa-8ff8-df24b5afd30d","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Alternatively, you can read the yielded values “by hand” using the iterator protocol:`","pinCode":false,"dname":"ac188736-5bff-4212-8ee0-2eb204976b9f","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const generator = foo();\n  const iterator = generator[Symbol.asyncIterator]();\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) return;\n    yield value;\n  }\n}","pinCode":false,"dname":"8c6b4953-7519-4810-9618-224b1d2e93ac","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`Observable already supported async generators in a sense: you can also define a (synchronous) generator cell that yields promises. Observable waits until the previous promise resolves before pulling the next one from the generator.`","pinCode":false,"dname":"3080c53e-881b-4d3c-9014-0916c9d85bcf","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"altFoo = (function* altFoo() {\n  for (let i = 0; i < 1000; ++i) {\n    yield Promises.delay(100, i);\n  }\n})","pinCode":false,"dname":"7b6169f7-27eb-4c67-8eee-13680ce80eca","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"altFoo()","pinCode":false,"dname":"654e1df8-b38b-440d-a84a-85aa04e338e8","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`And even a synchronous generator cell in Observable is implicitly async: Observable only pulls one value per animation frame from the generator, giving you fluid sixty frames per second by default.`","pinCode":false,"dname":"34608639-ebd6-44f2-9ab0-486aeaf84965","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"fastFoo = (function* fastFoo() {\n  for (let i = 0; i < 1000; ++i) {\n    yield i;\n  }\n})","pinCode":false,"dname":"b70e77a0-156d-4b36-b531-0b7e92da1c21","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"fastFoo()","pinCode":false,"dname":"b7b2cb01-0114-4361-9caf-e57f153ebac8","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"md`But async generators are a lot more flexible that normal generators: you can both \\`yield\\` and \\`await\\`! (Also, a normal generator must know synchronously whether it’s done, whereas an asynchronous generator can decide whenever it wants to return.) For example, async generators make it very easy to express animations as a sequence of transitions between keyframes: first yield the DOM element you want to display in the notebook, and then repeatedly await for each transition to finish before starting the next.`","pinCode":false,"dname":"e53fc7f1-d966-488d-998c-b9b53e06d5f7","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const w = Math.min(640, width);\n  const h = 320;\n  const r = 20;\n  const t = 1500;\n  const svg = d3.select(DOM.svg(w, h));\n  const circle = svg.append(\"circle\").attr(\"r\", r).attr(\"cx\", w / 4).attr(\"cy\", h / 4);\n  while (true) {\n    yield svg.node();\n    await circle.transition().duration(t).attr(\"cy\", h * 3 / 4).end();\n    await circle.transition().duration(t).attr(\"cx\", w * 3 / 4).end();\n    await circle.transition().duration(t).attr(\"cy\", h * 1 / 4).end();\n    await circle.transition().duration(t).attr(\"cx\", w * 1 / 4).end();\n  }\n}","pinCode":false,"dname":"f7933b76-4566-4513-9574-caaf134a5ad6","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"d3 = (require(\"d3@5\"))","pinCode":false,"dname":"d442aea2-24f1-4410-b6b6-3ecb44c498cc","codeMode":"javascript2"}}}],"version":"2.19.1"}