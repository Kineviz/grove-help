{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Introduction to code\n\nYou can definitely write your own Observable notebook; to do that, you'll be writing code. Let's cover some fundamental ideas that you need to know when writing code in Observable.\n\nObservable notebooks are written in [JavaScript](https://developer.mozilla.org/docs/Web/JavaScript), the Web’s native language, but [with a few changes](/@observablehq/observables-not-javascript). It's helpful if you have some JavaScript experience, but don’t panic if you’re rusty or not an expert! Instead, try tinkering with the code to get a feel for how it works. Even the most wizened developer may yet learn by trial and error. (If you *are* an experienced JavaScript developer, definitely look at [Observable JavaScript](/@observablehq/observable-javascript).)\n\\``","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"notebooksMadeOfCells = (md `## Notebooks are made of cells`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`This notebook, and every Observable notebook, is composed of *cells*. You might be familiar with cells in spreadsheets. Observable cells are similar: they are basic building blocks for the entire document, and can contain text, charts, images, and more. Your code for the notebook is contained in cells, so you need to know how to open, close, and evaluate them. A quick refresher in case you haven't been through one of our tutorials:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md ` ### Opening and closing cells`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`To open a cell, move your mouse pointer over the cell. At the left of the cell, a column of three dots <svg viewBox=\"0 0 8 14\" fill=\"currentColor\" stroke=\"none\" stroke-width=\"1.5\" stroke-linecap=\"round\" stroke-linejoin=\"round\" width=\"8\" height=\"14\"><circle r=\"1.5\" cx=\"4\" cy=\"2\"></circle><circle r=\"1.5\" cx=\"4\" cy=\"7\"></circle><circle r=\"1.5\" cx=\"4\" cy=\"12\"></circle></svg> appears. This is the cell menu. Click the three dots to display the cell menu, then choose **Edit**.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md `To close the cell, click on the cell menu again, then choose **Close**.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md ` ### Evaluating cells\n`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md `To have the results of your edits appear, click the Play (\\`▶︎\\`) button, or type Shift-Enter.\n`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"cellsHeading = (md `## Cells - for expressions, variable definitions, blocks`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Cells come in two primary forms: *expressions* and *blocks*. **Expression** cells are concise and are intended for simple definitions, such as basic arithmetic:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"3 * 3 * 3","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"22/7","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md `or **variable** definitions:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"approximately_two_pi = ((22/7) * 2)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md `Variables can also be strings of text:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"nameOfFish = (\"trout\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"nameOfPerson = (\"Mike\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`**Blocks** are surrounded by curly braces (\\`{\\` \\`}\\`) and are intended for more complex definitions, such as ones involving local variables or loops:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let x = 0;\n  for (let i = 1; i <= 100; ++i) {\n    x += i;\n  }\n  return x;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md `\n|||Note: Shaded cells|\n| --- |--- | --- |\n|||Any cell that you see with visible shading is _pinned_. This leaves the cell open so that the code is visible. A blue pushpin symbol appears in the left margin when you mouseover the cell.|\n`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"variables = (md `## Variables inside blocks are *local* to a cell`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Local variables, like the \\`x\\` seen in the block above, can’t be referenced from other cells; trying to reference an unknown variable results in a runtime error.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"x + 2","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Notice, however, that this error is localized to the broken cell—the rest of the notebook is able to run happily.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md `And, you *are* able to access variables that are not inside blocks:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"nameOfFish","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"objectLiterals = (md `## Special case: Object Literals`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"literalObject = (md`Using curly braces is necessary not only when you are defining a block, but also when you are defining an [object literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals).`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`An [object literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals) is an object with a set of name-value pairs that define properties of the object:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{oilOrAcrylic: \"oil\", name: \"Cobalt Blue\", sizeInMl: 40, priceInUSD: 58.46}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Notice the curly braces (like a block), but with parentheses surrounding the curly braces (unlike a block). If you want to define a cell as an object literal, you must wrap the literal in parentheses to disambiguate it from a block.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"functionHeading = (md `## Functions - for sharing code between cells`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`To repeat operations or share code between cells without copying and pasting, define a **function**:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"greet = (function greet(name) {\n  return `Hello, ${name}!`;\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`This \\`greet\\` function now can be called from other cells to display cheery greetings:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"greet(\"Alice\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"greet(nameOfPerson)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"namingCells = (md `## Naming Cells - allows cells' values to be referenced`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`While local variables are not visible across cell boundaries, you can name cells to reference their values. Here’s a cell named \\`color\\`:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"color = (\"red\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`(This looks identical to a standard JavaScript assignment, but it’s not—it’s *reactive*! More on that [in a bit](#reactivity).) Here’s another cell named \\`letters\\`:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"letters = { return \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\"); }","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`\n| <div style=\"width:860px\">Note: split()</div> | \n| --------------------------------------- |\n| You can read more about split() here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split             |\n`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can refer to \\`letters\\` (or any other named cell) from other cells:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"letters.map(l => l.toLowerCase())","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md `\n| <div style=\"width:860px\">Note: map() and toLowerCase()</div> | \n| --------------------------------------- |\n|More about map(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map|\n|More about toLowerCase(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase|\n`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You needn’t define named cells before you reference them: order your cells however you like, and Observable will automatically execute them in topological order. Out-of-order execution is especially helpful for improving the narrative flow of your notebook.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"fullName = (`${firstName} ${lastName}`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"lastName = (\"Lovelace\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"firstName = (\"Ada\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Cells can also be (re)named via the cell toolbar, as demonstrated in the video below.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"htl.html`<figure style=\"max-width:800px\">\n  <div>\n    <video\n      style=\"width:calc(100% - 27px);border-radius:4px;box-shadow:0 10px 16px rgba(0,0,0,0.33), 0 0 0 1px rgba(0, 0, 0, 0.1); margin-left:20px;margin-bottom:20px\"\n      muted\n      autoplay\n      loop\n      src=${await FileAttachment(\"cell_naming.mp4\").url()}\n    </video>\n  </div>\n  <figcaption style=\"padding-bottom:15px\">(Re)naming cells via the toolbar.</figcaption>\n</figure>`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"reactivity = (md `## Reactivity - cells re-evaluate automatically`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`A cell that references other cells is re-evaluated automatically whenever the referenced values change. Try editing the \\`firstName\\` or \\`lastName\\` cell above, then click the play button (\\`▶︎\\`) to commit your change; \\`fullName\\` updates automatically.\n\nThis *reactivity* is similar to live reload, with an important difference: when a value changes, *only* referencing cells are re-evaluated, rather than the entire notebook. This makes editing more responsive—notebooks update rapidly in response to changes—and you don’t lose independent transient state.\n\nFor example, the cell below computes a random walk, the next cell strokes a line based on the values of the random walk, and the third cell, named \\`stroke\\`, defines the color of the line. If you edit the \\`stroke\\` cell, the random walk will change color, but the shape of the line remains the same. A new walk is only computed if you edit the \\`randomWalk\\` cell.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"randomWalk = {\n  let y = 16, values = [y];\n  for (let x = 0; x < width; ++x) values.push(y = y + (Math.random() - 0.25) * 3 + (16 - y) * 0.1);\n  return values;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const context = DOM.context2d(width, 33);\n  context.beginPath();\n  context.moveTo(0, randomWalk[0]);\n  for (let x = 0; x < width; ++x) context.lineTo(x, randomWalk[x]);\n  context.lineJoin = context.lineCap = \"round\";\n  context.strokeStyle = stroke;\n  context.stroke();\n  return context.canvas;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"stroke = (\"steelblue\")","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`(See what happens if you set \\`stroke\\` equal to the named cell \\`color\\` from the [Naming Cells](#namingCells) section above. Remove the quotation marks if you try this!)`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md `### More about reactivity\n`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`To understand reactivity, think of each cell as a function. For example, the cell \\`sum = a + b\\` becomes a function that takes \\`a\\` and \\`b\\` as arguments, returning their sum; the runtime waits for the value of \\`a\\` and \\`b\\` to resolve and then invokes the \\`sum\\` function. The runtime invokes \\`sum\\` again whenever \\`a\\` or \\`b\\` change.\n\nIf a cell contains a \\`yield\\` statement, the runtime creates a [generator function](https://observablehq.com/@observablehq/introduction-to-generators) instead of a normal function. Likewise if the definition uses \\`await\\`, the runtime creates an [async function](https://observablehq.com/@observablehq/introduction-to-asynchronous-iteration). Reactivity greatly simplifies how you build user interfaces, script animations, and consume realtime data. \n\nIf you want to learn more about generators and asynchronous functions, follow the links in the previous paragraph. Or, return to the main Observable [documentation page](https://observablehq.com/documentation) to browse other topics that interest you!`","pinCode":false}}}],"version":"2.19.1"}