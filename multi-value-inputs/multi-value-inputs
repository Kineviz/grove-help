{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Multi-Value Inputs\n\n<p style=\"background: #fffced; box-sizing: border-box; padding: 10px 20px;\">***Update Dec. 2021:*** *Observable now supports [**Form inputs**](/@observablehq/input-form) that allow you to combine multiple inputs into a single cell for compact display. This notebook will remain for history, but please upgrade to [Observable Inputs](/@observablehq/inputs).*</p>\n\nHere are some ways you can have multiple interactive values in a notebook. The simplest, of course, is to create separate cells for each input:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof r = (html`<input type=range min=0 max=255 step=1 value=127>`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof g = (html`<input type=range min=0 max=255 step=1 value=127>`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof b = (html`<input type=range min=0 max=255 step=1 value=127>`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"html`<div style=\"height:33px;width:33px;background:rgb(${r},${g},${b});\">`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Another strategy is to combine the inputs into a single cell, and then set *element*.value on the root element of the cell, so that whenever an *input* event bubbles up, Observable sees the desired compound value. Below, that compound value has the form \\[*r*, *g*, *b*\\].`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"viewof rgb = {\n  const form = html`<form>\n  <div><input type=range name=r min=0 max=255 step=1 value=127> <i>r</i></div>\n  <div><input type=range name=g min=0 max=255 step=1 value=127> <i>g</i></div>\n  <div><input type=range name=b min=0 max=255 step=1 value=127> <i>b</i></div>\n</form>`;\n  form.oninput = () => form.value = [\n    form.r.valueAsNumber, \n    form.g.valueAsNumber, \n    form.b.valueAsNumber\n  ];\n  form.oninput();\n  return form;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"html`<div style=\"height:33px;width:33px;background:rgb(${rgb.join()});\">`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`If you combine your inputs into a single cell, a cell referencing the compound input will be run whenever any of the inputs are changed. That’s unlike separate cells (*r*, *g* and *b* above), where a cell reference a single input (such as *r*) won’t be run again if a different input (say *g*) changes.\n\nTo combine your inputs into a single cell for compact display, but still have separate cells for more efficient reactivity, you can use Generators.input rather than \\`viewof\\`. However, I only recommend this if you really need it for performance reasons.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"rgbForm = (html`<form>\n  <div><input type=range name=r min=0 max=255 step=1 value=127> <i>r</i></div>\n  <div><input type=range name=g min=0 max=255 step=1 value=127> <i>g</i></div>\n  <div><input type=range name=b min=0 max=255 step=1 value=127> <i>b</i></div>\n</form>`)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"r2 = (Generators.input(rgbForm.r))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"g2 = (Generators.input(rgbForm.g))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"b2 = (Generators.input(rgbForm.b))","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"html`<div style=\"height:33px;width:33px;background:rgb(${r2},${g2},${b2});\">`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`If you found this notebook interesting, you might also like my [Linked Inputs](https://beta.observablehq.com/@mbostock/linked-inputs) and [Nonlinear Slider](https://beta.observablehq.com/@mbostock/nonlinear-slider) notebooks.`","pinCode":false}}}],"version":"2.19.1"}