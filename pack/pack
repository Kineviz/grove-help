{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Circle Packing\n\nThe area of each leaf circle in a circle-packing diagram is proportional its value (here, file size). Although nested circles do not use space as efficiently as a [treemap](/@d3/treemap?collection=@d3/charts), the “wasted” space better reveals the hierarchical structure.`","pinCode":false,"dname":"80754bd5-632c-459f-8539-eee1a2bb85d1","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"chart = (Pack(flare, {\n  value: d => d.size, // size of each node (file); null for internal nodes (folders)\n  label: (d, n) => [...d.name.split(/(?=[A-Z][a-z])/g), n.value.toLocaleString(\"en\")].join(\"\\n\"),\n  title: (d, n) => `${n.ancestors().reverse().map(({data: d}) => d.name).join(\".\")}\\n${n.value.toLocaleString(\"en\")}`,\n  link: (d, n) => n.children\n    ? `https://github.com/prefuse/Flare/tree/master/flare/src/${n.ancestors().reverse().map(d => d.data.name).join(\"/\")}`\n    : `https://github.com/prefuse/Flare/blob/master/flare/src/${n.ancestors().reverse().map(d => d.data.name).join(\"/\")}.as`,\n  width: 1152,\n  height: 1152\n}))","pinCode":false,"dname":"63e75a7c-6e48-4500-91d6-ce09a6ea4623","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"flare = (FileAttachment(\"flare.json\").json())","pinCode":false,"dname":"13296425-09c4-4942-a4e5-b6843d5d8bca","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"howto(\"Pack\")","pinCode":false,"dname":"3d1acb99-fd34-4d2a-b583-a57d466f751a","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"Pack = (function Pack(data, { // data is either tabular (array of objects) or hierarchy (nested objects)\n  path, // as an alternative to id and parentId, returns an array identifier, imputing internal nodes\n  id = Array.isArray(data) ? d => d.id : null, // if tabular data, given a d in data, returns a unique identifier (string)\n  parentId = Array.isArray(data) ? d => d.parentId : null, // if tabular data, given a node d, returns its parent’s identifier\n  children, // if hierarchical data, given a d in data, returns its children\n  value, // given a node d, returns a quantitative value (for area encoding; null for count)\n  sort = (a, b) => d3.descending(a.value, b.value), // how to sort nodes prior to layout\n  label, // given a leaf node d, returns the display name\n  title, // given a node d, returns its hover text\n  link, // given a node d, its link (if any)\n  linkTarget = \"_blank\", // the target attribute for links, if any\n  width = 640, // outer width, in pixels\n  height = 400, // outer height, in pixels\n  margin = 1, // shorthand for margins\n  marginTop = margin, // top margin, in pixels\n  marginRight = margin, // right margin, in pixels\n  marginBottom = margin, // bottom margin, in pixels\n  marginLeft = margin, // left margin, in pixels\n  padding = 3, // separation between circles\n  fill = \"#ddd\", // fill for leaf circles\n  fillOpacity, // fill opacity for leaf circles\n  stroke = \"#bbb\", // stroke for internal circles\n  strokeWidth, // stroke width for internal circles\n  strokeOpacity, // stroke opacity for internal circles\n} = {}) {\n\n  // If id and parentId options are specified, or the path option, use d3.stratify\n  // to convert tabular data to a hierarchy; otherwise we assume that the data is\n  // specified as an object {children} with nested objects (a.k.a. the “flare.json”\n  // format), and use d3.hierarchy.\n  const root = path != null ? d3.stratify().path(path)(data)\n      : id != null || parentId != null ? d3.stratify().id(id).parentId(parentId)(data)\n      : d3.hierarchy(data, children);\n\n  // Compute the values of internal nodes by aggregating from the leaves.\n  value == null ? root.count() : root.sum(d => Math.max(0, value(d)));\n\n  // Compute labels and titles.\n  const descendants = root.descendants();\n  const leaves = descendants.filter(d => !d.children);\n  leaves.forEach((d, i) => d.index = i);\n  const L = label == null ? null : leaves.map(d => label(d.data, d));\n  const T = title == null ? null : descendants.map(d => title(d.data, d));\n\n  // Sort the leaves (typically by descending value for a pleasing layout).\n  if (sort != null) root.sort(sort);\n\n  // Compute the layout.\n  d3.pack()\n      .size([width - marginLeft - marginRight, height - marginTop - marginBottom])\n      .padding(padding)\n    (root);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [-marginLeft, -marginTop, width, height])\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\")\n      .attr(\"font-family\", \"sans-serif\")\n      .attr(\"font-size\", 10)\n      .attr(\"text-anchor\", \"middle\");\n\n  const node = svg.selectAll(\"a\")\n    .data(descendants)\n    .join(\"a\")\n      .attr(\"xlink:href\", link == null ? null : (d, i) => link(d.data, d))\n      .attr(\"target\", link == null ? null : linkTarget)\n      .attr(\"transform\", d => `translate(${d.x},${d.y})`);\n\n  node.append(\"circle\")\n      .attr(\"fill\", d => d.children ? \"#fff\" : fill)\n      .attr(\"fill-opacity\", d => d.children ? null : fillOpacity)\n      .attr(\"stroke\", d => d.children ? stroke : null)\n      .attr(\"stroke-width\", d => d.children ? strokeWidth : null)\n      .attr(\"stroke-opacity\", d => d.children ? strokeOpacity : null)\n      .attr(\"r\", d => d.r);\n\n  if (T) node.append(\"title\").text((d, i) => T[i]);\n\n  if (L) {\n    // A unique identifier for clip paths (to avoid conflicts).\n    const uid = `O-${Math.random().toString(16).slice(2)}`;\n\n    const leaf = node\n      .filter(d => !d.children && d.r > 10 && L[d.index] != null);\n\n    leaf.append(\"clipPath\")\n        .attr(\"id\", d => `${uid}-clip-${d.index}`)\n      .append(\"circle\")\n        .attr(\"r\", d => d.r);\n\n    leaf.append(\"text\")\n        .attr(\"clip-path\", d => `url(${new URL(`#${uid}-clip-${d.index}`, location)})`)\n      .selectAll(\"tspan\")\n      .data(d => `${L[d.index]}`.split(/\\n/g))\n      .join(\"tspan\")\n        .attr(\"x\", 0)\n        .attr(\"y\", (d, i, D) => `${(i - D.length / 2) + 0.85}em`)\n        .attr(\"fill-opacity\", (d, i, D) => i === D.length - 1 ? 0.7 : null)\n        .text(d => d);\n  }\n\n  return svg.node();\n})","pinCode":false,"dname":"f2e08aee-0829-4da9-81c8-9770c426e499","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"CirclePacking = (Pack)","pinCode":false,"dname":"a2706814-7bf2-43b2-bdf7-00e4025f44ad","codeMode":"javascript2"}}},{"type":"codeTool","data":{"codeData":{"value":"import { howto }  from 'pack/example-components'","pinCode":false,"dname":"3006499f-d4ba-47bd-9b7f-77a55d07e85d","codeMode":"javascript2"}}}],"version":"2.19.1"}