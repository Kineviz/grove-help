{"blocks":[{"type":"codeTool","data":{"codeData":{"value":"md`# Invalidation\n\nTo free up resources when a cell is re-evaluated, such as cancelling timers or disposing WebGL contexts, use the \\`invalidation\\` promise from the [standard library](https://observablehq.com/@observablehq/stdlib). This promise resolves when the current cell is re-evaluated: when the cell’s code changes, when it is run using Shift-Enter, or when a referenced input changes.\n\nHere’s \\`invalidation\\` being used to terminate a timer loop:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const div = html`<div>`;\n  let request = requestAnimationFrame(function tick() {\n    div.textContent = Date.now();\n    request = requestAnimationFrame(tick);\n  });\n  invalidation.then(() => cancelAnimationFrame(request));\n  return div;\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`If the cell above didn’t handle invalidation, then the page would get slower each time the cell were re-evaluated because many timer loops would run simultaneously! This is especially noticeable when a cell starting the timer loop references other cells such as sliders.\n\nThe cell above is contrived to demonstrate invalidation. A more idiomatic way of implementing a timer loop in Observable is a generator:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  const div = html`<div>`;\n  while (true) {\n    div.textContent = Date.now();\n    yield div;\n  }\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`Or even simpler, use \\`now\\`:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"html`<div>${now}`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can also implement disposal using a generator: if the generator yields the \\`invalidation\\` promise, it will wait until the cell is re-evaluated, at which point [*generator*.return](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Generator/return) is invoked by the runtime. You can then dispose of the cell’s resources in a try-finally block.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  ++mutable count; // This should always be one.\n  yield mutable count === 1\n      ? html`<div style=\"color:green;\">Success!</div>`\n      : html`<div style=\"color:red;\">Failure!</div>`;\n  try {\n    yield invalidation;\n  } finally {\n    --mutable count;\n  }\n}","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"mutable count = (0)","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`A generator can implement disposal without the \\`invalidation\\` promise, too, just by implementing *generator*.return. Using Generators.observe, call the *notify* function to yield a value, then return a *finalize* function to dispose of the cell’s resources. The *finalize* function will only be called when the cell is re-evaluated.`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"Generators.observe(notify => {\n  notify(42);\n  return () => console.log(\"invalidated\");\n})","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"md`You can even implement a generator by hand:`","pinCode":false}}},{"type":"codeTool","data":{"codeData":{"value":"{\n  let done = false;\n  return {\n    next() {\n      if (done) return {done: true};\n      done = true;\n      return {done: false, value: 42};\n    },\n    return() {\n      console.log(\"invalidated\");\n    }\n  };\n}","pinCode":false}}}],"version":"2.19.1"}